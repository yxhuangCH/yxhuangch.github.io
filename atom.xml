<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yxhuang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yxhuangch.github.io/"/>
  <updated>2021-03-31T11:41:31.864Z</updated>
  <id>https://yxhuangch.github.io/</id>
  
  <author>
    <name>yxhuang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 接入 Firebase 笔记</title>
    <link href="https://yxhuangch.github.io/2021/03/31/android-firebase-note/"/>
    <id>https://yxhuangch.github.io/2021/03/31/android-firebase-note/</id>
    <published>2021-03-31T08:45:49.000Z</published>
    <updated>2021-03-31T11:41:31.864Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="一、接入步骤"><a href="#一、接入步骤" class="headerlink" title="一、接入步骤"></a>一、接入步骤</h1><p>参考接入<a href="https://firebase.google.com/docs/analytics?authuser=0" target="_blank" rel="noopener">官网的接入步骤</a></p><h2 id="1-1-Firebase-项目设置"><a href="#1-1-Firebase-项目设置" class="headerlink" title="1.1 Firebase 项目设置"></a>1.1 Firebase 项目设置</h2><p>在 Firebase 的项目设置同添加 android 项目</p><p><img src="/2021/03/31/android-firebase-note/firebase_img_1.png" width="80%" height="80%"></p><p><img src="/2021/03/31/android-firebase-note/firebase_img_2.png" width="80%" height="80%"></p><p><img src="/2021/03/31/android-firebase-note/firebase_img_3.png" width="80%" height="80%"></p><h2 id="1-2-Android-项目中的设置"><a href="#1-2-Android-项目中的设置" class="headerlink" title="1.2 Android 项目中的设置"></a>1.2 Android 项目中的设置</h2><p>在<strong>根项目的 build.gradle</strong> 中添加 classpath，如果使用 kotlin 也要添加</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 添加 kotlin</span></span><br><span class="line">    <span class="keyword">classpath</span> <span class="string">"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"</span></span><br><span class="line">    <span class="comment">// 添加 google 服务</span></span><br><span class="line">    <span class="keyword">classpath</span> <span class="string">'com.google.gms:google-services:4.3.5'</span></span><br><span class="line">    <span class="comment">// 添加 firbase</span></span><br><span class="line">    <span class="keyword">classpath</span> <span class="string">'com.google.firebase:firebase-crashlytics-gradle:2.5.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目主模块的 build.gradle 中添加</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 谷歌 serices 插件</span></span><br><span class="line">apply plugin: <span class="string">'com.google.gms.google-services'</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// firebase 插件</span></span><br><span class="line">apply plugin: <span class="string">'com.google.firebase.crashlytics'</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="keyword">fileTree</span>(dir: <span class="string">"libs"</span>, <span class="keyword">include</span>: [<span class="string">"*.jar"</span>])</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 添加 firebase 的依赖</span></span><br><span class="line">    implementation <span class="string">'com.google.firebase:firebase-crashlytics-ktx:17.4.1'</span></span><br><span class="line">    implementation <span class="string">'com.google.firebase:firebase-analytics-ktx:18.0.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将下载的 google-services.json 文件放入项目中</p><p><img src="/2021/03/31/android-firebase-note/firebase_img_4.png" width="80%" height="80%"></p><h2 id="1-3-接入检测"><a href="#1-3-接入检测" class="headerlink" title="1.3 接入检测"></a>1.3 接入检测</h2><p>在经过上面的两个步骤，启动，检测一下接入是否正常<br>使用命令开启 firebse debug 的日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb shell setprop log.tag.FirebaseCrashlytics DEBUG</span><br><span class="line"></span><br><span class="line">adb logcat -s FirebaseCrashlytics</span><br></pre></td></tr></table></figure><p>将下载的 google-services.json 文件放入项目中</p><p><img src="/2021/03/31/android-firebase-note/firebase_img_5.png" width="80%" height="80%"></p><p>另外可以开启设备调试<br>要在 Android 模拟设备上启用 Analytics（分析）“调试”模式，请执行以下这行命令：</p><blockquote><p>adb shell setprop debug.firebase.analytics.app &lt;软件包名称&gt;</p></blockquote><p>“调试”模式将保持启用状态，直至您通过执行以下这行命令明确停用“调试”模式：</p><blockquote><p>adb shell setprop debug.firebase.analytics.app .none.</p></blockquote><p>在 Firebase 控制台上可以看到调试设备</p><p><img src="/2021/03/31/android-firebase-note/firebase_img_6.png" width="80%" height="80%"></p><h1 id="二、崩溃上报"><a href="#二、崩溃上报" class="headerlink" title="二、崩溃上报"></a>二、崩溃上报</h1><p>崩溃上报分为 java 层崩溃上报和 Native 层上报</p><h2 id="2-1-Java-层崩溃上报"><a href="#2-1-Java-层崩溃上报" class="headerlink" title="2.1 Java 层崩溃上报"></a>2.1 Java 层崩溃上报</h2><p>添加测试崩溃代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">findViewById&lt;TextView&gt;(R.id.tv_test_crash).setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">throw</span> RuntimeException(<span class="string">"test crash "</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看 log 输出</p><p><img src="/2021/03/31/android-firebase-note/firebase_img_7.png" width="80%" height="80%"></p><p>在Firebase 控制台上可以看到崩溃上报的信息</p><p><img src="/2021/03/31/android-firebase-note/firebase_img_8.png" width="80%" height="80%"></p><h2 id="2-2-Native-崩溃上报"><a href="#2-2-Native-崩溃上报" class="headerlink" title="2.2 Native 崩溃上报"></a>2.2 Native 崩溃上报</h2><p><a href="https://firebase.google.com/docs/crashlytics/ndk-reports?authuser=0" target="_blank" rel="noopener">文档地址</a></p><p>在项目依赖中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(dir: &quot;libs&quot;, include: [&quot;*.jar&quot;])</span><br><span class="line">   </span><br><span class="line">    implementation &apos;com.google.firebase:firebase-crashlytics-ktx:17.4.1&apos;</span><br><span class="line">    implementation &apos;com.google.firebase:firebase-analytics-ktx:18.0.2&apos;</span><br><span class="line">    // 添加 ndk 崩溃上报</span><br><span class="line">    implementation &apos;com.google.firebase:firebase-crashlytics-ndk:17.3.0&apos;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Native 崩溃需要在 app 的 build.gradle 中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line"></span><br><span class="line">    release &#123;</span><br><span class="line">        ...</span><br><span class="line">        firebaseCrashlytics &#123;</span><br><span class="line">            ...</span><br><span class="line">            nativeSymbolUploadEnabled true</span><br><span class="line">            strippedNativeLibsDir &apos;nativelibs/stripped/jni&apos; // 已经脱离符号表的 so</span><br><span class="line">            unstrippedNativeLibsDir &apos;nativelibs/unstripped&apos; // 为脱离符号表的 so</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    debug &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        firebaseCrashlytics &#123;</span><br><span class="line">            ...</span><br><span class="line">            nativeSymbolUploadEnabled true</span><br><span class="line">            strippedNativeLibsDir &apos;nativelibs/stripped/jni&apos;</span><br><span class="line">            unstrippedNativeLibsDir &apos;nativelibs/unstripped&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是 crashlytics-ndk 17.3.0 版本，需要加上<br>在 AndroidMainifest.xml 中添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span> <span class="attr">android:allowNativeHeapPointerTagging</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="二、自定义事件上报"><a href="#二、自定义事件上报" class="headerlink" title="二、自定义事件上报"></a>二、自定义事件上报</h1><h1 id="三、Firebase-推送"><a href="#三、Firebase-推送" class="headerlink" title="三、Firebase 推送"></a>三、Firebase 推送</h1><h1 id="五、不同开发环境使用不同的-Firebase"><a href="#五、不同开发环境使用不同的-Firebase" class="headerlink" title="五、不同开发环境使用不同的 Firebase"></a>五、不同开发环境使用不同的 Firebase</h1><h1 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h1><h2 id="6-1-相关文档地址"><a href="#6-1-相关文档地址" class="headerlink" title="6.1 相关文档地址"></a>6.1 相关文档地址</h2><h2 id="6-2-不同环境-Firebase-参考"><a href="#6-2-不同环境-Firebase-参考" class="headerlink" title="6.2 不同环境 Firebase 参考"></a>6.2 不同环境 Firebase 参考</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;一、接入步骤&quot;&gt;&lt;a href=&quot;#一、接入步骤&quot; class=&quot;headerlink&quot; title=&quot;一、接入步骤&quot;&gt;&lt;/a&gt;一、接入步骤&lt;/h1&gt;&lt;p&gt;参考接入&lt;a href=&quot;https://firebase.google.com/
      
    
    </summary>
    
    
      <category term="Android" scheme="https://yxhuangch.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记|《程序员的自我修养》- 02 目标文件</title>
    <link href="https://yxhuangch.github.io/2021/03/28/linker-read-one/"/>
    <id>https://yxhuangch.github.io/2021/03/28/linker-read-one/</id>
    <published>2021-03-28T14:41:30.000Z</published>
    <updated>2021-04-01T03:11:06.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、目标文件的格式"><a href="#一、目标文件的格式" class="headerlink" title="一、目标文件的格式"></a>一、目标文件的格式</h1><p>目标文件是源代码编译后但为进行链接的那些中间文件（Window 的 .obj 和 Linux 下的 .o）</p><p>动态链接库（DLL, Dynamic Linking Library）, Window 是 .dll， Linux 是 .so<br>静态链接库（Static Linking Library）, Window 是 .lib 和 Linux 是 .a</p><p>可执行文件格式是 ELF</p><h1 id="二、目标文件的文件类型"><a href="#二、目标文件的文件类型" class="headerlink" title="二、目标文件的文件类型"></a>二、目标文件的文件类型</h1><p><img src="/2021/03/28/linker-read-one/type.png" width="80%" height="80%"></p><p>命令 file 查看文件的类型格式<br>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; file libdycloudmedia.so </span><br><span class="line">libdycloudmedia.so: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, BuildID[sha1]=2bcf3eae561f0f6ca25b0f2abd0728eef68f9ea3, stripped</span><br></pre></td></tr></table></figure><h1 id="三、目标文件的内容"><a href="#三、目标文件的内容" class="headerlink" title="三、目标文件的内容"></a>三、目标文件的内容</h1><p><img src="/2021/03/28/linker-read-one/obj_type.png" width="80%" height="80%"></p><h2 id="3-1-可执行文件的内容"><a href="#3-1-可执行文件的内容" class="headerlink" title="3.1 可执行文件的内容"></a>3.1 可执行文件的内容</h2><p>程序源代码编译后的机器指令经常被放在<strong>代码段（Code Section）</strong>, 代码段常见的字有 “.code” 或 ”.text”</p><p>全局变量和局部变量数据经常放在<strong>数据段（Data Section）</strong></p><p>总体来说，源程序代码被编译以后主要分成两种段，程序指令和程序数据。代码段属于程序指令，而数据段和.bss 属于程序数据</p><p>将数据和指令分段的好处：</p><ul><li>程序被装载后，数据和指令分别被映射到两个虚拟区域。数据区对于进程是可读写，指令区对于进程是只读，这两个两个区域的权限分别设置为可读写和只读。这样防止程序指令被破坏</li><li>充分利用 CPU 的缓存，提供命中率</li><li>当系统中存在该程序的副本时，可以共享指令，节约内存。</li></ul><p><strong>查看 ELF 各段的基本信息</strong></p><blockquote><p>objdump -h SimpleSection.o<br>-h 将 ELF 文件的各个段的基本信息打印出来</p></blockquote><p><img src="/2021/03/28/linker-read-one/16163130180870.png" width="80%" height="80%"></p><p><strong>查看ELF文件的代码段、数据段、和 BSS 段的长度</strong></p><blockquote><p>size SimpleSection.o</p></blockquote><p><img src="/2021/03/28/linker-read-one/16163131604327.png" width="80%" height="80%"></p><h2 id="3-2-文件头-HEADER"><a href="#3-2-文件头-HEADER" class="headerlink" title="3.2 文件头 HEADER"></a>3.2 文件头 HEADER</h2><p>ELF 目标文件最前面的是 ELF 文件头，它包含描述整个文件的基本属性，例如 ELF 文件版本、目标机器型号、程序入口等</p><p>查看</p><blockquote><p>$readelf -h SimpleSection.o  // linex 用 </p></blockquote><blockquote><p>$otool -h SimpleSection.o  // mac 使用</p></blockquote><p><img src="/2021/03/28/linker-read-one/16163150711009.png" width="80%" height="80%"></p><h2 id="3-3-代码段-text"><a href="#3-3-代码段-text" class="headerlink" title="3.3 代码段 .text"></a>3.3 代码段 .text</h2><p>使用命令下面命令查看</p><blockquote><p>objdump -s -d SimpleSection.o<br>-s 参数表示将所有段的内容以十六进制的方式打印出来<br>-d 参数将所有包含指令的段反汇编</p></blockquote><p><img src="/2021/03/28/linker-read-one/16163111896910.png" width="80%" height="80%"></p><h2 id="3-3-数据段和只读数据段-data"><a href="#3-3-数据段和只读数据段-data" class="headerlink" title="3.3 数据段和只读数据段 .data"></a>3.3 数据段和只读数据段 .data</h2><p>.data 段保存已经初始化了的全局静态变量和局部静态变量</p><p>.rodata 段存放只读数据,(mac 里面是 cstring )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Contents of section __data:</span><br><span class="line"> 0068 54000000 55000000                    T...U...</span><br><span class="line">Contents of section __cstring:</span><br><span class="line"> 0070 25640a00                             %d..</span><br></pre></td></tr></table></figure><h2 id="3-4-BSS-段"><a href="#3-4-BSS-段" class="headerlink" title="3.4 BSS 段"></a>3.4 BSS 段</h2><p>.bss 段存放未初始化的全局变量和局部静态变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Contents of section __bss:</span><br><span class="line">&lt;skipping contents of bss section at [0120, 0124)&gt;</span><br></pre></td></tr></table></figure><h1 id="四、ELF-文件结构描述"><a href="#四、ELF-文件结构描述" class="headerlink" title="四、ELF 文件结构描述"></a>四、ELF 文件结构描述</h1><p><strong>链接过程的本质就是要把多个不同的目标文件之间相互”粘“到一起，或者说像玩具积木一样，可以拼成一个整体</strong></p><p>符号是链接过程的粘合剂</p><h2 id="4-1-重新定位表-rel-text"><a href="#4-1-重新定位表-rel-text" class="headerlink" title="4.1  重新定位表 .rel.text"></a>4.1  重新定位表 .rel.text</h2><p>链接器在处理目标文件时，必须要对目标文件中某些部位进行重定位</p><h2 id="4-2-符号"><a href="#4-2-符号" class="headerlink" title="4.2  符号"></a>4.2  符号</h2><p>链接过程的本质就是把不同的目标文件相互“粘”到一起，拼成一个整体。符号就是链接中的粘合剂，整个链接过程正是基于符号才能正确完成的。</p><p>查看符号表</p><blockquote><p>$ nm SimpleSection.o</p></blockquote><p><img src="/2021/03/28/linker-read-one/16163116226334.png" width="80%" height="80%"></p><p><strong>ELF 符号表结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word st_name;     <span class="comment">// 符号名</span></span><br><span class="line">    Efl32_Addr st_value;    <span class="comment">// 对应的值</span></span><br><span class="line">    Elf32_Word st_size;     <span class="comment">// 符号大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;  <span class="comment">// 符号类型和绑定信息</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other; <span class="comment">// 0, 暂时没有用途</span></span><br><span class="line">    Elf32_Half st_shndx;    <span class="comment">// 符号所在的段</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/28/linker-read-one/sysmbol.png" width="80%" height="80%"></p><h1 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h1><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* fromt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_init_var = <span class="number">84</span>;</span><br><span class="line"><span class="keyword">int</span> global_uninit_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_var = <span class="number">85</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_var2;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    func1(static_var + static_var2 + a + b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mac-使用-readelf"><a href="#Mac-使用-readelf" class="headerlink" title="Mac 使用 readelf"></a>Mac 使用 readelf</h2><p>Mac 上没有 ‘readelf 命令’ 可以使用 ’greadelf‘ 和 ’gobjdump‘<br>安装步骤：</p><ol><li>使用命令<blockquote><p>brew update &amp;&amp; brew install binutils</p></blockquote></li></ol><p>2.路径添加到 ’~/.bash_profile‘ 文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># binutils</span><br><span class="line">export PATH=&quot;/usr/local/opt/binutils/bin:$PATH&quot;</span><br><span class="line">export LDFLAGS=&quot;-L/usr/local/opt/binutils/lib&quot;</span><br><span class="line">export CPPFLAGS=&quot;-I/usr/local/opt/binutils/include&quot;</span><br></pre></td></tr></table></figure><h2 id="Mac-otool替代readelf命令"><a href="#Mac-otool替代readelf命令" class="headerlink" title="Mac otool替代readelf命令"></a>Mac otool替代readelf命令</h2><p>$otool -h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">rg] [--version] &lt;object file&gt; ...</span><br><span class="line">-f print the fat headers</span><br><span class="line">-a print the archive header</span><br><span class="line">-h print the mach header</span><br><span class="line">-l print the load commands</span><br><span class="line">-L print shared libraries used</span><br><span class="line">-D print shared library id name</span><br><span class="line">-t print the text section (disassemble with -v)</span><br><span class="line">-x print all text sections (disassemble with -v)</span><br><span class="line">-p &lt;routine name&gt;  start dissassemble from routine name</span><br><span class="line">-s &lt;segname&gt; &lt;sectname&gt; print contents of section</span><br><span class="line">-d print the data section</span><br><span class="line">-o print the Objective-C segment</span><br><span class="line">-r print the relocation entries</span><br><span class="line">-S print the table of contents of a library (obsolete)</span><br><span class="line">-T print the table of contents of a dynamic shared library (obsolete)</span><br><span class="line">-M print the module table of a dynamic shared library (obsolete)</span><br><span class="line">-R print the reference table of a dynamic shared library (obsolete)</span><br><span class="line">-I print the indirect symbol table</span><br><span class="line">-H print the two-level hints table (obsolete)</span><br><span class="line">-G print the data in code table</span><br><span class="line">-v print verbosely (symbolically) when possible</span><br><span class="line">-V print disassembled operands symbolically</span><br><span class="line">-c print argument strings of a core file</span><br><span class="line">-X print no leading addresses or headers</span><br><span class="line">-m don&apos;t use archive(member) syntax</span><br><span class="line">-B force Thumb disassembly (ARM objects only)</span><br><span class="line">-q use llvm&apos;s disassembler (the default)</span><br><span class="line">-Q use otool(1)&apos;s disassembler</span><br><span class="line">-mcpu=arg use `arg&apos; as the cpu for disassembly</span><br><span class="line">-j print opcode bytes</span><br><span class="line">-P print the info plist section as strings</span><br><span class="line">-C print linker optimization hints</span><br><span class="line">--version print the version of /Users/yxhuang/software/xcode/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、目标文件的格式&quot;&gt;&lt;a href=&quot;#一、目标文件的格式&quot; class=&quot;headerlink&quot; title=&quot;一、目标文件的格式&quot;&gt;&lt;/a&gt;一、目标文件的格式&lt;/h1&gt;&lt;p&gt;目标文件是源代码编译后但为进行链接的那些中间文件（Window 的 .obj 和 L
      
    
    </summary>
    
    
      <category term="读书笔记, 程序员的自我修养" scheme="https://yxhuangch.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记|《程序员的自我修养》- 01 前言</title>
    <link href="https://yxhuangch.github.io/2021/03/28/linker-read-pre/"/>
    <id>https://yxhuangch.github.io/2021/03/28/linker-read-pre/</id>
    <published>2021-03-28T14:37:52.000Z</published>
    <updated>2021-03-30T11:46:19.891Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2021/03/28/linker-read-pre/linker-read-pre.png" width="80%" height="80%"></p><p>图片来自极客时间<a href="https://time.geekbang.org/column/article/94470" target="_blank" rel="noopener">深入浅出计算机原理</a></p><h1 id="学习链接知识的意义"><a href="#学习链接知识的意义" class="headerlink" title="学习链接知识的意义"></a>学习链接知识的意义</h1><ul><li><p><strong>理解链接将帮助你构建大型程序</strong><br>构建大型程序的程序员经常会遇到由于缺少模块、缺少库或者不兼容的库版本引起的连接器错误。除非你理解连接器是如何解析引用、什么是库以及链接器是如何使用库来解析引用的，否则这类错误将令你感到迷惑或挫折。</p></li><li><p><strong>理解链接器将帮助你避免一些危险的编译错误</strong></p></li><li><p><strong>理解链接将帮助你理解语言的作用域是如何实现的</strong><br>例如，全局和局部变量之间的区别是什么？当你定义一个具有 static 属性的变量或者函数时，到底意味着什么</p></li><li><p><strong>理解链接将帮助你理解其他重要的系统概念</strong><br>链接器产生的可执行文件在重要的系统中扮演着关键角色，例如加载和运行程序、虚拟内存、分页和内存映射</p></li><li><p><strong>理解链接将使你能够利用共享库</strong><br>这个在 Android 的动态加载 so 文件以及 Native hook 中会用，我会在后续提供这方面的应用</p></li></ul><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>链接器是把程序的各个部分合并成一个文件，处理器可以将这个文件加载到存储器，并且执行它。</p><p>链接可以在编译的时候有静态编译器来完成，也可以在加载时和运行时有动态链接器完成。</p><p>静态链接器（static linker）以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。</p><p>被编译为位置无关代码的共享库可以加载到任何地方，也可以在运行时被多个进程共享。为了加载、链接和访问共享的函数和数据，应用程序还可以在运行时使用动态链接器。</p><h1 id="链接器的任务"><a href="#链接器的任务" class="headerlink" title="链接器的任务"></a>链接器的任务</h1><p>链接器的主要两个任务是</p><ul><li><strong>符号解析（symbol resolution）</strong></li><li><strong>重定位(relocation)</strong></li></ul><p><strong>符号解析</strong><br>目标文件定义和引用符号，符号解析是将目标文件中的每个全局符号都绑定到一个唯一定义。</p><p><strong>重定位</strong><br>编译器和汇编器生成从地址 0 开始的代码和数据节。<br>链接器通过把每个符号定义与一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指向这个存储器位置，从而重定位这些节</p><h1 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h1><p>目标文件是源代码编译后但为进行链接的那些中间文件（Window 的 .obj 和 Linux 下的 .o）</p><p>目标文件存粹是字节块的集合。</p><p><strong>目标文件的型式</strong></p><ul><li><strong>可重定位目标文件</strong></li><li><strong>可执行目标文件</strong></li><li><strong>共享目标文件</strong></li></ul><h2 id="可重定位的目标文件"><a href="#可重定位的目标文件" class="headerlink" title="可重定位的目标文件"></a>可重定位的目标文件</h2><p>可重定位的目标文件是静态连接器合并成一个可执行的目标文件，它可以加载到存储器中并执行</p><p>可重定位的目标文件包含二进制代码和数据，它是有在编译时与其他可重定位目标文件合并起来，形成一个可执行目标文件</p><h2 id="共享目标文件"><a href="#共享目标文件" class="headerlink" title="共享目标文件"></a>共享目标文件</h2><p>共享目标文件（共享库）是在运行时有动态链接器和加载的，在调用程序被加载和开始执行时，或者需要在程序调用 dlopen 库的函数。</p><p>目标共享文件是一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态加载到存储器并链接。</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>加载器将可以执行文件的内容映射到存储器，并运行这个程序。链接器还可能生出部分链接的可执行文件，这样的文件中有对定义在共享库中的程序和数据的未解析的引用。在加载时，加载器将部分链接的可执行文件映射到存储器，然后调用动态链接器，它通过加载共享库和重定位程序中的引用来完成链接任务。</p><h1 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gcc -c SimpleSection.c  // 生成目标文件</span><br><span class="line">readelf -s link_example.o //查看符号表</span><br><span class="line">objdump -r link_example.o //查看重定位表</span><br><span class="line"></span><br><span class="line">&gt; $readelf -h SimpleSection.o  // linex 用 </span><br><span class="line"></span><br><span class="line">&gt; $otool -h SimpleSection.o  // mac 使用</span><br></pre></td></tr></table></figure><h2 id="Mac-使用-readelf"><a href="#Mac-使用-readelf" class="headerlink" title="Mac 使用 readelf"></a>Mac 使用 readelf</h2><p>Mac 上没有 ‘readelf 命令’ 可以使用 ’greadelf‘ 和 ’gobjdump‘<br>安装步骤：</p><ol><li>使用命令<blockquote><p>brew update &amp;&amp; brew install binutils</p></blockquote></li></ol><p>2.路径添加到 ’~/.bash_profile‘ 文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># binutils</span><br><span class="line">export PATH=&quot;/usr/local/opt/binutils/bin:$PATH&quot;</span><br><span class="line">export LDFLAGS=&quot;-L/usr/local/opt/binutils/lib&quot;</span><br><span class="line">export CPPFLAGS=&quot;-I/usr/local/opt/binutils/include&quot;</span><br></pre></td></tr></table></figure><h2 id="查看-so-的文件格式"><a href="#查看-so-的文件格式" class="headerlink" title="查看 so 的文件格式"></a>查看 so 的文件格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; file libdycloudmedia.so</span><br><span class="line">libdycloudmedia.so: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, BuildID[sha1]=2bcf3eae561f0f6ca25b0f2abd0728eef68f9ea3, stripped</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://fengmuzi2003.gitbook.io/csapp3e/di-er-zhang-zhong-dian-jie-du" target="_blank" rel="noopener">https://fengmuzi2003.gitbook.io/csapp3e/di-er-zhang-zhong-dian-jie-du</a><br><a href="https://www.bilibili.com/video/BV1a54y1k7YE?p=13" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1a54y1k7YE?p=13</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2021/03/28/linker-read-pre/linker-read-pre.png&quot; width=&quot;80%&quot; height=&quot;80%&quot;&gt;&lt;/p&gt;
&lt;p&gt;图片来自极客时间&lt;a href=&quot;https://time.geekbang.org/co
      
    
    </summary>
    
    
      <category term="程序员的自我修养" scheme="https://yxhuangch.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记《修改软件的艺术》</title>
    <link href="https://yxhuangch.github.io/2021/03/13/read-changle-code/"/>
    <id>https://yxhuangch.github.io/2021/03/13/read-changle-code/</id>
    <published>2021-03-13T08:57:02.000Z</published>
    <updated>2021-03-13T14:37:14.246Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2021/03/13/read-changle-code/change_code_1.png" width="80%" height="80%"></p><p>来源 <a href="https://book.douban.com/subject/27151925/" target="_blank" rel="noopener">《修改软件的艺术》</a></p><p>[TOC]</p><p><strong>重点摘要</strong></p><ul><li>优秀的开发者首要考虑的是代码的可维护性</li><li>软件开发者之所以会过度开发，是因为我们害怕某个功能会以我们没有预料的方式使用</li><li>不同层次的抽象可以帮助我们对组件的关系建立起大局观，也可以让我们可以只在需要的时候关注细节</li><li>意外耦合是缺乏优质代码特质的一种体现</li><li>封装就是：让做什么，隐藏如何做</li><li>封装良好的软件是由外而内而不是由内而外设计的</li><li>一部分代码对另一部分 “知道” 得越多，则依赖越重，无论显示的还是隐式的</li><li>软件被阅读的次数比编写次数多</li><li>在写公用的应用程序接口、方法，或者暴露给外部的其他服务，不要在那个方法中放入任何实现。而是将其位委托其他方法</li></ul><h3 id="1-如何做之前先问做什么、为什么做、给谁做"><a href="#1-如何做之前先问做什么、为什么做、给谁做" class="headerlink" title="1. 如何做之前先问做什么、为什么做、给谁做"></a>1. 如何做之前先问做什么、为什么做、给谁做</h3><p>软件开发者需要领域建模，这就是需要我们去学习领域设计的知识；</p><p>开发者需要在善于提出没人想过的问题。这就要要去需要在需求评审的时候提出，多问产品为什么需要这样？出发点是什么？</p><h3 id="2-编写整洁的代码"><a href="#2-编写整洁的代码" class="headerlink" title="2.编写整洁的代码"></a>2.编写整洁的代码</h3><p><img src="/2021/03/13/read-changle-code/clean_code_1.png" width="80%" height="80%"></p><h4 id="内聚"><a href="#内聚" class="headerlink" title="内聚"></a>内聚</h4><p>内聚就是每个片段都只关注一件事，一个类应该只有一个目的；</p><p>不同层次的抽象可以帮助我们对组件的关系建立起大局观，也可以让我们可以只在需要的时候关注细节。</p><blockquote><p>代码的层次从高往下应该是从抽象 -&gt; 实体</p></blockquote><p>内聚的代码更容易理解和查找 bug, 因为每个实体都只处理自身的事物</p><h4 id="松散耦合"><a href="#松散耦合" class="headerlink" title="松散耦合"></a>松散耦合</h4><p>松散耦合的代码不直接依赖它所使用的代码，而是通过一个中间层来调用；</p><p>意外耦合是缺乏优质代码特质的一种体现</p><p>松散耦合的代码让实体之间的副作用更少，而且更容易测试、复用、扩展</p><h4 id="封装良好"><a href="#封装良好" class="headerlink" title="封装良好"></a>封装良好</h4><p>高质量的代码是封装良好的，它隐藏了实现细节</p><p>封装就是：让做什么，隐藏如何做</p><p>封装良好的软件是由外而内而不是由内而外设计的。</p><p>在用对象来实现系统的时候，让每个对象自身和所处的环境复制，系统中的每个对象都有自己的用途</p><p>默认封装，必要时再暴露</p><p>面向接口编程，而不是面向实现编程</p><p>封装良好的代码有助于我们管理复杂度，让调用者不必关系被调用者的实现细节，所以更容易修改</p><h4 id="代码自主"><a href="#代码自主" class="headerlink" title="代码自主"></a>代码自主</h4><p>代码自主，是指让它自己管理自己的职责，不应该互相干预。</p><p>自主的原则是:</p><ul><li>对象应该控制自身的状态</li><li>对象之间不应该相互干预</li></ul><blockquote><p>数据和控制逻辑要分开</p></blockquote><p>自主的代码让我们知道行为应该和它所依赖的数据放到一起</p><h4 id="没有冗余"><a href="#没有冗余" class="headerlink" title="没有冗余"></a>没有冗余</h4><p>软件不应该自我复制，要没有冗余</p><p>没有冗余的代码以为这我们可以只在一个地方修复 bug 和进行更改</p><h3 id="3-最后实现设计"><a href="#3-最后实现设计" class="headerlink" title="3.最后实现设计"></a>3.最后实现设计</h3><h4 id="3-1-阻碍了可修改代码的产生"><a href="#3-1-阻碍了可修改代码的产生" class="headerlink" title="3.1 阻碍了可修改代码的产生"></a>3.1 阻碍了可修改代码的产生</h4><p>在实现设计之前，需用明确是什么阻碍了可修改代码的产生</p><h5 id="缺乏封装"><a href="#缺乏封装" class="headerlink" title="缺乏封装"></a>缺乏封装</h5><p>一部分代码对另一部分 “知道” 得越多，则依赖越重，无论显示的还是隐式的</p><h5 id="滥用继承"><a href="#滥用继承" class="headerlink" title="滥用继承"></a>滥用继承</h5><p>少用继承，多用组合</p><h5 id="僵化的实现"><a href="#僵化的实现" class="headerlink" title="僵化的实现"></a>僵化的实现</h5><p>当缺乏抽象的时候，两个或多个行为之间会有太多的共同性，导致冗余和非必要的复杂性，让代码难以使用。僵化的实现难以修改，难以在日后添加新的差异性</p><h5 id="内联代码"><a href="#内联代码" class="headerlink" title="内联代码"></a>内联代码</h5><h5 id="没有正常阻隔一拉"><a href="#没有正常阻隔一拉" class="headerlink" title="没有正常阻隔一拉"></a>没有正常阻隔一拉</h5><h4 id="3-2-编写可持续性代码的注意事项"><a href="#3-2-编写可持续性代码的注意事项" class="headerlink" title="3.2 编写可持续性代码的注意事项"></a>3.2 编写可持续性代码的注意事项</h4><ul><li>删除死代码</li><li><p>保持名称更新<br>重命名方法和类，以保持“见名知意”的良好名称。随着开发的进行，对事物理解的加深，代码功能也会随之变化。如果代码变化了，随之亦要重新命名来反应代码更新后的行为</p></li><li><p><strong>集中决策</strong><br>将分散大代码集中一处。让决策集中。如果决策需要改变，只会影响一处。<br>如果类和方法都非常内聚，业务规则就分散到系统的各个部分，让其难以理解和修改。将各种流程的规则集中化。将业务规则集中到一起。这样就消除了很多冗余，让代码更容易理解和维护</p><blockquote><p>这个规则是在平时写代码的时候容易被忽略的，需要重视</p></blockquote></li><li><p>对所有外部依赖建立并使用抽象</p></li><li>在建领域模型的时候，需要确保建模完整，对这些类组织，让它们有合理的行为和属性</li></ul><h4 id="3-3-意图导向编程"><a href="#3-3-意图导向编程" class="headerlink" title="3.3 意图导向编程"></a>3.3 意图导向编程</h4><p>意图导向编程是指，将所有公用接口的代码都委托到不同的方法中，就可以消除这些重复工作。这样代码读起来就像一段脚本或一个菜单，因为它保持同样抽象层次。</p><p>在写公用的应用程序接口、方法，或者暴露给外部的其他服务，不要在那个方法中放入任何实现。而是将其委托给其他方法。</p><h4 id="3-4-降低复杂度"><a href="#3-4-降低复杂度" class="headerlink" title="3.4 降低复杂度"></a>3.4 降低复杂度</h4><p>一个条件（if）语句的复杂度是 2， 两个 if 语句就是的复杂度是4， 这种复杂度是指数型增长的。复杂度越高，越容易出现 bug 所以要降低复杂度</p><p>降低复杂度的手段一般有多态，将条件语句的创建放在对象的创建阶段而不是使用阶段</p><p>以下内容来自极客时间的专栏 《左耳听风》，第 38| 编程范式游记（9）编程的本质</p><p><strong>任何算法都会有两个部分，一个是 Logic 部分，这是用来解决实际问题的。另一个是 Control 部分，这是用来决定用什么策略来解决问题。Logic 部分是真正意义上解决问题的算法，而 Control 部分只是影响解决这个这个问题的效率。程序运行的效率问题和程序的逻辑其实是没有关系的。我们认为，如果将 Logic 和 Control 部分有效地分开，那么代码就会变得更容易改进和维护</strong></p><p><strong>有效分离 Logic 、Control 和 Data 是写出好程序的关键所在</strong></p><p><img src="/2021/03/13/read-changle-code/logic_control.png" width="80%" height="80%"></p><p>Logic 是程序复杂度的下限，然后，我们未来控制程序，需要再搞出很多控制代码，于是 Logic + Control 的相互交织成为了最终程序的复杂度</p><ul><li>业务逻辑的复杂度决定了代码的复杂度；</li><li>控制逻辑的复杂度 + 业务逻辑的复杂度 ==&gt; 程序代码的混乱不堪</li><li>绝大多数程序复杂混乱的根本原因：<strong>业务逻辑与控制逻辑的耦合</strong></li></ul><p>分离 logic 和 control</p><ul><li><p><strong>State Machine 状态机</strong> </p><ul><li>状态定义</li><li>状态变迁条件</li><li>状态的 action</li></ul></li><li><p><strong>DSL</strong></p><ul><li>HTML, SQL, Unix Shell Script, AWK, 正则表达式</li></ul></li><li><strong>编程范式</strong><ul><li>面向对象：委托、策略、桥接、修饰、 IoC/DIP、MVC…</li><li>函数式编程：修饰、管道、拼装</li><li>逻辑推导式编程： Prolog</li></ul></li></ul><p><strong>编程的本质：</strong></p><ul><li><strong>Logic 部分是真正有意义的 （What）</strong></li><li><strong>Control 部分只影响 Logic 部分的效率 （How）</strong></li></ul><h3 id="5-重构遗留代码"><a href="#5-重构遗留代码" class="headerlink" title="5.重构遗留代码"></a>5.重构遗留代码</h3><p>重构是指在不改变外部行为的前提下对代码的内部结构进行重组和重新包装</p><p>怎样重构</p><blockquote><p>1.只要代码运行没有问题，就不要去修改它，能正常运行，就不用重构<br>2.只有在那些要修改、添加新功能的代码，才进行重构<br>3.重构的时候要遵循渐进式、小步修改的原则</p></blockquote><p><strong>何时进行重构</strong></p><ul><li><p>当关键代码维护不善的时候<br>别去碰遗留代码是明智的，但是关键代码难以理解变成累赘时，就需要进行清理</p></li><li><p>当唯一理解代码的人没空的时候</p></li><li><p>当有信息可以揭示更好的设计的时候</p></li><li><p>当修复bug 的时候</p></li><li><p>当需要添加新功能的时候</p></li><li><p>当需要为遗留代码写文档的时候</p></li><li><p>当重构比重写容易的时候</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2021/03/13/read-changle-code/change_code_1.png&quot; width=&quot;80%&quot; height=&quot;80%&quot;&gt;&lt;/p&gt;
&lt;p&gt;来源 &lt;a href=&quot;https://book.douban.com/subject/2
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://yxhuangch.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>对 Firebase 上 NDK 无符号解决的记录</title>
    <link href="https://yxhuangch.github.io/2020/12/19/firebase-no-ndk-symbol/"/>
    <id>https://yxhuangch.github.io/2020/12/19/firebase-no-ndk-symbol/</id>
    <published>2020-12-19T08:57:02.000Z</published>
    <updated>2021-03-13T14:34:40.077Z</updated>
    
    <content type="html"><![CDATA[<p>记 Firebase 上无 NDK 符号表解决的过程</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在 项目上线之后，Firebase 的后台收到音视频上报的崩溃。在项目中音视频以 so 文件的形式集成近项目。在后台上报页面，看不到符号表的匹配。</p><p><img src="/2020/12/19/firebase-no-ndk-symbol/img_1.png" width="100%" height="100%"></p><p>而这个 bug 占据了我们 bug 的 Top 1 位置。</p><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p><strong>第一步 重新检查集成 Firebase 的过程</strong><br>出现问题的时候，我们第一步是去<a href="https://firebase.google.com/docs/crashlytics/get-started?platform=android" target="_blank" rel="noopener">官网</a>重新看集成 Firebase 的过程<br>检查了发现没有问题。</p><p><strong>第二步 重新查看官网文档</strong><br>经过第一步的检查，集成的步骤是没有问题的, 我们再次看看官网文档，有没有新的发现。<br>在官网的 <a href="https://firebase.google.com/docs/crashlytics/ndk-reports" target="_blank" rel="noopener">Get Android NDK crash reports</a> 的这个章节发现了新的线索。</p><p>我们的音视频 so 是自己开发的，用 gradle 的方式集成到工程里面。这个相当于外部独立的依赖，所以，需要用 Firebase 提供的 unstrippedNativeLibsDir 的属性上传未剥离符号表的 so.<br>在第三步 <a href="https://firebase.google.com/docs/crashlytics/ndk-reports#upload-external-dependencies" target="_blank" rel="noopener">Step 3(optinal): Upload symbols for external dependencies</a> 中</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// …</span></span><br><span class="line">android &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            firebaseCrashlytics &#123;</span><br><span class="line">                nativeSymbolUploadEnabled <span class="keyword">true</span></span><br><span class="line">                unstrippedNativeLibsDir ‘path<span class="regexp">/to/u</span>nstripped<span class="regexp">/parent/</span>dir’</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且需要对应的 so 架构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unstrippedNativeLibsDir/</span><br><span class="line"> +- x86/</span><br><span class="line">      |</span><br><span class="line">      +- libfoo.so</span><br><span class="line">      +- libbar.so</span><br><span class="line"> +- arm64/</span><br><span class="line">      |</span><br><span class="line">      +- libfoo.so</span><br><span class="line">      +- libbar.so</span><br></pre></td></tr></table></figure><p>加了之后用命令执行 task 上传符号表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew app:assembleDebug app:uploadCrashlyticsSymbolFileDebug -debug | grep &quot;\[com.google.firebase.crashlytics\]&quot;</span><br></pre></td></tr></table></figure><p>上面的命令跑了，之后发现我们上传符号表失败了，是因为网络的原因</p><p><strong>第三步 Android　Studio 配置科学上网</strong><br>我们在国内需要对 Android Studio 的 gradle 设置代理</p><p>设置 Android Studio 的代理<br>查看 SS 的端口<br><img src="/2020/12/19/firebase-no-ndk-symbol/img_2.png" width="100%" height="100%"></p><p>设置代理<br><img src="/2020/12/19/firebase-no-ndk-symbol/img_3.png" width="100%" height="100%"></p><ul><li>1.找到 HTTP Proxy 设置选项</li><li>2.选择 Manual proxy configuration</li><li>3.填写 ss 的 ip 和端口</li><li>4.检测是否设置成功 check connection<br>输入 google 的网址，检测是否设置成功，如果成功了，会弹窗连接成功的弹窗</li></ul><p><strong>第四步 去 Firebas 的github 上看 issues</strong><br>经过上面三步还是不行，我们就去 <a href="https://github.com/firebase/firebase-android-sdk" target="_blank" rel="noopener">Firebase 的 github</a> 上看看其他人有没有遇到同样的问题。<br>这里顺便说一句，如果是开源的项目，遇到问题，查看它的 issues 也是解决问题的切入点，你遇到的问题，别人也会遇到，看看 issues 或许能找到解决办法或者提示。</p><p>在 Firebase 的 issues 中搜索 ndk symbol，可以找到相关 ndk 符号表的内容。然后在一条中找到相关的内容 <a href="https://github.com/firebase/firebase-android-sdk/issues/1978" target="_blank" rel="noopener">Native crash reports missing symbol information (file name, line number, function name) #1978</a>，有人也遇到相应的问题，就是在 Firebase 上没有看到相应的符号表。<br>他的解决办法，就是把已剥离和未剥离符号表的 so 都放到对于的目录下，用于上传符号表</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">debug &#123;</span><br><span class="line">    minifyEnabled <span class="keyword">false</span></span><br><span class="line">    signingConfig signingConfigs.debugsign</span><br><span class="line"></span><br><span class="line">    firebaseCrashlytics &#123;</span><br><span class="line">        nativeSymbolUploadEnabled <span class="keyword">true</span></span><br><span class="line">        strippedNativeLibsDir <span class="string">'nativelibs/stripped'</span>  <span class="comment">// 剥离符号表的 so</span></span><br><span class="line">        unstrippedNativeLibsDir <span class="string">'nativelibs/unstripped'</span> <span class="comment">// 未剥离符号表的 so</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew app:assembleDebug app:uploadCrashlyticsSymbolFileDebug -debug | grep &quot;\[com.google.firebase.crashlytics\]&quot;</span><br></pre></td></tr></table></figure><p>这次命令执行的结果显示,上传符号表成功了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Crashlytics symbol file uploaded successfully</span><br></pre></td></tr></table></figure><p>经过测试 native 的崩溃后，发现符号表打印是上传成功了，但是还是没有显示出来。</p><p>到这来，我们已经没有办法。为什么明明符号表已经上传成功了，但是还是解析不到呢。</p><p><strong>第四步 配对 So 和项目 NDK 版本</strong></p><p>至此，唯一的可能性是我们上传的符号表和 native 的崩溃对不上，导致 Firebase 无法解析。</p><p>通过一番查找，发现我们构建 SO 用的 NDK 版本是 19， 构建项目是的 NDK 是 21 版本。<br>我们将项目的 NDK 版本也改成 19。</p><p>最后发现可以了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上传非工程直接编译 so 的符号表</p><p><strong>第一 按照官方文档集成 Firebase</strong><br>在项目级别的 build.gradle 中,添加 firebase</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    classpath &apos;com.google.firebase:firebase-crashlytics-gradle:2.1.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 app 的 build.gradle 中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.google.firebase.crashlytics&apos;</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">buildTypes &#123;</span><br><span class="line"></span><br><span class="line">    release &#123;</span><br><span class="line">        ...</span><br><span class="line">        firebaseCrashlytics &#123;</span><br><span class="line"></span><br><span class="line">            nativeSymbolUploadEnabled true</span><br><span class="line">            strippedNativeLibsDir &apos;nativelibs/stripped&apos;</span><br><span class="line">            unstrippedNativeLibsDir &apos;nativelibs/unstripped&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    debug &#123;</span><br><span class="line">         ...</span><br><span class="line">        firebaseCrashlytics &#123;</span><br><span class="line">            nativeSymbolUploadEnabled true</span><br><span class="line">            strippedNativeLibsDir &apos;nativelibs/stripped&apos;</span><br><span class="line">            unstrippedNativeLibsDir &apos;nativelibs/unstripped&apos;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>strippedNativeLibsDir 是放已经剥离符号表的 so, unstrippedNativeLibsDir 是放未剥离符号表的 so</p><p><img src="/2020/12/19/firebase-no-ndk-symbol/img_4.png" width="100%" height="100%"></p><p>在 module 的 build.gradle 中添加依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// google 崩溃上报</span></span><br><span class="line">    implementation <span class="string">'com.google.firebase:firebase-analytics-ktx:17.4.4'</span></span><br><span class="line">    <span class="comment">// Add the Firebase Crashlytics SDK.</span></span><br><span class="line">    implementation <span class="string">'com.google.firebase:firebase-crashlytics:17.1.1'</span></span><br><span class="line">    implementation <span class="string">'com.google.firebase:firebase-crashlytics-ndk:17.1.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步 确保网络没有问题</strong><br>如果是在国内，要设置Android studio 代理</p><p><strong>第三步 确保编译 so 的 NDK 和项目的 NDK 版本一致</strong></p><p><strong>第三步 用命令行上传符号表</strong><br>用命令行上传符号表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew app:assembleDebug app:uploadCrashlyticsSymbolFileDebug -debug | grep &quot;\[com.google.firebase.crashlytics\]&quot;</span><br></pre></td></tr></table></figure><p>跑命令的时候观察打印，如果打印出</p><blockquote><p>Crashlytics symbol file uploaded successfully</p></blockquote><p>则说明已经上传成功</p><p><strong>第四步 测试 bug</strong><br>打开 firebase 的 log 打印</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb shell setprop log.tag.FirebaseCrashlytics DEBUG</span><br><span class="line"></span><br><span class="line">adb logcat -s FirebaseCrashlytics</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记 Firebase 上无 NDK 符号表解决的过程&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在 项目上线之后，Firebase 的后台收到音视频上报的崩溃。在项目中
      
    
    </summary>
    
    
      <category term="firebase" scheme="https://yxhuangch.github.io/tags/firebase/"/>
    
  </entry>
  
  <entry>
    <title>Java 虚拟机（五）- 链接模式</title>
    <link href="https://yxhuangch.github.io/2020/08/16/jvm-link-model/"/>
    <id>https://yxhuangch.github.io/2020/08/16/jvm-link-model/</id>
    <published>2020-08-16T09:00:56.000Z</published>
    <updated>2020-08-16T11:58:57.623Z</updated>
    
    <content type="html"><![CDATA[<p>这是我们 Java 虚拟机系列文件的第五篇，连接模型</p><p>从程序员的角度来看，理解 Java 虚拟机体系结构最重要的方面之一就是连接模型</p><h3 id="1-解析和动态扩展"><a href="#1-解析和动态扩展" class="headerlink" title="1.解析和动态扩展"></a>1.解析和动态扩展</h3><p>编译一个 Java 程序之后，会得到程序中每个类和接口的独立 class 文件。它们是通过接口符号（harbor）相互联系的，或者用 Java API 的 class 文件相联</p><p>class 文件把它所有的引用符号都保存在常量池中。在程序运行时，如果某个特定的接口符号将要被使用，它通过解析，根据符号引用查到实体，再把符号引用替换成一个直接引用的过程。<br>因为所有的符号引用都保存在常量池中，这个过程也被称为<strong>常量池解析。</strong></p><p>解析分成早解析和迟解析</p><ul><li>早解析：程序在它的 main() 方法尚未被调用时就已经完全连接了</li><li>迟解析：JVM 在执行程序的第一次用到这个符号引用的最后一刻才去解析</li></ul><p><strong>连接包括把符号引用替换成直接引用，还包括检查正确性和权限。</strong></p><p>检查内容包含：</p><ul><li>那个类是否存在</li><li>该类是返回有权访问那个类</li><li>那个类中是否存在名称相符的字段</li><li>那个字段的类型和期望的类型是否相符</li><li>本类是否有权访问那个字段</li><li>那个字段的确是一个类变量，而不是一个实例变量。</li></ul><p><strong>Java 虚拟机为每一个装载的类和接口都保存一份独立的常量池。</strong></p><h3 id="2-类加载器和双亲委托机制"><a href="#2-类加载器和双亲委托机制" class="headerlink" title="2.类加载器和双亲委托机制"></a>2.类加载器和双亲委托机制</h3><p>看前面的文章</p><h3 id="3-常量池的解析"><a href="#3-常量池的解析" class="headerlink" title="3.常量池的解析"></a>3.常量池的解析</h3><p> 被初始化为编译时常量的静态 final 变量的引用，在编译时被解析为常量值的一个本地拷贝</p><h3 id="4-其他类型的解析"><a href="#4-其他类型的解析" class="headerlink" title="4.其他类型的解析"></a>4.其他类型的解析</h3><h4 id="4-1-解析-CONSTANT-Class-info-入口"><a href="#4-1-解析-CONSTANT-Class-info-入口" class="headerlink" title="4.1 解析 CONSTANT_Class_info 入口"></a>4.1 解析 CONSTANT_Class_info 入口</h4><p><img src="/2020/08/16/jvm-link-model/jvm_link_1.png" width="50%" height="20%"></p><ul><li><ol><li>装载类或任何超类<br>在第一步，虚拟机确定被引用的已经被装载进当前命名空间，并为该类标记为初设装载器。<br>如果当前类加载器是启动类加载器，虚拟机根据不同的实现，使用不同的方式加载。<br>如果是自定义类加载器，则通过 loadClass() 方法完成加载请求，把需要加载的类的全限定名作为参数传递进去。</li></ol></li></ul><p>被引用的类型被加载了，虚拟机检测它的二进制数据。如果类型是一个类，并且不是 java.lang.Object， 虚拟机根据类的数据得到它的直接超类的全限定名。如果超类没有被加载进当前命名空间。如果没有，先加载超类。一旦超类被加载了，虚拟在此检查超类的二进制数据来找到它的超类。一直重复到超类是 Object 为止。</p><p>一旦一个类型被加载进当前命名空间，而且通过递归，所有该类型的超类和超接口都会被加载成功。</p><ul><li><p>2.检查访问权限<br>如果没有访问权限，会抛出 <strong>IllegalAccessError 异常</strong>，符号引用解析失败。</p></li><li><p>3.检验类型<br>校验过程要去虚拟机加载的类型符合 Java 语言的语义</p></li><li><p>4.准备阶段<br>准备阶段虚拟机为类变量以及实现不同有差别的数据结构分配内存</p></li><li><p>5.解析类型<br>解析类型的阶段是可以选择的，根据参数选择解析或不解析</p></li><li><p>6.初始化类型<br>超类必须在子类之前被初始化，必须确保它的所有超类都被初始化，从 Object 开始沿着继承的结构向下处理，直达被引用的类。<br>如果一个类型没有被连接，在初始化之前必须被连接。<br>超类必须被初始化，超接口是不必的</p></li></ul><p>如果虚拟机因为内存不足，在初始化的时候会抛出 <strong>OutOfMemoryError 异常</strong></p><h4 id="4-2-解析-CONSTANT-Fieldref-info-入口"><a href="#4-2-解析-CONSTANT-Fieldref-info-入口" class="headerlink" title="4.2 解析 CONSTANT_Fieldref_info 入口"></a>4.2 解析 CONSTANT_Fieldref_info 入口</h4><p>要解析 CONSTANT_Fieldref_info 入口，必须要先解析 CONSTANT_Class_info 入口。</p><p><img src="/2020/08/16/jvm-link-model/jvm_link_2.png" width="70%" height="70%"></p><p>搜索 Field 字段过程</p><ul><li>1.虚拟机在被引用的类型中查找具有指定的名称和类型的字段。如果找到，则成功。</li><li>2.否则虚拟机检测类型的直接实现或拓展的接口，以及递归地检查它们的超接口。如果找到，则成功</li><li>3.否则检测直接超类，并且递归地检查类型的所有超类。如果找到，则成功</li><li>4.最后都找不到，则字段搜索失败</li></ul><p>如果没有在被引用的类或者它的任何超类中找到名字和类型都符合的字段，虚拟机就会抛出 <strong>NoSuchFieldError 异常</strong><br>如果字段搜索成功，但是当前类没有权限访问该字段，虚拟机就会抛出 <strong>IllegalAccessError 异常</strong></p><p>成功了之后，虚拟机就会把这个入口标记为已解析，并在这个常量池入口的数据中放上指向这个字段的直接引用。</p><h4 id="4-3-解析-CONSTANT-Methodref-info-入口"><a href="#4-3-解析-CONSTANT-Methodref-info-入口" class="headerlink" title="4.3 解析 CONSTANT_Methodref_info 入口"></a>4.3 解析 CONSTANT_Methodref_info 入口</h4><p>要解析 CONSTANT_Methodref_info 入口，必须要先解析 CONSTANT_Class_info 入口。</p><p>解析 methodref 的过程</p><ul><li>1.如果被解析的类型是一个接口，而非类，虚拟机就会抛出 <strong>IncompatibleClassChangeError 异常</strong></li><li>2.如果解析的类型是一个类。虚拟机检查被引用的类是否有一个符合指定名字以及描述符。如果找到，则成功</li><li>3.否则虚拟机检查是否这个类直接实现了任何接口，并递归地检查由类型直接实现的接口的超接口，查看是否有方法符合指定的名称和描述符。如果找到，则成功</li><li>4.最后都找不到，则方法搜索失败</li></ul><p>如果没有在被引用的类和它的任何超类中找到名称、返回类型、参数数量和类型都符合的方法，虚拟机就会抛出 <strong>NoSuchMethodError 异常</strong></p><p>成功了之后，虚拟机就会把这个入口标记为已解析，并在这个常量池入口的数据中放上指向这个字段的直接引用。</p><h4 id="4-4-解析-CONSTANT-InterfaceMethodref-info-入口"><a href="#4-4-解析-CONSTANT-InterfaceMethodref-info-入口" class="headerlink" title="4.4 解析 CONSTANT_InterfaceMethodref_info 入口"></a>4.4 解析 CONSTANT_InterfaceMethodref_info 入口</h4><p>要解析 CONSTANT_InterfaceMethodref_info 入口，必须要先解析 CONSTANT_Class_info 入口。</p><p>解析 InterfaceMethodref 的过程</p><ul><li>1.如果被解析的类型是一个类，而非接口，虚拟机就会抛出 <strong>IncompatibleClassChangeError 异常</strong></li><li>2.如果解析的类型是一个接口。虚拟机检查被引用的接口是否有符合指定名称和描述符。如果找到，则成功</li><li>3.否则虚拟机检查接口的直接超接口，并且递归地检查接口的所有超接口，以及 java.lang.Object 类来查找符合指定名称和描述符的方法。如果找到，则成功</li><li>4.最后都找不到，则接口方法搜索失败</li></ul><p>如果在被引用的接口和它的任何超类型中都招标名称、返回类型、参数数量和类型都符合的方法，虚拟机就会抛出 <strong>NoSuchMethodError 异常</strong></p><p>成功了之后，虚拟机就会把这个入口标记为已解析，并在这个常量池入口的数据中放上指向这个字段的直接引用。</p><h4 id="4-5-解析-CONSTANT-String-info-入口"><a href="#4-5-解析-CONSTANT-String-info-入口" class="headerlink" title="4.5 解析 CONSTANT_String_info 入口"></a>4.5 解析 CONSTANT_String_info 入口</h4><p>要解析 CONSTANT_String_info 入口，虚拟机必须把一个指定内部字符串对象的引用放置到被解析的常量池入口数据中。该字符串对象必须按照 sting_index 项在 CONSTANT_String_info 中指明 CONTANT_Utf8_info 入口所指定的字符顺序组织。</p><p>要完成 CONSTANT_String_info 入口的解析过程，虚拟机应把指向被拘留的字符串对象的引用放置到被解析的常量表入口数据中。</p><h3 id="5-直接引用"><a href="#5-直接引用" class="headerlink" title="5.直接引用"></a>5.直接引用</h3><p><strong>常量池解析的最终目标是把符号引用替换为直接引用</strong></p><p><strong>直接存储的格式是用指针</strong></p><p>指向类、类变量和类方法的直接引用是指向方法区的本地指针<br>指向实例变量和实例方法的直接引用都是偏移变量。实例变量的直接引用是从对象的映像开始算起到这个实例位置的偏移量。实例方法的直接引用是方发表的偏移量。</p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://book.douban.com/subject/1138768/" target="_blank" rel="noopener">《深入 Java 虚拟机》</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是我们 Java 虚拟机系列文件的第五篇，连接模型&lt;/p&gt;
&lt;p&gt;从程序员的角度来看，理解 Java 虚拟机体系结构最重要的方面之一就是连接模型&lt;/p&gt;
&lt;h3 id=&quot;1-解析和动态扩展&quot;&gt;&lt;a href=&quot;#1-解析和动态扩展&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JVM(三)  类的生命周期</title>
    <link href="https://yxhuangch.github.io/2020/08/05/jvm-class-lifetime/"/>
    <id>https://yxhuangch.github.io/2020/08/05/jvm-class-lifetime/</id>
    <published>2020-08-05T00:15:49.000Z</published>
    <updated>2020-08-10T23:33:39.163Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><strong>Java 虚拟机通过装载、连接和初始化一个 Java 类型</strong></p><p>类的完整生命周期包括：加载、验证、准备、解析、初始化、使用、卸载</p><p><img src="/2020/08/05/jvm-class-lifetime/jvm_lift_1.png" width="50%" height="50%"></p><p>图 1-1 类的完整生命周期</p><p>重要的阶段</p><ul><li><strong>装载</strong>：把二进制型式的 Java 类型读入 Java 虚拟机中</li><li><strong>连接</strong>：把已经读入虚拟机中的二进制型式的类型数据合并到虚拟机的运行时状态中去<br>连接分三个子步奏：验证、准备和解析</li><li><strong>初始化</strong>：给类变量赋予适当的初始值</li></ul><p><img src="/2020/08/05/jvm-class-lifetime/jvm_lift_2.png" width="50%" height="50%"></p><h2 id="1-装载"><a href="#1-装载" class="headerlink" title="1 装载"></a>1 装载</h2><p><strong>装载</strong>：就是把二进制型式的 Java 类型读入 Java 虚拟机中</p><p>装载有三个基本动作组成</p><ul><li>通过该类型的完全限定名，产生一个代表该类型的二进制数据流；</li><li>解析这个二进制数据流为方法区内的数据结构</li><li>创建一个表示该类型的 java.lang.Class 类的实例</li></ul><p>类型二进制数据流产生的方式有多种<br>例如：</p><ul><li>从本地文件系统装载一个 Java Class 文件</li><li>通过网络下载一个 Java Class 文件</li><li>动态为某个类型计算其 Class 文件格式</li></ul><p>创建类型就是把一个类型的二进制数据解析为方法区中的内部数据结构，并在堆上建立一个 Class 对象的过程。</p><h2 id="2-连接"><a href="#2-连接" class="headerlink" title="2 连接"></a>2 连接</h2><p><strong>连接</strong>：就是把已经读入虚拟机中的二进制型式的类型数据合并到虚拟机的运行时状态中去<br>连接分三个子步奏：验证、准备和解析</p><h3 id="2-1-验证"><a href="#2-1-验证" class="headerlink" title="2.1 验证"></a>2.1 验证</h3><p>验证的目的就是确认类型符合 Java 语言的语义，并且它不会危及虚拟机的完整性。<br>在验证阶段，虚拟机规范会说明在每种情况下应该抛出哪种异常，例如找不到相应的类，就会抛出 NoClassDefFoundError 异常。</p><p>在验证阶段，会使用 class 文件检验器保证装载的 class 文件内容是正确的结构。这里的 class 文件内容见 <a href="https://www.jianshu.com/p/ea05cea9c1be" target="_blank" rel="noopener">Java 虚拟机（二）：Class 文件结构</a></p><p>class 文件检验器会进行四趟扫描检测；</p><p><strong>验证扫描检测</strong></p><h4 id="第一趟扫描：class-文件的结构检查"><a href="#第一趟扫描：class-文件的结构检查" class="headerlink" title="第一趟扫描：class 文件的结构检查"></a>第一趟扫描：class 文件的结构检查</h4><ul><li>时间：第一趟扫描是在类被装载是进行的</li><li>目的：它的主要目的是保证字节序列正确地定义一个类型，并且必须遵循 Java 的 class 文件的固定格式，这样它才能被编译成在方法区中的内部数据结构</li><li>检验的内容：<ul><li>是否是魔数 OxCAFEBABE 开头</li><li>class 文件的主版本号和次版本号是否在虚拟机的支持范围之内</li><li>。。。</li></ul></li></ul><h4 id="第二趟扫描-语义检查"><a href="#第二趟扫描-语义检查" class="headerlink" title="第二趟扫描: 语义检查"></a>第二趟扫描: 语义检查</h4><ul><li>时间：在连接过程时进行</li><li>目的：确保类型数据遵从 Java 编程语言的语义</li><li>检验的内容：<ul><li>检查 class 文件每个组成部分，确保它们是否是其所属类型的实例，结构是否正确；</li><li>检查 final 的类不能拥有子类；</li><li>检查 final 的方法不能被覆盖；</li><li>确保在类型和超类型直接没有不兼容的方法声明（比如两个方法拥有同样的名字，参数在数量、类型、类型上都相同，但是返回类型不同）</li><li>检查这个类是否有父类（除了 Object 类以外的所有类，都必须有一个超类）</li></ul></li></ul><h4 id="第三趟扫描：-字节码验证"><a href="#第三趟扫描：-字节码验证" class="headerlink" title="第三趟扫描： 字节码验证"></a>第三趟扫描： 字节码验证</h4><ul><li>时间：在连接过程时进行</li><li>目的：确保程序语义是合法的、符合逻辑的</li><li>检验内容：对数据流和控制流分析</li></ul><h4 id="第四趟扫描：-符号引用的验证"><a href="#第四趟扫描：-符号引用的验证" class="headerlink" title="第四趟扫描： 符号引用的验证"></a>第四趟扫描： 符号引用的验证</h4><ul><li>时间：在<strong>动态连接阶段</strong>进行的</li><li>目的：确保被引用的类、字段及其方法确实存在</li><li>检查内容：<ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li><li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段</li><li>符合引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问</li></ul></li></ul><p>符号引用验证的目的是确保解析动作能正常执行，如果没有通过验证、就会抛出 java.lang.InCompatibleClassChangeErro 的子类，例如 java.lang.ILLegalAccessError, java.lang.NoSuchFieldError, java.lang.NoSuchMethodError 等。</p><h3 id="2-2-准备"><a href="#2-2-准备" class="headerlink" title="2.2 准备"></a>2.2 准备</h3><p>在准备阶段，Java 虚拟机会为 <strong>类变量</strong>分配内存，设置默认值。</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value 是 A 的类变量，类型是 int, 在准备阶段，变量 value 赋值为默认值 0;至于将值 123 赋值给 value 是在初始化阶段。</p><p>基本类型的默认值</p><p><img src="/2020/08/05/jvm-class-lifetime/jvm_lift_3.png" width="50%" height="50%"></p><h3 id="2-3-解析（可选）"><a href="#2-3-解析（可选）" class="headerlink" title="2.3 解析（可选）"></a>2.3 解析（可选）</h3><p><strong>解析过程就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用的过程</strong></p><p>常量池解析的最终目标是把符号引用替换为直接应用。</p><p>直接应用的数据格式：</p><ul><li>指向类型、类变量和类方法的直接引用是 指向方法区的本地指针</li><li>指向实例变量和实例方法的直接引用是 偏移量</li></ul><p>实例变量的直接引用可能是从对象的映像开始算起到这个实例变量位置的偏移量；<br>实例方法的直接应用是到方法表的偏移量。</p><h2 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3 初始化"></a>3 初始化</h2><p>在初始化阶段是为类变量赋予正确的值。<br>这里的”正确“初始值指的是程序员希望这个类变量所具备的起始值。</p><p>在 Java 代码中，一个正确的初始值是通过类变量初始化语句或者静态初始化给出的。<br>那上面的例子为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value 在准备阶段已经赋予默认值 0， 在初始化阶段，就会设值为 123</p><h3 id="3-1-初始化步骤"><a href="#3-1-初始化步骤" class="headerlink" title="3.1 初始化步骤"></a>3.1 初始化步骤</h3><p>初始化一个类包含两个步骤：</p><ul><li>如果类存在直接超类，且直接超类没有被初始化，就先初始化直接超类；</li><li>如果类存在一个类初始化方法，就执行此方法</li></ul><h3 id="3-2-主动使用和被动使用"><a href="#3-2-主动使用和被动使用" class="headerlink" title="3.2 主动使用和被动使用"></a>3.2 主动使用和被动使用</h3><p>这里的主动使用和被动使用，指的是虚拟机初始化 class 类时机时的使用方式，所有的 java 虚拟机实现必须在每个类或接口首次主动使用时初始化。</p><p>下面六种情形符合主动使用的要求：</p><ul><li>当创建某个类的新实例时（或者通过字节码中执行 new 指令；或者通过不明确的创建、反射或者反序列化）</li><li>当调用某个类或接口的静态字段，或者对该字段赋值（在字节码中，执行 getstatic 或 putstatic 指令时），用 final 修饰的静态字段除外，它被初始化编译时的常量表达式</li><li>当调用 Java API 的某个反射方法时，比如类 Class 中的方法或者 java.lang.reflect 包中类方法</li><li>当初始化某个类的子类时（某个类初始化时，要求它的超类已经被初始化了）</li><li>当虚拟机启动时某个被标明为启动的类（即含有 main() 方法的那个类</li></ul><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestParent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sleep = (<span class="keyword">int</span>)(Math.random() * <span class="number">3.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span>  <span class="keyword">int</span> touch = (<span class="keyword">int</span>)(Math.random() * <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"TestParent was initialized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestChild</span> <span class="keyword">extends</span> <span class="title">TestParent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> crying = <span class="number">1</span> + (<span class="keyword">int</span>)(Math.random() * <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"TestChild was initialized."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"TestClient was initialized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hours = TestChild.sleep;</span><br><span class="line">        System.out.println(<span class="string">"TestClient hours: "</span> + hours);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TestClient was initialized</span><br><span class="line">TestParent was initialized</span><br><span class="line">TestClient hours: 1</span><br></pre></td></tr></table></figure><p>从上面的例子可以看出， TestChild 没有被初始化，TestParent 被初始化了。</p><h3 id="3-3-接口的初始化"><a href="#3-3-接口的初始化" class="headerlink" title="3.3 接口的初始化"></a>3.3 接口的初始化</h3><p><strong>当 Java 虚拟机初始化一个类时，要求它所有父类都已经被初始化，但是这条规则不适用于接口</strong></p><ul><li>在初始化一个类时，并不会初始化它所实现的接口</li><li>在初始化一个接口时，并不会先初始化它的父接口</li></ul><p>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java 虚拟机通过装载、连接和初始化一个 Java 类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类的完整生命周期包括：加载、验证、准备、解析、初始化、使用、卸载&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/08/05/jvm-clas
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JVM(四)类加载器</title>
    <link href="https://yxhuangch.github.io/2020/07/07/java-class-loader/"/>
    <id>https://yxhuangch.github.io/2020/07/07/java-class-loader/</id>
    <published>2020-07-07T00:25:25.000Z</published>
    <updated>2020-08-12T15:37:18.260Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-类加载器"><a href="#1-类加载器" class="headerlink" title="1.类加载器"></a>1.类加载器</h2><p><img src="/2020/07/07/java-class-loader/jvm_1.png" width="50%" height="50%"></p><p>Java 虚拟机的主要任务是装载 class 文件并且执行其中的字节码。类加载器的作用是加载程序或 Java API 的 class 文件，并将字节码加载到执行引擎。</p><p>在加载 class 文件时， 为了防止加载进来恶意的代码，需要在类的加载器体系中去实现一些规则，保证在 Java 沙箱的安全模型。</p><p>类加载其在 Java 沙箱中主要是三方面</p><ul><li>守护了被信任的类库的边界 - 通过双亲委托机制实现</li><li>防止恶意代码去干涉善意代码 - 通过不同的命名空间去实现</li><li>将代码归入某类（称为保护域,该类确定了代码可以进行哪些操作。</li></ul><p>这三方面我们后续会一个一个说</p><p>首先我们先看看在 Java 虚拟机中的整个类加载器体系</p><h2 id="2-双亲委托机制"><a href="#2-双亲委托机制" class="headerlink" title="2. 双亲委托机制"></a>2. 双亲委托机制</h2><p>类加载器体系守护了被信任的类库的边界，这是通过分别使用不同的类加载器加载可靠包和不可靠包来实现的。</p><p>这些不同的类加载器之间的依赖关系，构成了 Java 虚拟机中的双亲委托机制。<strong>所谓的双亲委托机制，是指类加载器请求另一个类加载器来加载类的过程。</strong></p><p><img src="/2020/07/07/java-class-loader/jvm_2.png" width="50%" height="50%"></p><p>上图是类加载器双亲委托模型，我们可以看到，除了启动类加载器以外的每一个类加载器，都有一个 ”双亲“ 类加载器，在某个特定的类加载器试图以常用的方式加载类以前，它会默认将这个任务 ”委托“ 给它的双亲 – 请求它的双亲来加载这个类。这个双亲再依次请求它自己的双亲来加载这个类。这个委托的过程一直向上继续，直到达到启动类加载器。如果一个类加载器的双亲类加器有能力来加载这个类，则这个类加载器返回这个类。否则，这个类加载器试图自己来加载这个类。</p><p>它们有着不同的启动路径</p><table><thead><tr><th>类加载器</th><th>路径</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader 启动类加载器</td><td>Load JRE\lib\rt.jar 或者 -Xbootclasspath 选项指定的 Jar 包</td></tr><tr><td>Extension ClassLoader 扩展类加载器</td><td>Load JRE\lib\ext*.jar 或 -Djava.ext.dirs 指定目录下的 Jar 包</td></tr><tr><td>Application ClassLoader 应用程序类加载器</td><td>Load CLASSPATH 或 -Djava.class.path 所指定的目录下的类和 Jar 包</td></tr><tr><td>User ClassLoader 自定义类加载器</td><td>通过 Java.lang.ClassLoader 的子类自定义加载 class</td></tr></tbody></table><p> ClassLoader 的 loadClass 方法和 findClass 方法，如果是我们自定义 ClassLoader 的话，只需要重写 findClass 方法即可</p><p>下面我们用一个例子来说明来加载器的双亲委托机制。我们自定义一个 ClassLoader 并复写它的 findClass() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Class <span class="title">findClass</span><span class="params">(String className)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"findClass className: "</span> + className);</span><br><span class="line">      <span class="keyword">byte</span>[] classData;</span><br><span class="line"></span><br><span class="line">      classData = getTypeFromBasePath(className);</span><br><span class="line">      <span class="keyword">if</span> (classData == <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Parse it</span></span><br><span class="line">      <span class="keyword">return</span> defineClass(className, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] getTypeFromBasePath(String typeName)&#123;</span><br><span class="line">      FileInputStream fis;</span><br><span class="line">      String fileName = path  + typeName.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">      System.out.println(<span class="string">"getTypeFromBasePath fileName :"</span> + fileName);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          fis = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          <span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">      ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">int</span> c = bis.read();</span><br><span class="line">          <span class="keyword">while</span> ( c != -<span class="number">1</span>)&#123;</span><br><span class="line">              out.write(c);</span><br><span class="line">              c = bis.read();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后在我们通过 IDEA 编译，将编译出来的 Class 文件版本放到桌面，并且指定路径进行加载。</p><p><img src="/2020/07/07/java-class-loader/jvm_3.png" width="50%" height="50%"></p><p>然后在 main 方法中运行，将路径设置为 我们在上面的桌面 视图加载 Test1 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//  loadClass</span></span><br><span class="line">        MyClassLoader loader1 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader1"</span>);</span><br><span class="line"></span><br><span class="line">        loader1.setPath(<span class="string">"/Users/yxhuang/Desktop/"</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = loader1.loadClass(<span class="string">"com.yxhuang.jvm.bytecode.Test1"</span>);</span><br><span class="line">        System.out.println(<span class="string">"class name: "</span> + clazz.getSimpleName() + <span class="string">" \nclass hashcode: "</span> + clazz.hashCode() + <span class="string">" \nloader: "</span> + clazz.getClassLoader().getClass().getSimpleName());</span><br><span class="line">        Object object1 = clazz.newInstance();</span><br><span class="line">        System.out.println(object1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子，我们将 <code>MyClassLoader</code> 命名为 <code>loader1</code>, 设置路径为我们的电脑桌面。这时候运行，看看输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class name: Test1 </span><br><span class="line">class hashcode: 1265094477 </span><br><span class="line">loader: AppClassLoader</span><br><span class="line">com.yxhuang.jvm.bytecode.Test1@7ea987ac</span><br></pre></td></tr></table></figure><p>上面输出，我们看看 Test1 类文件已经加载进了 类加载器，但是打印出来，我们看到 ClassLoader 是 AppClassLoader 而不是我们自定义的 MyClassLoader。 为什么会这样呢，这就涉及到类的双亲委托机制了。</p><p>当我们用 loader1 视图去加载 <code>com.yxhuang.jvm.bytecode.Test1</code> 这个类的时候，根据双亲委托机制，自定义的类加载器  MyClassLoader 会委托它的父加载器 AppClassLoader 去加载， AppClassLoader 应用类加载器又会委托它的父类加载器 Bootstrap ClassLoader 启动类去加载。而 Bootstrap ClassLoader 找不到这个类，然后让 AppClassLoader 去加载，还记得上面提到 AppClassLoader 加载的路径是项目的 ClassPath, 这时候找到了 Test1 类并加载了它，并没有让 MyClassLoader 去加载</p><p><img src="/2020/07/07/java-class-loader/jvm_4.png" width="50%" height="50%"></p><p>现在，我们把 out/production/class 路径里面的 Test1 删掉，再次运行查看结果<br>这时候的输出是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">findClass className: com.yxhuang.jvm.bytecode.Test1</span><br><span class="line">getTypeFromBasePath fileName :/Users/yxhuang/Desktop/com/yxhuang/jvm/bytecode/Test1.class</span><br><span class="line">class name: Test1 </span><br><span class="line">class hashcode: 1554874502 </span><br><span class="line">loader: MyClassLoader</span><br><span class="line">com.yxhuang.jvm.bytecode.Test1@6e0be858</span><br></pre></td></tr></table></figure><p>看到上面的输出，我们看到我们自定义的 MyClassLoader 被调用了，加载 Test1 的路径是  <code>/Users/yxhuang/Desktop/com/</code> , 类加载器也是我们自定义的 MyClassLoader</p><p><img src="/2020/07/07/java-class-loader/jvm_5.png" width="50%" height="50%"></p><p>MyClassLoader 会委托给它的父类，最后到 启动类加载器，然后 MyClassLoader 之上的类加载器没有一个能加载到，最后只能是 MyClassLoader 来加载。</p><p>双亲委托机制可以保证父类先加载 Class 文件，特别是 jdk 里面的类，保证 jdk 类的类优先被启动类加载器加载，防止恶意代码伪装成 jdk 的类去破坏 jvm 的运行。</p><p><strong>双亲委托机制还有下面的一些特点：</strong></p><ul><li><strong>1.如果没有显示地传递一个双亲类装载器给用户自定义的类装载器的构造方法，系统装载器就默认被指定为双亲。</strong></li><li><strong>2. 如果传递到构造方法的是一个已有的用户自定义类型装载器的引用，该用户自定义装载器就被作为双亲。</strong></li><li><strong>3.如果传递的方法是一个 null, 启动类装载器就是双亲。</strong></li><li><strong>4.在类装载器之间具有了委派关系，首先发起装载要求的类装载器不必是定义该类的类装载器。</strong></li></ul><p>当时双亲委托机制，也有它不足的地方，在不需要双亲委托机制的地方，需要上下文类加载器。关于上下文类加载器，后面我们会讲到，这里先跳过。</p><p>下面我们先看看命名空间</p><h2 id="3-类加器的命名空间"><a href="#3-类加器的命名空间" class="headerlink" title="3. 类加器的命名空间"></a>3. 类加器的命名空间</h2><p>下面我们通过实例代码，说明命名空间</p><p>先定义一个 Person 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPerson</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setPerson "</span> + object.getClass().getSimpleName());</span><br><span class="line">        <span class="keyword">this</span>.person = (Person) object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 IDEA 编译成 class 文件，将编译出来的 Class 文件版本放到桌面，并且指定路径进行加载。然后将 Persion 的 class 文件 删除，同时注释 Person。</p><p>下面是命名空间的测试类, 设置加载路径，用两个不同的类加载器去加载 <code>com.yxhuang.jvm.classloader.Person</code> 类，然后通过反射，调用 class1 的 <code>setPerson</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameSpaceLoaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader classLoader1 = <span class="keyword">new</span> MyClassLoader(<span class="string">"classloader1"</span>);</span><br><span class="line">        MyClassLoader classLoader2 = <span class="keyword">new</span> MyClassLoader(<span class="string">"classloader2"</span>);</span><br><span class="line"></span><br><span class="line">        classLoader1.setPath(<span class="string">"/Users/yxhuang/Desktop/"</span>);</span><br><span class="line">        classLoader2.setPath(<span class="string">"/Users/yxhuang/Desktop/"</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; class1 = classLoader1.loadClass(<span class="string">"com.yxhuang.jvm.classloader.Person"</span>);</span><br><span class="line">        Class&lt;?&gt; class2 = classLoader2.loadClass(<span class="string">"com.yxhuang.jvm.classloader.Person"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"class1 : "</span> + class1.getSimpleName() + <span class="string">" "</span> +  class1.getClassLoader().toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"class2 : "</span> + class2.getSimpleName() + <span class="string">" "</span> +  class2.getClassLoader().toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(class1 == class2);</span><br><span class="line"></span><br><span class="line">        Object object1 = class1.newInstance();</span><br><span class="line">        Object object2 = class2.newInstance();</span><br><span class="line"></span><br><span class="line">        Method method = class1.getMethod(<span class="string">"setPerson"</span>, Object.class);</span><br><span class="line">        method.invoke(object1, object2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们看看输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">findClass className: com.yxhuang.jvm.classloader.Person</span><br><span class="line">getTypeFromBasePath fileName :/Users/yxhuang/Desktop/com/yxhuang/jvm/classloader/Person.class</span><br><span class="line"></span><br><span class="line">findClass className: com.yxhuang.jvm.classloader.Person</span><br><span class="line">getTypeFromBasePath fileName :/Users/yxhuang/Desktop/com/yxhuang/jvm/classloader/Person.class</span><br><span class="line"></span><br><span class="line">class1 : Person com.yxhuang.jvm.classloader.MyClassLoader@42a57993</span><br><span class="line"></span><br><span class="line">class2 : Person com.yxhuang.jvm.classloader.MyClassLoader@6bc7c054</span><br><span class="line"></span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">// 还会抛出异常</span><br><span class="line">Caused by: java.lang.ClassCastException: com.yxhuang.jvm.classloader.Person cannot be cast to com.yxhuang.jvm.classloader.Person</span><br></pre></td></tr></table></figure><p>根据上面的打印，我们可以知道， class1 和 class2 都是 Person 类，但是 <code>class1 == class2</code> 是 false 的，说明他们不是同一个类。</p><p>将 class1 和 class2 通过 newInstance() 方法生成对应的 object1 和 object2 对象，这也都是 Person 类的对象。<br>在调用反射将 object1 的 setPerson 方法会抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPerson</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setPerson "</span> + object.getClass().getSimpleName());</span><br><span class="line">        <span class="keyword">this</span>.person = (Person) object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抛出的异常是说 Person 对象不能强转成 Person 对象。这个异常就很奇怪了，那为什么会出现这个异常，那就要说到 java 虚拟机里面的命名空间了。<br>因为这两个对象加载的虚拟机不一样，导致命名空间不一样导致的。</p><p>命名空间是表示当前类的加载器的命名空间，是由当前类转加载器是自己的初始类加载器的类型名称组成的。</p><p>命名空间的作用是通过不同的命名空间，防止恶意代码去干涉其他代码。在 Java 虚拟机中，在同一个命名空间内的类可以之间进行交互，而不同的命名空间中的类察觉不到彼此的存在。</p><p>每个类装载器都有自己的命名空间，其中维护者由它装载的类型。所以一个 Java 程序可以多次装载具有一个全限定名的多个类型。这样一个类的全限定名就不足以确定在一个 Java 虚拟机中的唯一性。因此，当多个类装载器都装载了同名的类型时，为了唯一地标识该类型，还要在类型名称前加上装载器该类（指出了它所位于的命名空间）的类装载器的标识。</p><p>上面 Person 的这个例子就说明，一个类的全限定名 <code>com.yxhuang.jvm.classloader.Person</code> 不能确定它的唯一性，我们可以用另外一个类加载器去再次加载这个类。</p><p>综上所述，如果想要确定一个类是否是唯一的或者说判断两个类是否相等，就需要他们的类加载器为同一个累加器，并且命名空间是一致的。</p><p>关于命名空间的一些论述</p><ul><li><ol><li>每个类装载器都有自己的命名空间，命名空间由该装载器及其父装载器所装载的类组成；</li></ol></li><li><ol start="2"><li>在同一个命名空间中，不会出现类的完整姓名（包括类的包名）相同的两个类；</li></ol></li><li><ol start="3"><li>在不同的命名空间中，有可能会出现类的完整名字（包含类的包名）相同的两个类。</li></ol></li></ul><p>类装载器和这个类本身一起共同确立在 Java 虚拟机中的唯一性，每一个类装载器，都有一个独立的命名空间。<br>也就是说，比较两个类是否”相等“，只有这两个类是由同一个类装载器的前提下，否则，即使这两个类来源于同一个 Class 文件，被同一个 Java 虚拟机加载，只要加载它们的类装载器不同，那这两个类就必定不相等。</p><p>不同的加载器实例加载的类被认为是不同的类</p><p>在 JVM 的实现中有一条隐含的规则，默认情况下，如果一个类由类加载器 A 加载，那么这个类的依赖类也是由相同的类加载器加载</p><p>上面的几条论述在例子中也有体现。</p><h2 id="4-自定义类加载器"><a href="#4-自定义类加载器" class="headerlink" title="4 自定义类加载器"></a>4 自定义类加载器</h2><h3 id="4-1-自定义类加载器"><a href="#4-1-自定义类加载器" class="headerlink" title="4.1 自定义类加载器"></a>4.1 自定义类加载器</h3><p>如果想要自定义类加载器，只需要继承 ClassLoader 并且重写它的 findClass() 方法。</p><p>在 findClass() 方法里面根据路径去加载相应的 Class 文件流，然后将数据传递给 ClassLoader 自带的 defineClass() 方法，defineClass() 会将Class 流文件转成 Class 类的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected Class findClass(String className) throws ClassNotFoundException &#123;</span><br><span class="line">    System.out.println(&quot;findClass className: &quot; + className);</span><br><span class="line">    byte[] classData;</span><br><span class="line">    </span><br><span class="line">    // 指定路径加载 Class 流文件</span><br><span class="line">    classData = getTypeFromBasePath(className);</span><br><span class="line">    if (classData == null)&#123;</span><br><span class="line">        throw new ClassNotFoundException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Parse it 将流文件转成一个 Class 类实例</span><br><span class="line">    return defineClass(className, classData, 0, classData.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，必须要了解 ClassLoader 里面的 loadClass() 方法</p><h3 id="4-2-loadClass-方法"><a href="#4-2-loadClass-方法" class="headerlink" title="4.2 loadClass() 方法"></a>4.2 loadClass() 方法</h3><p>在我们自定义了 ClassLoader 之后，会调用  loadClass() 方法去加载想要加载的类。</p><ul><li><p>loadClass() 的基本工作方式：<br>给定需要查找的类型的全限定名， loadClass()方法会用某种方式找到或生成字节数组到，里面的数据采用 Java Class 文件格式（用该格式定义类型）。如果 loadClass() 无法找到或生成这些字节，就会抛出 ClassNotFoundException 异常。否则，loadClass() 会传递这个自己数组到 ClassLoader 声明的某一个 defineClass() 方法。通过把这些字节数组传递给<br>defineClass(),loadClass() 会要求虚拟机把传入的字节数组导入这个用户自定义的类装载器的命名中间中去。</p></li><li><p>loadClass 的步骤：</p><ul><li>1.查看是否请求的类型已经被这个类装载器装载进命名空间（提供 findLoadedClass()）方法的工作方式</li><li>2.否则，委派到这个类装载器的双亲装载器。如果双亲返回了一个 Class 实例，就把这个 Class 实例返回。</li><li><ol start="3"><li>否则，调用 findClass(), findClass() 会试图寻找或者生成一个字节数组，内容采用 Java Class 文件格式（它定义了所需要的类型）。如果成功，findClass() 把这个字节传递给 defineClass() ，后者试图导入这个类型，返回一个 Class 实例。 如果 findClass() 返回一个 Class 实例，loadClass() 就会把这个实例返回。</li></ol></li><li><ol start="4"><li>否则， findClass() 抛出某些异常来中止处理，而且 loadClass() 也会抛出异常中止。</li></ol></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个类加载器都有个父加载器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//查找一下这个类是不是已经加载过了</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果没有加载过</span></span><br><span class="line">        <span class="keyword">if</span>( c == <span class="keyword">null</span> )&#123;</span><br><span class="line">          <span class="comment">//先委托给父加载器去加载，注意这是个递归调用</span></span><br><span class="line">          <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">              c = parent.loadClass(name);</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果父加载器为空，查找Bootstrap加载器是不是加载过了</span></span><br><span class="line">              c = findBootstrapClassOrNull(name);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果父加载器没加载成功，调用自己的findClass去加载</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> c；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name)&#123;</span><br><span class="line">       <span class="comment">//1. 根据传入的类名name，到在特定目录下去寻找类文件，把.class文件读入内存</span></span><br><span class="line">          ...</span><br><span class="line">          </span><br><span class="line">       <span class="comment">//2. 调用defineClass将字节数组转成Class对象</span></span><br><span class="line">       <span class="keyword">return</span> defineClass(buf, off, len)；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将字节码数组解析成一个Class对象，用native方法实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-线程上下文类加载器"><a href="#5-线程上下文类加载器" class="headerlink" title="5 线程上下文类加载器"></a>5 线程上下文类加载器</h2><p>双亲委托机制不适用的场景下，需要使用到 上下文类加载器(Thread Context ClassLoader)</p><p>场景是有基础类要调用用户代码(Service Provider Interface, SPI)</p><p>线程上下文加载器通过  Thread 类的 setContextClassLoader() 方法进行设置，如果创建线程还未设置，就会从父线程中继承一个，如果在应用程序的全局范围都没有设置过的话，那这个类装载器默认是应用类加载器。</p><h2 id="6-获取-ClassLoader-的途径"><a href="#6-获取-ClassLoader-的途径" class="headerlink" title="6.获取 ClassLoader 的途径"></a>6.获取 ClassLoader 的途径</h2><p>获取当前类的 ClassLoader: clazz.getClassLoader()</p><p>获取当前线程上下文的 ClassLoader: Thread.currentThread().getContextClassLoader()</p><p>获取系统的 ClassLoader : ClassLoader.getSystemClassLoader()</p><p>获取调用者的 ClassLoader: DriverManager.getCallerClassLoader()</p><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7.参考"></a>7.参考</h2><ul><li><a href="https://book.douban.com/subject/1138768/" target="_blank" rel="noopener">《深入 Java 虚拟机》</a></li><li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解 Java 虚拟机》</a></li><li><a href="http://www.iprogramming.cn/" target="_blank" rel="noopener">圣思园张龙</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-类加载器&quot;&gt;&lt;a href=&quot;#1-类加载器&quot; class=&quot;headerlink&quot; title=&quot;1.类加载器&quot;&gt;&lt;/a&gt;1.类加载器&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2020/07/07/java-class-loader/j
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 虚拟机（二）：Class 文件结构</title>
    <link href="https://yxhuangch.github.io/2020/04/12/jvm-class-file/"/>
    <id>https://yxhuangch.github.io/2020/04/12/jvm-class-file/</id>
    <published>2020-04-12T13:14:25.000Z</published>
    <updated>2020-04-14T00:10:14.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Class-文件结构"><a href="#Class-文件结构" class="headerlink" title="Class 文件结构"></a>Class 文件结构</h1><p><strong>Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件中，中间没有添加任何分隔符。</strong></p><h2 id="1-ClassFile-结构"><a href="#1-ClassFile-结构" class="headerlink" title="1  ClassFile 结构"></a>1  ClassFile 结构</h2><p>（从上往下顺序）</p><table><thead><tr><th>数据类型</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td>u4</td><td>magic</td><td>魔数，固定是 0xCAFEBABE</td></tr><tr><td>u2</td><td>minor_version</td><td>副版本号</td></tr><tr><td>u2</td><td>major_version</td><td>主版本号</td></tr><tr><td>u2</td><td>constanct_pool_count</td><td>常量池计数器</td></tr><tr><td>cp_info</td><td>constanct_pool[constanct_pool_count - 1]</td><td>常量池</td></tr><tr><td>u2</td><td>access_flags</td><td>访问标志</td></tr><tr><td>u2</td><td>this_class</td><td>类索引</td></tr><tr><td>u2</td><td>super_class</td><td>父类索引</td></tr><tr><td>u2</td><td>interfaces_count</td><td>接口计数器</td></tr><tr><td>u2</td><td>interfaces[interfaces_count]</td><td>接口表</td></tr><tr><td>u2</td><td>fields_count</td><td>字段计算器</td></tr><tr><td>field_info</td><td>fields[fields_count]</td><td>字段表</td></tr><tr><td>u2</td><td>methods_count</td><td>方法计数器</td></tr><tr><td>method_info</td><td>methods[methods_count]</td><td>类和接口中定义的所有方法</td></tr><tr><td>u2</td><td>attributes_count</td><td>属性计数器</td></tr><tr><td>attribute_info</td><td>attributs[attributes_count]</td><td>属性表</td></tr></tbody></table><p>说明：</p><ul><li>u1 代表1个字节</li><li>u2 代表2个字节</li><li>u4 代表4个字节</li><li>u8 代表8个字节</li></ul><h3 id="1-1-特殊方法"><a href="#1-1-特殊方法" class="headerlink" title="1.1 特殊方法"></a>1.1 特殊方法</h3><ul><li><init> 这个方法名称由编译器生成的，它代表着类的实例化，也就是说构造函数的调用</init></li><li><clinit> 这个方法名称也是由编译器生成的，它代表着静态类的调用</clinit></li></ul><h3 id="1-2-描述符标识字符含义"><a href="#1-2-描述符标识字符含义" class="headerlink" title="1.2 描述符标识字符含义"></a>1.2 描述符标识字符含义</h3><table><thead><tr><th>标识符字符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>byte</td></tr><tr><td>C</td><td>char</td></tr><tr><td>D</td><td>double</td></tr><tr><td>F</td><td>float</td></tr><tr><td>I</td><td>int</td></tr><tr><td>J</td><td>long</td></tr><tr><td>S</td><td>short</td></tr><tr><td>Z</td><td>boolean</td></tr><tr><td>V</td><td>特殊类型 void</td></tr><tr><td>L</td><td>对象类型，例如 Ljava/lang/Object</td></tr></tbody></table><p>数组类型，每一维将使用一个前置的 “[“ 字符来描述，<br>例如 String[][] -&gt; [[Ljava/lang/String, int[] -&gt; [i</p><p>用描述符描述方法时，按参数先，后返回值的顺序描述<br>例如</p><blockquote><p>int  indexOf(Sting a, int i) 对应是 (Ljava/lang/StringI)I<br>void inc()  对应 ()V</p></blockquote><h2 id="2-Magic-魔数-与版本"><a href="#2-Magic-魔数-与版本" class="headerlink" title="2 Magic 魔数 与版本"></a>2 Magic 魔数 与版本</h2><p><img src="/2020/04/12/jvm-class-file/jvm_class_1.png" width="100%" height="100%"></p><p>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yxhuang.jvm.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-Magic-Number-魔数-u4"><a href="#2-1-Magic-Number-魔数-u4" class="headerlink" title="2.1 Magic Number 魔数 u4"></a>2.1 Magic Number 魔数 u4</h3><p>位于 Class 文件的头四个字节成为魔数(Magic Number)<br>作用是确定这个文件能否被虚拟机接受的 Class 文件</p><p>上图中 <code>CA FE BA BE</code> 四个字节就是 Magice Number 固定不变</p><h3 id="2-2-版本"><a href="#2-2-版本" class="headerlink" title="2.2 版本"></a>2.2 版本</h3><ul><li>minor_version 副版本号 u2</li><li>major_version 主版本号 u2</li></ul><p><strong>高版本好的虚拟机可以支持低版本号的 Class 文件，反之则不行</strong></p><p>例如52.1<br>52 是主版本号， 0.1 是副版本号</p><p>常用的 Class 文件版本号</p><table><thead><tr><th>编译器器版本</th><th>十六进制版本号</th><th>十进制版本号</th></tr></thead><tbody><tr><td>JDK 1.7.0</td><td>00 00 00 32</td><td>50</td></tr><tr><td>JDK 1.8.0</td><td>00 00 00 34</td><td>52</td></tr></tbody></table><p>上图中 <code>00 00 00 34</code> 代表版本号，副版本号是 <code>00 00</code>, 主版本号是 <code>00 34</code> 则说明是 JDK 1.8 编译的</p><h2 id="3-常量池-constant-pool"><a href="#3-常量池-constant-pool" class="headerlink" title="3 常量池 constant_pool"></a>3 常量池 constant_pool</h2><h3 id="3-1-说明"><a href="#3-1-说明" class="headerlink" title="3.1 说明"></a>3.1 说明</h3><p><strong>Class 文件结构中，只有常量池的计数是从 1 开始的，其他集合类型都是从 0 开始</strong></p><p>图一中的 contant_pool_count 是 <code>00 18</code> 变成 10 进制是 24，但是常量个数 = 24 -1 = 23 个</p><p><img src="/2020/04/12/jvm-class-file/jvm_class_2.png" width="50%" height="50%"></p><p><img src="/2020/04/12/jvm-class-file/jvm_class_3.png" width="80%" height="50%"></p><h3 id="3-2-例子"><a href="#3-2-例子" class="headerlink" title="3.2 例子"></a>3.2 例子</h3><p>看第一个常量 <code>0x0A</code> 是 10，对应上表是 CONSTANT_Methodref_info </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Methodref_info&#123;</span><br><span class="line">    u1 tag                   0A</span><br><span class="line">    u2 class_index           00 04  </span><br><span class="line">    u2 name_and_type_index   00 14</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>0A</strong> 对应是 CONSTANT_Methodref_info 类型</li><li><strong>00 04</strong> class_index， 指向常量池表中索引 #4 的 CONSTANT_Class_info 结构。<br>CONSTANT_Class_info 表示一个类或接口，当前字段或方法就是这个类或接口的成员</li><li><strong>00 14</strong> name_and_type_index，指向常量池索引为 #20 的 CONSTANT_NameAndType_info结构。 CONSTANT_NameAndType_info 结构表示当前字段或方法的描述符</li></ul><p>对着下图，我们看到</p><blockquote><p> #1 对应 Methodref, 指向   #4.#20， 和我们上面分析的一致</p><p> #4 Class 指向 #23 java/lang/Object 说明当前这个方法是 java.lang.Object</p><p> #20 NameAndType 指向了 #7和#8  <init>()V 说明这个方法是 <init>；方法描述符是 ()V</init></init></p></blockquote><p><img src="/2020/04/12/jvm-class-file/jvm_class_4.png" width="80%" height="50%"><br>常量池例子图一</p><p><img src="/2020/04/12/jvm-class-file/jvm_class_5.png" width="80%" height="50%"><br>常量池例子图二</p><p>常量池例子图二 中选中的字节就是常量池的内容<br>其他的方法可以用类似例子的方法对照常量项的结构总表一个个去分析</p><p>常量池中的 14 种常量项的结构总表<br><img src="/2020/04/12/jvm-class-file/jvm_class_6.png" width="80%" height="50%"><br><img src="/2020/04/12/jvm-class-file/jvm_class_7.png" width="80%" height="50%"></p><h3 id="3-3-访问标志-access-flags-u2"><a href="#3-3-访问标志-access-flags-u2" class="headerlink" title="3.3  访问标志 access_flags u2"></a>3.3  访问标志 access_flags u2</h3><p>访问标志在常量池之后的后两位 u2, 用于标志类或接口层次的访问信息；<br>包括</p><ul><li>这个 Class 是类还是接口</li><li>是否定义为 public 类型</li><li>是否定义为 abstract 类型</li><li>如果是类的话，是否被定义为 final</li></ul><p>一般是两个位的组合</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>是否为 pulic 类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>是否声明为 final,只有类可设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>是否允许使用 invokespecial 字节码的新语意</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标志这是个接口</td></tr><tr><td>ACC_ABSTEACT</td><td>0x0400</td><td>是否为 sbstract 类型，对于接口或抽象类说，此标志值为真，其他类值为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标识这个类并非由用户代码产生的</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标识这个是注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标识这个是枚举</td></tr></tbody></table><p>如果是一个普通类，不是接口、枚举或者注解，被 public 关键字修饰但没有被声明为 final 和 abstract.是用组合值</p><p>0x0021 = 0x0001|0x0020</p><p>说明这个类是 PUBLIC, SUPTER</p><p><img src="/2020/04/12/jvm-class-file/jvm_class_8.png" width="80%" height="50%"></p><h2 id="4-类索引、父索引与接口索引集合"><a href="#4-类索引、父索引与接口索引集合" class="headerlink" title="4 类索引、父索引与接口索引集合"></a>4 类索引、父索引与接口索引集合</h2><p><strong>Class 文件由类索引、父索引和接口索引这三项数据来确定这个类的继承关系。</strong></p><h3 id="4-1-类索引-this-class"><a href="#4-1-类索引-this-class" class="headerlink" title="4.1 类索引 this_class"></a>4.1 类索引 this_class</h3><p>类索引用于确定这个类的全限定名<br>u2 类型的索引值，指向类型 CONSTANT_Class_info 的类描述符</p><h3 id="4-2-父索引-super-class"><a href="#4-2-父索引-super-class" class="headerlink" title="4.2 父索引 super_class"></a>4.2 父索引 super_class</h3><p>父索引用于确定这个类的父类全限定名<br>u2 类型的索引值，指向类型 CONSTANT_Class_info 的类描述符<br>除了 java.lang.Object 外，所有的 Java 类的父类索引都不为 0</p><h3 id="4-3-接口索引-interfaces"><a href="#4-3-接口索引-interfaces" class="headerlink" title="4.3 接口索引 interfaces"></a>4.3 接口索引 interfaces</h3><p>接口索引，入口是 u2 类型的的接口计数器（interfaces_count）表示索引表的容量。<br>如果及计数器值为 0 ，表示这个类没有任何接口，后面接口的索引表不占任何字节。</p><p>例子<br><img src="/2020/04/12/jvm-class-file/jvm_class_9.png" width="80%" height="50%"></p><p>上图中在常量池结束之后，就是类索引，查看 常量池例子图一<br><code>00 03</code>  指向 #3 的 CONSTANT_Class_info 索引， #3再指向 #20， 是</p><blockquote><p> #22 = Utf8               com/yxhuang/jvm/bytecode/Test1<br>说明这个类 <code>com.yxhuang.jvm.bytecode.Test1</code></p></blockquote><p>父类索引是 <code>00 04</code>， 指向 #4 的 CONSTANT_Class_info 索引，#4 再指向#23</p><blockquote><p> #23 = Utf8  java/lang/Object</p></blockquote><p>说明这个类的父类是 java.lang.Object。在 java 中如果一个类没有继承其他类，它的父类默认是 Object, 与我们现在看到的内容是对得上的</p><p>接口索引计数器 <code>00 00</code> 说明接口数量为 0， 则没有后面的接口索引表</p><h2 id="5-字段表-field-info"><a href="#5-字段表-field-info" class="headerlink" title="5 字段表 field_info"></a>5 字段表 field_info</h2><p><strong>字段表用于描述接口或类中声明的变量。<br>字段（field）包括类级变量（static field）以及实例变量,但不包括在方法内部声明的局部变量。</strong></p><p>字段表中不会列出从超类或者父类接口中继承而来的字段。</p><h3 id="5-1-字段表结构"><a href="#5-1-字段表结构" class="headerlink" title="5.1 字段表结构"></a>5.1 字段表结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">    u2              access_flags</span><br><span class="line">    u2              name_index</span><br><span class="line">    u2              descriptor_index;</span><br><span class="line">    u2              attributes_count;</span><br><span class="line">    attribute_info   attributes[attributes_count]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>access_flags 用于定义字段的访问权限和基本属性的掩码标识</li><li>name_index 对应常量池中的一个有效索引，指向 CONSTANT_Utf8_info 结构，标识一个有效的字段的非全限定名</li><li>descriptor_index 对应常量池中的一个字段描述符索引</li><li>attributes_count 表示当前字段的附加属性数量</li><li>attribute_info 附加属性<br>一般有：<ul><li>ConstantValue</li><li>Synthetic</li><li>Signature</li><li>Dprecated</li><li>RuntimeVisibleAnnotations</li><li>RuntimeInvisibleAnnoation</li></ul></li></ul><p>表5.1 字段 acces_flags 标志列表</p><table><thead><tr><th>标志名</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>声明为 public, 可以从包外访问</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>声明为 private, 只能自身访问</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>声明为 protected, 子类可以访问</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>声明为 static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>声明为 final, 定义后无法修改</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>声明为 valatile, 被标识的字段无法储存</td></tr><tr><td>ACC_TRANSIENT</td><td>0x0080</td><td>声明为 transient, 被标识的字段不会序列化</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>声明为被表示的字段的编译器产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>声明为 enum, 枚举类型</td></tr></tbody></table><p>descriptor_index 是 1.2 节中的描述符</p><p>attributes 属性包含 见后面的 属性 章节</p><p><code>00 01</code> 是 fields_count，字段个数，说明只有 1 个字段<br><code>00 02</code> 是 access_flags，表示是该字段是 private<br><code>00 05</code> 是 name_index， 指向 #05 是 a<br><code>00 06</code> 是 descriptor_index， 指向 #06 是 I, 根据 1.2 描述符表说明这个类是 int<br><code>00 00</code> 是附加属性个数，0 说明这字段没有附加属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#5 = Utf8               a</span><br><span class="line">#6 = Utf8               I</span><br></pre></td></tr></table></figure><p><img src="/2020/04/12/jvm-class-file/jvm_class_10.png" width="80%" height="50%"></p><h2 id="6-方法-method"><a href="#6-方法-method" class="headerlink" title="6 方法 method"></a>6 方法 method</h2><p>所有方法，包括实例初始化话方法以及类或接口初始化方法在内，都是由 methode_info 结构定义的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method_info &#123;</span><br><span class="line">    u2               access_flags</span><br><span class="line">    u2               name_index</span><br><span class="line">    u2               descriptor_index</span><br><span class="line">    u2               attributes_count</span><br><span class="line">    attribute_info   attributes[attributes_count]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>access_flags 用于定义当前方法的访问权限和基本属性的掩码标识</li><li>name_index 对应常量池中的一个有效索引，指向 CONSTANT_Utf8_info 结构，标识一个有效的字段的非全限定名</li><li>descriptor_index 对应常量池中的一个字段描述符索引</li><li>attributes_count 表示当前方法的附加属性数量</li><li>attribute_info 附加属性<br>  包含：<pre><code>- Code- Exceptions- Synthetic- Signature- Dprecated- RuntimeVisibleAnnotations- RuntimeInvisibleAnnotations- RuntimeVisibleParameterAnnotations- RuntimeInvisibleParameterAnnotations- AnnotationDefault</code></pre></li></ul><p>  <img src="/2020/04/12/jvm-class-file/jvm_class_10_1.png" width="80%" height="50%"></p><p> <code>00 03</code> 是 method_count ,说明方法的入口说明有三个方法，对照我们的源码，我们定义了 <code>getA</code> <code>setA</code> 两个方法，另外就是编译器自动为当前类生成的无参构造函数方法</p><p> <code>00 01</code> 是 access_flags， 对照方法访问标志表，说明该方法是 public<br> <code>00 07</code> 是 name_index， 指向常量池 #7 ，是<init><br> <code>00 08</code> 是 descriptor_index， 指向常量池的 #8, 是 ()V<br> <code>00 01</code> 是 attributes_count， 附加属性个数是 1<br> <code>00 09</code> 是 attribute_info， 附加属性的指向索引 #9，是 Code, 关于 Code 可以看 第七节属性 </init></p><p><img src="/2020/04/12/jvm-class-file/jvm_class_11.png" width="80%" height="50%"></p><h2 id="7-Code-属性"><a href="#7-Code-属性" class="headerlink" title="7 Code 属性"></a>7 Code 属性</h2><p>Code 属性是变长属性，位于 method_info 结构的 <code>attribute_info</code> 中。<br>一个 Code 属性只为唯一一个方法、实例初始化方法、类或接口初始化方法保存 Java　虚拟机指令及其相关辅助信息。</p><h3 id="7-1-格式"><a href="#7-1-格式" class="headerlink" title="7.1 格式"></a>7.1 格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">    u2      attribute_name_index;   // 一般是 &apos;Code&apos;</span><br><span class="line">    u4      attribute_length;</span><br><span class="line">    u2      max_stack;</span><br><span class="line">    u2      max_locals;</span><br><span class="line">    u4      code_length;</span><br><span class="line">    u1      code[code_length];</span><br><span class="line">    u2      exception_table_length;</span><br><span class="line">    &#123;</span><br><span class="line">        u2  start_pc;</span><br><span class="line">        u2  end_pc;</span><br><span class="line">        u2  handler_pc;</span><br><span class="line">        u2  catch_type;</span><br><span class="line">    &#125; exception_table[exception_table_length];</span><br><span class="line">    u2      attributes_count;</span><br><span class="line">    attribute_info  attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>attribute_name_index 是 属性名称的的常量索引 ，值一般是 Code</li><li>attribute_length 属性的的长度</li><li>max_stack 代表了操作数栈（Operand Stacks）深度的最大值。在方法执行的任意时刻，操作栈都不会超过这深度。</li><li>max_locals 代表了局部变量表所需的存储空间。存储单位是 Slot</li><li>code_length 代表编译之后的字节码指令长度， u4 类型，说明一个方法的最大长度是  <code>2^32 - 1</code>,也就是 65535</li><li>code[] 当前方法的 java 虚拟机的实际字节码， code 用于存储字节码指令的一系列字节流。 每个指令是 u1 类型， 根据对应的值去查虚拟机指令表</li><li>exception_table_length 异常表的成员个数</li><li>exception_table[] 异常表<ul><li>start_pc 和 end_pc 表示异常处理的索引范围，既 start_pc ≤ x &lt; end_pc</li><li>handle_pc 异常处理器的起点</li><li>catch_type 异常类型，指向常量池中的索引</li></ul></li><li>attributes_count 表示 Code 中的附加属性个数</li><li>attribute_info 附加属性</li></ul><h3 id="7-2-具体的例子"><a href="#7-2-具体的例子" class="headerlink" title="7.2 具体的例子"></a>7.2 具体的例子</h3><p><img src="/2020/04/12/jvm-class-file/jvm_class_7.2.png" width="80%" height="50%"></p><p><code>00 09</code> 在上面的 第 6 节已经说明了，是 #9, 值是 Code<br><code>00 00 00 38</code>  是 attribute_length 是 Code 属性长度，变成10进制是 56 个字节<br><code>00 02</code> 是 max_stack，说明操作栈是的最大深度是 2<br><code>00 01</code> 是 max_locals，说明存储空间是 1<br><code>00 00 00 0A</code> 是 code_length 说明 code 的长度是10个字节</p><h4 id="7-2-1-Code-的指令"><a href="#7-2-1-Code-的指令" class="headerlink" title="7.2.1 Code 的指令"></a>7.2.1 Code 的指令</h4><p>下面的内容是具体的 Code, 10 个字节， 每个字节可以根据虚拟机字节码指令表查找到,关于指令的具体行为，查看另外的资料 </p><p><img src="/2020/04/12/jvm-class-file/jvm_class_7.2.1.png" width="80%" height="50%"></p><blockquote><p>2A B7 00 01 2A 04 B5 00 02 B1</p></blockquote><ul><li><code>2A</code> 是 aload_0 指令</li><li><code>B7</code> 是 invokespecial指令， 调用父类的构造方法，  格式是  <code>invokespecial indexByte1 indexByte2</code>  </li><li><code>00 01</code> 指向常量池的 #1，是 <code>java/lang/Object.&quot;&lt;init&gt;&quot;:()V</code></li><li><code>2A</code> 是 aload_0 指令</li><li><code>04</code> 是 iconst_1 指令，将 int 型 1 推送至栈顶</li><li><code>B5</code> 是 putfield 是为指定的的类的实例赋值， 格式是 <code>putfield indexbyte1 indexbyte2</code> </li><li><p><code>00 02</code> 指向常量池的 #2 是 </p><blockquote><p>Fieldref       #3.#21         // com/yxhuang/jvm/bytecode/Test1.a:I</p></blockquote></li><li><p><code>B1</code> 是 return 指令</p></li></ul><p>通过 javap -verbose 看到的， 是一样的</p><p><img src="/2020/04/12/jvm-class-file/jvm_class_12.png" width="80%" height="50%"></p><h4 id="7-2-2-Code-异常表"><a href="#7-2-2-Code-异常表" class="headerlink" title="7.2.2 Code 异常表"></a>7.2.2 Code 异常表</h4><p><img src="/2020/04/12/jvm-class-file/jvm_class_7.2.2.png" width="80%" height="50%"></p><p>根据 Code 结构，在 Code 中跟在指令后面的是异常表</p><p><code>00 00</code> 是 exception_table_length 异常表的长度，这里是 0, 说明这个方法没有异常</p><h4 id="7-2-3-Code-的附近属性-attribute-info"><a href="#7-2-3-Code-的附近属性-attribute-info" class="headerlink" title="7.2.3 Code 的附近属性 attribute_info"></a>7.2.3 Code 的附近属性 attribute_info</h4><p>根据 Code 结构，在 Code 中跟在异常表后面的是附近属性</p><p><code>00 02</code> 是 attributes_count 代表这个方法的附近属性，这里是两个</p><p><strong>第一个附加属性</strong><br><code>00 0A</code> 是指向常量池的 #10, 是 LineNumberTable，说明这个属性是 LineNumberTable, 关于 LineNumberTable 属性，可以看后面的第 8 节<br><code>00 00 00 0A</code> 是 attribute_length， 表示附近附加属性的字节长度，只是是 10 个字节， 即后面的 <code>00 02 00 00 00 03 00 04 00 05</code></p><p><code>00 02</code> 是 line_number_table_length，表示  line_number 数组的个数，2 个</p><p><em>第一个数组</em><br><code>00 00</code> 是 start_pc，表示字节码行号， 这里是 0<br><code>00 03</code> 是 line_number， 表示 Java 源代码行数，这里是 3</p><p><em>第二个数组</em></p><p><code>00 04</code> 表示字节码行数是 4<br><code>00 05</code> 表示 Java 源代码行数是 5</p><p>对照下图，是和我们分析的一样</p><p><img src="/2020/04/12/jvm-class-file/jvm_class_13.png" width="80%" height="50%"></p><p>第一个属性已经结束了，来看看第二个属性</p><p><strong>第二个属性</strong><br><code>00 0B</code> 指向常量池的 #11 是 LocalVariableTable，是局部变量表，具体信息看看第 9 节<br><code>00 00 00 0C</code> 表示这个附加属性的长度是 14 个字节,即 <code>00 01 00 00 00 0A 00 0C 00 0D 00 00</code></p><p><code>00 01</code> 是 local_variable_table_length, 表示局部变量表的个数是 1<br><code>00 00</code> 是 start_pc 字节码行数 0<br><code>00 0A</code> 是 length，表示当前属性的长度，是 10<br><code>00 0C</code> 是 name_index，表示局部变量的名称，指向常量池的索引 #12，是 this<br><code>00 0D</code> 是 descriptor_index,表示局部变量的描述符，指向常量池的索引 #13，是 Lcom/yxhuang/jvm/bytecode/Test1;<br><code>00 00</code> 是 index，表示这个局部变量在栈帧局部变量表中 Slot 的位置，是 0</p><p>从上面的分支，和下图的结果可以看到是一样的</p><p><img src="/2020/04/12/jvm-class-file/jvm_class_14.png" width="80%" height="50%"></p><p>其他剩下的两个方法都可以按照这样去分析</p><h2 id="8-LineNumberTable-属性"><a href="#8-LineNumberTable-属性" class="headerlink" title="8  LineNumberTable 属性"></a>8  LineNumberTable 属性</h2><p>是可选、变长属性，位于 Code 结构中。<br>是用来确定源文件中的行号</p><h3 id="8-1-结构"><a href="#8-1-结构" class="headerlink" title="8.1 结构"></a>8.1 结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LineNumberTable_attribute &#123;</span><br><span class="line">    u2      attribute_name_index;  // 一般是 `LineNumberTable`</span><br><span class="line">    u4      attribute_length;</span><br><span class="line">    u2      line_number_table_length;</span><br><span class="line">    &#123;</span><br><span class="line">        u2  start_pc;</span><br><span class="line">        u2  line_number;</span><br><span class="line">    &#125;line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>attribute_name_index 指向常量池中的索引，是 “LineNumberTable”</li><li>attribute_length 表示当前属性的长度</li><li>line_number_table_length 表示数组的成员的个数</li><li>start_pc 表示改字符在源文件中的字节码行数</li><li>line_number 表示这个值在源文件的行数</li></ul><h2 id="9-LocalVaribleTable-属性"><a href="#9-LocalVaribleTable-属性" class="headerlink" title="9  LocalVaribleTable 属性"></a>9  LocalVaribleTable 属性</h2><p>是可选、变长属性，位于 Code 结构中<br>确定在执行过程中给定局部变量的信息</p><p>结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LocalVaribleTable_attribute &#123;</span><br><span class="line">    u2    attribute_name_index;    // 一般是`LocalVaribleTable`</span><br><span class="line">    u4    attribute_length; </span><br><span class="line">    u2    local_variable_table_length;</span><br><span class="line">    &#123;</span><br><span class="line">        u2  start_pc;</span><br><span class="line">        u2  length;</span><br><span class="line">        u2  name_index;</span><br><span class="line">        u2  descriptor_index;</span><br><span class="line">        u2  index;</span><br><span class="line">    &#125; local_variable_table[local_variable_table_length]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>attribute_name_index 是指向常量池中的索引，是 “LocalVaribleTable”</li><li>attribute_length 属性的长度</li><li>local_variable_table_length 局部变量表的长度</li><li>start_pc 和 length，表示所有给定的局部变量的索引都在范围[start_pc, start_pc + length) </li><li>index 表示一个局部变量的有效的非全限定名，指向常量池表的索引</li><li>descriptor_index 表示源程序中局部变量类型的字段描述符，指向常量池的索引</li><li>index 表示此局部标量在当前栈帧的局部变量表中的索引</li></ul><h2 id="10-属性-attribute"><a href="#10-属性-attribute" class="headerlink" title="10 属性 attribute"></a>10 属性 attribute</h2><p><strong>属性在 Class 文件格式中 ClassFile 结构、 field_info 结构、 method_info 结构 和 Code_attribute 结构中</strong></p><h3 id="通用格式"><a href="#通用格式" class="headerlink" title="通用格式"></a>通用格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute_info&#123;</span><br><span class="line">    u2      attribute_name_index</span><br><span class="line">    u4      attribute_length</span><br><span class="line">    u2      info[attribute_length]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-字节码文件的-Attribute"><a href="#11-字节码文件的-Attribute" class="headerlink" title="11 字节码文件的 Attribute"></a>11 字节码文件的 Attribute</h2><p><img src="/2020/04/12/jvm-class-file/jvm_class_15.png" width="80%" height="50%"></p><p><code>00 01</code> 代表属性个数， attributes_count， 只有一个<br><code>00 12</code> 是 attribute_name_index， 表示属性名称，指向 #18，是 SoureFile<br><code>00 00 00 02</code> 是 attribute_length， 表示属性长度，是 2<br><code>00 13</code> 是 attribute_info 的信息，指向 #19，是 Test1.java</p><p>上面说明，这个属性名称是 SourceFile, 名称是 Test1.java</p><h2 id="12-总结"><a href="#12-总结" class="headerlink" title="12 总结"></a>12 总结</h2><p>至此，我们整个 Class 文件已经分析完成了。分析 Class　文件需要耐心，按照　Class 文件结构，一个字节码，一个字节码去分析，就可以将整个 Class 文件弄清楚。</p><p>如果弄懂了整个 class 文件，对于学习 java 或者 kotlin 都有很大的帮助。<code></code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解 Java 虚拟机》(第2版)</a></li><li><a href="https://book.douban.com/subject/25792515/" target="_blank" rel="noopener">《Java 虚拟机规范》（Javs SE 7 版）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Class-文件结构&quot;&gt;&lt;a href=&quot;#Class-文件结构&quot; class=&quot;headerlink&quot; title=&quot;Class 文件结构&quot;&gt;&lt;/a&gt;Class 文件结构&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Class 文件是一组以 8 位字节为基础单位的二进制流，各
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android 动态链接库 So 的加载</title>
    <link href="https://yxhuangch.github.io/2020/03/28/android-so-load/"/>
    <id>https://yxhuangch.github.io/2020/03/28/android-so-load/</id>
    <published>2020-03-28T00:51:02.000Z</published>
    <updated>2020-03-28T03:36:01.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在做 Android 项目的时候，需要在 NativeActivity  中动态加载 so 。运行的时候，抛出了异常</p><blockquote><p>Caused by: java.lang.IllegalArgumentException: Unable to find native library  using classloader: dalvik.system.PathClassLoader</p></blockquote><p>在 NativeActivity 中可以看到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    BaseDexClassLoader classLoader = (BaseDexClassLoader) getClassLoader();</span><br><span class="line">        String path = classLoader.findLibrary(libname);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to find native library "</span> + libname +</span><br><span class="line">                                               <span class="string">" using classloader: "</span> + classLoader.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的源码中，可以知道，NativeActivity 要是通过 BaseDexClassLoader#findLibrary 方法去查找 so 的路径，然后进行判空。上面提到的异常，就是因为找不到这个 so 的 path, 抛处理的异常。</p><p>在这个异常之后有几个疑问</p><ul><li>第一个问题是： so 的加载过程是怎样的，so 是如何和现在运行的代码联系起来的？</li><li>第二个问题是： classLoader 通过 findLibrary 方法去查找 so 的 path, 这些path 有什么，是怎样来的？</li><li>第三个问题是：classLoader 是怎么来的，在哪里生成的？</li></ul><p>带着这三个问题去找答案，下面就是对三个问题答案的寻找过程。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本文通过讲述 Android 动态链接库 so 的加载过来，已经 so 的加载原理，可以对加载的整个流程有个清晰的认识，有助于对后续学习热修复有比较好的帮助。</p><p>下面代码分析的源码都是以 Android 9.0 版。</p><h2 id="1-Android-So-的加载过程"><a href="#1-Android-So-的加载过程" class="headerlink" title="1 Android  So 的加载过程"></a>1 Android  So 的加载过程</h2><p>在 Android 添加 so 有两种方式，一种是调用 <code>load(String filename)</code> 方法，传递进去的是路径；另一种是调用 <code>loadLibrary(String libname)</code> 方式，传递进去的是 so 的名称</p><blockquote><p>System.load(“/storage/emulated/0/libnative-lib.so”) 全路径<br>System.loadLibrary(“native-lib”); so 的名字</p></blockquote><h3 id="1-1-System-loadLibrary"><a href="#1-1-System-loadLibrary" class="headerlink" title="1.1 System#loadLibrary"></a>1.1 System#loadLibrary</h3><p>[&gt; java/lang/System.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libname)</span> </span>&#123;</span><br><span class="line">    Runtime.getRuntime().loadLibrary0(VMStack.getCallingClassLoader(), libname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-Runtime-loadLibrary0"><a href="#1-2-Runtime-loadLibrary0" class="headerlink" title="1.2 Runtime#loadLibrary0"></a>1.2 Runtime#loadLibrary0</h3><p>[&gt;java/lang/Runtime.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">loadLibrary0</span><span class="params">(ClassLoader loader, Class&lt;?&gt; callerClass, String libname)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    String libraryName = libname;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="keyword">null</span> &amp;&amp; !(loader <span class="keyword">instanceof</span> BootClassLoader)) &#123;</span><br><span class="line">         <span class="comment">//① ClassLoader#findLibrary 查找 so 的文件名称，见 1.4节</span></span><br><span class="line">        String filename = loader.findLibrary(libraryName);</span><br><span class="line">            <span class="keyword">if</span> (filename == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (loader.getClass() == PathClassLoader.class ||</span><br><span class="line">                     loader.getClass() == DelegateLastClassLoader.class)) &#123;</span><br><span class="line">            <span class="comment">// ② 如果通过 ClassLoader 找不到，则会通过 System 默认路径去找</span></span><br><span class="line">                filename = System.mapLibraryName(libraryName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (filename == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(loader + <span class="string">" couldn't find \""</span> +</span><br><span class="line">                                               System.mapLibraryName(libraryName) + <span class="string">"\""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ③ Native 加载</span></span><br><span class="line">            String error = nativeLoad(filename, loader);</span><br><span class="line">            <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(error);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ClassLoader 为空的时候</span></span><br><span class="line">    getLibPaths();</span><br><span class="line">    String filename = System.mapLibraryName(libraryName);</span><br><span class="line">    String error = nativeLoad(filename, loader, callerClass);</span><br><span class="line">    <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">// 最终通过 Native 来加载</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">nativeLoad</span><span class="params">(String filename, ClassLoader loader, Class&lt;?&gt; caller)</span></span></span><br></pre></td></tr></table></figure><ul><li>当 loader 不为空是，通过 ClassLoader#findLibrary() 查看 so  是否存在</li><li>当 loader 为空是，则从默认目录 mLibPaths 中查找</li></ul><h3 id="1-3-Runtime-getLibPaths"><a href="#1-3-Runtime-getLibPaths" class="headerlink" title="1.3 Runtime#getLibPaths"></a>1.3 Runtime#getLibPaths</h3><p>[&gt;java/lang/Runtime.java]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 获取 Lib 默认路径</span><br><span class="line">private String[] getLibPaths() &#123;</span><br><span class="line">    if (mLibPaths == null) &#123;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            if (mLibPaths == null) &#123;</span><br><span class="line">                mLibPaths = initLibPaths();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return mLibPaths;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">private static String[] initLibPaths() &#123;</span><br><span class="line">    String javaLibraryPath = System.getProperty(&quot;java.library.path&quot;);</span><br><span class="line">    if (javaLibraryPath == null) &#123;</span><br><span class="line">        return EmptyArray.STRING;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] paths = javaLibraryPath.split(&quot;:&quot;);</span><br><span class="line">    for (int i = 0; i &lt; paths.length; ++i) &#123;</span><br><span class="line">        if (!paths[i].endsWith(&quot;/&quot;)) &#123;</span><br><span class="line">            paths[i] += &quot;/&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return paths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initLibPaths</code> 路径是默认的 lib 路径 返回的路径是</p><blockquote><p> /system/lib/<br>/vendor/lib/<br>/product/lib/</p></blockquote><h3 id="1-4-BaseDexClassLoader-findLibrary"><a href="#1-4-BaseDexClassLoader-findLibrary" class="headerlink" title="1.4 BaseDexClassLoader.findLibrary"></a>1.4 BaseDexClassLoader.findLibrary</h3><p>通过 ClassLoader 查找 so</p><p>[&gt; libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pathList.findLibrary(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pathList 是 DexPathList</p><h3 id="1-5-DexPathList-findLibrary"><a href="#1-5-DexPathList-findLibrary" class="headerlink" title="1.5 DexPathList#findLibrary"></a>1.5 DexPathList#findLibrary</h3><p>[&gt;libcore/dalvik/src/main/java/dalvik/system/DexPathList.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String libraryName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过 so 的名称拼接成文件路径</span></span><br><span class="line">    String fileName = System.mapLibraryName(libraryName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (NativeLibraryElement element : nativeLibraryPathElements) &#123;</span><br><span class="line">        String path = element.findNativeLibrary(fileName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (path != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> path;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如<br><code>System.mapLibraryName(native-lib)</code> 返回的是 <code>libnative-lib.so</code></p><p><code>nativeLibraryPathElements</code> 是 native library 路径的集合， 它的是 <code>DexPathList</code> 初始化的时候赋值，详见 1.7节</p><h3 id="1-6-DexPathList-NativeLibraryElement-findNativeLibrary"><a href="#1-6-DexPathList-NativeLibraryElement-findNativeLibrary" class="headerlink" title="1.6 DexPathList$NativeLibraryElement#findNativeLibrary"></a>1.6 DexPathList$NativeLibraryElement#findNativeLibrary</h3><p>[&gt;libcore/dalvik/src/main/java/dalvik/system/DexPathList.java]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public String findNativeLibrary(String name) &#123;</span><br><span class="line">    maybeInit();</span><br><span class="line"></span><br><span class="line">    if (zipDir == null) &#123;</span><br><span class="line">        String entryPath = new File(path, name).getPath();</span><br><span class="line">        // 能打开并且只读的 so</span><br><span class="line">        if (IoUtils.canOpenReadOnly(entryPath)) &#123;</span><br><span class="line">            return entryPath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (urlHandler != null) &#123;</span><br><span class="line">        String entryName = zipDir + &apos;/&apos; + name;</span><br><span class="line">        if (urlHandler.isEntryStored(entryName)) &#123;</span><br><span class="line">          return path.getPath() + zipSeparator + entryName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-DexPathList-DexPathList"><a href="#1-7-DexPathList-DexPathList" class="headerlink" title="1.7 DexPathList#DexPathList"></a>1.7 DexPathList#DexPathList</h3><p>[&gt;libcore/dalvik/src/main/java/dalvik/system/DexPathList.java]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DexPathList(ClassLoader definingContext, String dexPath,</span><br><span class="line">    String librarySearchPath, File optimizedDirectory, boolean isTrusted) &#123;</span><br><span class="line">  </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    this.definingContext = definingContext;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;();</span><br><span class="line">    // save dexPath for BaseDexClassLoader</span><br><span class="line">   //  dex 的路径</span><br><span class="line">    this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,</span><br><span class="line">                                           suppressedExceptions, definingContext, isTrusted);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    // Native 库的路径</span><br><span class="line">    this.nativeLibraryDirectories = splitPaths(librarySearchPath, false);</span><br><span class="line">    //  系统 Native 库的路径</span><br><span class="line">    this.systemNativeLibraryDirectories =</span><br><span class="line">            splitPaths(System.getProperty(&quot;java.library.path&quot;), true);</span><br><span class="line">    // 所有的 Natvie</span><br><span class="line">    this.nativeLibraryPathElements = makePathElements(getAllNativeLibraryDirectories());</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>DexPathList</code> 的构造函数中，我们可以知道 <code>nativeLibraryPathElements</code> 是所有 Native Library 的集合。</p><p><code>DexPathList</code> 是在 ActivityThread 中创建，ActivityThread 是在 App 启动时候创建的。关于 App 启动的启动流程，可以去找这方面的资料，自行查看。</p><p>总结一些 Native Library 的路径来源：</p><ul><li><p>一个是 Native 库的原始路径 <code>System.getProperty(&quot;java.library.path****&quot;)</code>,<br>  /system/lib/; /vendor/lib/; /product/lib/</p></li><li><p>另外一个是App启动时的 Lib 库路径</p></li></ul><p><img src="/2020/03/28/android-so-load/android_so_1.png" width="80%" height="30%"></p><h3 id="1-8-Runtime-doLoad"><a href="#1-8-Runtime-doLoad" class="headerlink" title="1.8 Runtime#doLoad"></a>1.8 Runtime#doLoad</h3><p>在上面我们解决 Native Library 的路径问题，下面分析一下加载的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">doLoad</span><span class="params">(String name, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    String librarySearchPath = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="keyword">null</span> &amp;&amp; loader <span class="keyword">instanceof</span> BaseDexClassLoader) &#123;</span><br><span class="line">        BaseDexClassLoader dexClassLoader = (BaseDexClassLoader) loader;</span><br><span class="line">        librarySearchPath = dexClassLoader.getLdLibraryPath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用 native 方法加载 so, librarySearchPath 就是前面分析的路径的路径</span></span><br><span class="line">        <span class="keyword">return</span> nativeLoad(name, loader, librarySearchPath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">nativeLoad</span><span class="params">(String filename, ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            String librarySearchPath)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="1-9-Runtime-c-Runtime-nativeLoad"><a href="#1-9-Runtime-c-Runtime-nativeLoad" class="headerlink" title="1.9 Runtime.c#Runtime_nativeLoad"></a>1.9 Runtime.c#Runtime_nativeLoad</h3><p>[&gt; libcore/ojluni/src/main/native/Runtime.c]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line">Runtime_nativeLoad(JNIEnv* env, jclass ignored, jstring javaFilename,</span><br><span class="line">                   jobject javaLoader, jclass caller)</span><br><span class="line">&#123;</span><br><span class="line">    return JVM_NativeLoad(env, javaFilename, javaLoader, caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Runtime.c 中 <code>Runtime_nativeLoad</code> 方法会调用 <code>JVM_NativeLoad</code></p><h3 id="1-10-OpenjdkJvm-cc-JVM-NativeLoad"><a href="#1-10-OpenjdkJvm-cc-JVM-NativeLoad" class="headerlink" title="1.10 OpenjdkJvm.cc#JVM_NativeLoad"></a>1.10 OpenjdkJvm.cc#JVM_NativeLoad</h3><p>[&gt;art/openjdkjvm/OpenjdkJvm.cc]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jstring JVM_NativeLoad(JNIEnv* env,</span><br><span class="line">                                 jstring javaFilename,</span><br><span class="line">                                 jobject javaLoader,</span><br><span class="line">                                 jclass caller) &#123;</span><br><span class="line">  ScopedUtfChars filename(env, javaFilename);</span><br><span class="line">  if (filename.c_str() == nullptr) &#123;</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::string error_msg;</span><br><span class="line">  &#123;</span><br><span class="line">    // 获取 java 虚拟机</span><br><span class="line">    art::JavaVMExt* vm = art::Runtime::Current()-&gt;GetJavaVM();</span><br><span class="line">    // 加载 调用java 虚拟机中 NativieLibrary 方法去加载 so</span><br><span class="line">    bool success = vm-&gt;LoadNativeLibrary(env,</span><br><span class="line">                                         filename.c_str(),</span><br><span class="line">                                         javaLoader,</span><br><span class="line">                                         caller,</span><br><span class="line">                                         &amp;error_msg);</span><br><span class="line">    if (success) &#123;</span><br><span class="line">      return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h3 id="1-11-java-vm-ext-cc-JVM-NativeLoad"><a href="#1-11-java-vm-ext-cc-JVM-NativeLoad" class="headerlink" title="1.11 java_vm_ext.cc#JVM_NativeLoad"></a>1.11 java_vm_ext.cc#JVM_NativeLoad</h3><p>[&gt;art/runtime/java_vm_ext.cc]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">bool JavaVMExt::LoadNativeLibrary(JNIEnv* env,</span><br><span class="line">                                  const std::string&amp; path,</span><br><span class="line">                                  jobject class_loader,</span><br><span class="line">                                  std::string* error_msg) &#123;</span><br><span class="line">  error_msg-&gt;clear();</span><br><span class="line"></span><br><span class="line">  SharedLibrary* library;</span><br><span class="line">  Thread* self = Thread::Current();</span><br><span class="line">  // ① 先判断 so 是否已经被加载过</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLock mu(self, *Locks::jni_libraries_lock_);</span><br><span class="line">    library = libraries_-&gt;Get(path);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    VLOG(jni) &lt;&lt; &quot;[Shared library \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; already loaded in &quot;</span><br><span class="line">              &lt;&lt; &quot; ClassLoader &quot; &lt;&lt; class_loader &lt;&lt; &quot;]&quot;;</span><br><span class="line">    if (!library-&gt;CheckOnLoadResult()) &#123;</span><br><span class="line">      StringAppendF(error_msg, &quot;JNI_OnLoad failed on a previous attempt &quot;</span><br><span class="line">          &quot;to load \&quot;%s\&quot;&quot;, path.c_str());</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // ② 打开 so </span><br><span class="line">  ScopedLocalRef&lt;jstring&gt; library_path(env, GetLibrarySearchPath(env, class_loader));</span><br><span class="line">  Locks::mutator_lock_-&gt;AssertNotHeld(self);</span><br><span class="line">  const char* path_str = path.empty() ? nullptr : path.c_str();</span><br><span class="line">  bool needs_native_bridge = false;</span><br><span class="line">  void* handle = android::OpenNativeLibrary(env,</span><br><span class="line">                                            runtime_-&gt;GetTargetSdkVersion(),</span><br><span class="line">                                            path_str,</span><br><span class="line">                                            class_loader,</span><br><span class="line">                                            library_path.get(),</span><br><span class="line">                                            &amp;needs_native_bridge,</span><br><span class="line">                                            error_msg);</span><br><span class="line"></span><br><span class="line">  VLOG(jni) &lt;&lt; &quot;[Call to dlopen(\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;, RTLD_NOW) returned &quot; &lt;&lt; handle &lt;&lt; &quot;]&quot;;</span><br><span class="line"></span><br><span class="line">  // 打开失败返回</span><br><span class="line">  if (handle == nullptr) &#123;</span><br><span class="line">    VLOG(jni) &lt;&lt; &quot;dlopen(\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;, RTLD_NOW) failed: &quot; &lt;&lt; *error_msg;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 检测异常</span><br><span class="line">  if (env-&gt;ExceptionCheck() == JNI_TRUE) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; &quot;Unexpected exception:&quot;;</span><br><span class="line">    env-&gt;ExceptionDescribe();</span><br><span class="line">    env-&gt;ExceptionClear();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // ③ 创建一个新的 SharedLibrary 结构体放到 libraries 中</span><br><span class="line">  bool created_library = false;</span><br><span class="line">  &#123;</span><br><span class="line">    // Create SharedLibrary ahead of taking the libraries lock to maintain lock ordering.</span><br><span class="line">    std::unique_ptr&lt;SharedLibrary&gt; new_library(</span><br><span class="line">        new SharedLibrary(env,</span><br><span class="line">                          self,</span><br><span class="line">                          path,</span><br><span class="line">                          handle,</span><br><span class="line">                          needs_native_bridge,</span><br><span class="line">                          class_loader,</span><br><span class="line">                          class_loader_allocator));</span><br><span class="line"></span><br><span class="line">    MutexLock mu(self, *Locks::jni_libraries_lock_);</span><br><span class="line">    library = libraries_-&gt;Get(path);</span><br><span class="line">    if (library == nullptr) &#123;  // We won race to get libraries_lock.</span><br><span class="line">      library = new_library.release();</span><br><span class="line">      libraries_-&gt;Put(path, library);</span><br><span class="line">      created_library = true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!created_library) &#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;WOW: we lost a race to add shared library: &quot;</span><br><span class="line">        &lt;&lt; &quot;\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; ClassLoader=&quot; &lt;&lt; class_loader;</span><br><span class="line">    return library-&gt;CheckOnLoadResult();</span><br><span class="line">  &#125;</span><br><span class="line">  VLOG(jni) &lt;&lt; &quot;[Added shared library \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; for ClassLoader &quot; &lt;&lt; class_loader &lt;&lt; &quot;]&quot;;</span><br><span class="line"></span><br><span class="line">  // ④ 查找 ”JNI_OnLoad“ 符号</span><br><span class="line">  bool was_successful = false;</span><br><span class="line">  void* sym = library-&gt;FindSymbol(&quot;JNI_OnLoad&quot;, nullptr);</span><br><span class="line">  // 没有查找到， 标记为加载成功</span><br><span class="line">  if (sym == nullptr) &#123;</span><br><span class="line">    VLOG(jni) &lt;&lt; &quot;[No JNI_OnLoad found in \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;]&quot;;</span><br><span class="line">    was_successful = true;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 如果我们在 JNI 中已经复写了 JNI_OnLoad 方法，则需要重写 ClassLoader</span><br><span class="line">    ScopedLocalRef&lt;jobject&gt; old_class_loader(env, env-&gt;NewLocalRef(self-&gt;GetClassLoaderOverride()));</span><br><span class="line">    self-&gt;SetClassLoaderOverride(class_loader);</span><br><span class="line"></span><br><span class="line">    VLOG(jni) &lt;&lt; &quot;[Calling JNI_OnLoad in \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;]&quot;;</span><br><span class="line">    typedef int (*JNI_OnLoadFn)(JavaVM*, void*);</span><br><span class="line">    JNI_OnLoadFn jni_on_load = reinterpret_cast&lt;JNI_OnLoadFn&gt;(sym);</span><br><span class="line">    int version = (*jni_on_load)(this, nullptr);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    self-&gt;SetClassLoaderOverride(old_class_loader.get());</span><br><span class="line"></span><br><span class="line">    // 判断 JNI 版本</span><br><span class="line">    if (version == JNI_ERR) &#123;</span><br><span class="line">      StringAppendF(error_msg, &quot;JNI_ERR returned from JNI_OnLoad in \&quot;%s\&quot;&quot;, path.c_str());</span><br><span class="line">    &#125; else if (JavaVMExt::IsBadJniVersion(version)) &#123;</span><br><span class="line">      StringAppendF(error_msg, &quot;Bad JNI version returned from JNI_OnLoad in \&quot;%s\&quot;: %d&quot;,</span><br><span class="line">                    path.c_str(), version);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      was_successful = true;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 返回加载结果</span><br><span class="line">  library-&gt;SetResult(was_successful);</span><br><span class="line">  return was_successful;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的内容比较多，需要一步步分析</p><ul><li>第一步是判断 so 是否已经被加载过，如果已经加载过了，则直接返回加载成功</li><li>第二步是打开 so, 返回 <code>handle</code>句柄，如果返回的句柄为空，这份表示加载失败</li><li>第三步是创建一个 <code>SharedLibrary</code> 结构体，放到 <code>libraries</code> 中缓存</li><li>第四步是查找 <code>JNI_OnLoad</code> 符号，这里分两种情况<ul><li>如果在 JNI 中没有写 <code>JNI_OnLoad</code> 方法，找不到符号，返回加成功</li><li>另一种情况是，如果 JNI 中有 <code>JNI_OnLoad</code> 方法，则会重写当前的 ClassLoader, 并且判断 JNI 版本</li></ul></li></ul><p>从上面的第四步，<strong>我们可以知道加载 so 中 JNI 的入口是 <code>JNI_OnLoad</code> 方法，所以在写 JNI 的时候，会在 <code>JNI_OnLoad</code>方法中做一些初始化的工作。另外一个就是，如果写了 <code>JNI_OnLoad</code> 方法，就要指定 JNI 版本。</strong></p><p>判断 JNI 的版本</p><p>[&gt;art/runtime/java_vm_ext.cc]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool JavaVMExt::IsBadJniVersion(int version) &#123;</span><br><span class="line">  // We don&apos;t support JNI_VERSION_1_1. These are the only other valid versions.</span><br><span class="line">  return version != JNI_VERSION_1_2 &amp;&amp; version != JNI_VERSION_1_4 &amp;&amp; version != JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是判断 JNI 版本，可以看到只能是 <code>JNI_VERSION_1_2,JNI_VERSION_1_4,JNI_VERSION_1_6</code> 三个版本</p><p>下来是我们平时在写 JNI 的时候, <code>JNI_OnLoad</code> 方法中需要给定 jni 的版本， 同时做一些初始化的工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int JNI_OnLoad(JavaVM *vm, void *reserved) &#123;</span><br><span class="line">    JNIEnv *env;</span><br><span class="line">    jVM = vm;</span><br><span class="line"></span><br><span class="line">    // 设定 jni 版本为 1_4</span><br><span class="line">    if ((*vm)-&gt;GetEnv(vm, (void **) &amp;env, JNI_VERSION_1_4) != JNI_OK) &#123; </span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 初始化的工作</span><br><span class="line">     android_dumpVideo = (*env)-&gt;GetStaticMethodID(env, cEmulator, &quot;bitblt&quot;,</span><br><span class="line">                                                  &quot;(Ljava/nio/ByteBuffer;)V&quot;);</span><br><span class="line"></span><br><span class="line">    if (android_dumpVideo == NULL) &#123;</span><br><span class="line">        __android_log_print(ANDROID_LOG_ERROR, &quot;mame4droid-jni&quot;, &quot;Failed to find method bitblt&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    android_changeVideo = (*env)-&gt;GetStaticMethodID(env, cEmulator, &quot;changeVideo&quot;, &quot;(IIII)V&quot;);</span><br><span class="line"></span><br><span class="line">    if (android_changeVideo == NULL) &#123;</span><br><span class="line">        __android_log_print(ANDROID_LOG_ERROR, &quot;mame4droid-jni&quot;,</span><br><span class="line">                            &quot;Failed to find method changeVideo&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-So-的加载原理"><a href="#2-So-的加载原理" class="headerlink" title="2. So 的加载原理"></a>2. So 的加载原理</h2><p>在前面的部分，我们梳理了 so 加载的整个流程，但这个过程还有一些以为，包括：</p><ul><li>ClassLoader 从哪里来</li><li>Native 库是怎样来的</li><li>so 是怎样到 Native 库里面的</li></ul><p>下面将一个个来查找这些疑问的答案</p><h3 id="2-1-ClassLoader-是怎样来的"><a href="#2-1-ClassLoader-是怎样来的" class="headerlink" title="2.1 ClassLoader 是怎样来的"></a>2.1 ClassLoader 是怎样来的</h3><h3 id="2-1-1-System-loadLibrary"><a href="#2-1-1-System-loadLibrary" class="headerlink" title="2.1.1 System#loadLibrary"></a>2.1.1 System#loadLibrary</h3><p>[&gt; java/lang/System.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libname)</span> </span>&#123;</span><br><span class="line">      Runtime.getRuntime().loadLibrary0(VMStack.getCallingClassLoader(), libname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载的 ClassLoader 从 VMStack 中获取， VMStack 再去从 Native 中获取</p><p>[&gt;/libcore/libart/src/main/java/dalvik/system/VMStack.java]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@FastNative</span><br><span class="line">native public static ClassLoader getCallingClassLoader();</span><br></pre></td></tr></table></figure><h3 id="2-1-2-ActivityThread-handleBindApplication"><a href="#2-1-2-ActivityThread-handleBindApplication" class="headerlink" title="2.1.2 ActivityThread#handleBindApplication"></a>2.1.2 ActivityThread#handleBindApplication</h3><p>[&gt;/frameworks/base/core/java/android/app/ActivityThread.java]</p><p>在 ActivityThread 是 Android App 启动的入口，关于 App 的启动可参考其他资料。<br>App 启动过程，会调到 ActivityThread#handleBindApplication 方法。<br>在这个方法中，会创建 <code>LoadedApk</code>  并且传入进去 Context 中的 ClassLoader.<br>Context 的实现是 ContextImpl，Context#getClassLoader() 方法，去看 ContextImpl#getClassLoader()， 详见 2.1.3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 LoadedApk，使用是 Context 的 ClassLoader</span></span><br><span class="line">    LoadedApk pi = getPackageInfo(instrApp, data.compatInfo, appContext.getClassLoader(), <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 将 ActivityThread 和 LoadedApk 作为创建 ContextImpl 的参数</span></span><br><span class="line">    ContextImpl instrContext = ContextImpl.createAppContext(<span class="keyword">this</span>, pi);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = instrContext.getClassLoader();</span><br><span class="line">        mInstrumentation = (Instrumentation) cl.loadClass(data.instrumentationName.getClassName())</span><br><span class="line">                .newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to instantiate instrumentation "</span> + data.instrumentationName + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-3-ContextImpl-getClassLoader"><a href="#2-1-3-ContextImpl-getClassLoader" class="headerlink" title="2.1.3 ContextImpl#getClassLoader"></a>2.1.3 ContextImpl#getClassLoader</h3><p>[&gt;/frameworks/base/core/java/android/app/ContextImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mClassLoader != <span class="keyword">null</span> ? mClassLoader : (mPackageInfo != <span class="keyword">null</span> ? mPackageInfo.getClassLoader() : ClassLoader.getSystemClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑有点绕，将代码整理改成下面，会更加容易看懂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mClassLoader != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> mClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> mPackageInfo.getClassLoader();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过整理的代码逻辑就很清晰了，第一次进来的时候 mClassLoader 是空的，只要看后面的逻辑。<br>mPackageInfo是 LoadApk, mPackageInfo 不会为空，在 2.1.2 节知道它是 ContextImpl 创建的时候传进来的mP。所以，ackageInfo.getClassLoader()  是调用了  LoadApk#getClassLoader() 方法，关于这个方法详见 2.1.4</p><h3 id="2-1-4-LoadApk-getClassLoader"><a href="#2-1-4-LoadApk-getClassLoader" class="headerlink" title="2.1.4 LoadApk#getClassLoader"></a>2.1.4 LoadApk#getClassLoader</h3><p>[&gt;/frameworks/base/core/java/android/app/LoadApk.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mClassLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            createOrUpdateClassLoaderLocked(<span class="keyword">null</span> <span class="comment">/*addedPaths*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createOrUpdateClassLoaderLocked</span><span class="params">(List&lt;String&gt; addedPaths)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    ···</span></span><br><span class="line"><span class="function">    <span class="comment">// 创建 LoadApk 的时候，传进 mIncludeCode 的值是 false</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(!mIncludeCode)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mClassLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();</span><br><span class="line">                mClassLoader = ApplicationLoaders.getDefault().getClassLoader(</span><br><span class="line">                        <span class="string">""</span> <span class="comment">/* codePath */</span>, mApplicationInfo.targetSdkVersion, isBundledApp,</span><br><span class="line">                        librarySearchPath, libraryPermittedPath, mBaseClassLoader,</span><br><span class="line">                        <span class="keyword">null</span> <span class="comment">/* classLoaderName */</span>);</span><br><span class="line">                StrictMode.setThreadPolicy(oldPolicy);</span><br><span class="line">                mAppComponentFactory = AppComponentFactory.DEFAULT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 调用  ApplicationLoaders.getDefault() 创建 ClassLoader, </span></span><br><span class="line">     <span class="keyword">if</span> (mClassLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ..</span><br><span class="line">        mClassLoader = ApplicationLoaders.getDefault().getClassLoader(zip,</span><br><span class="line">                mApplicationInfo.targetSdkVersion, isBundledApp, librarySearchPath,</span><br><span class="line">                libraryPermittedPath, mBaseClassLoader,</span><br><span class="line">                mApplicationInfo.classLoaderName);</span><br><span class="line">        mAppComponentFactory = createAppFactory(mApplicationInfo, mClassLoader);</span><br><span class="line">    </span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-5-ApplicationLoaders-getClassLoader"><a href="#2-1-5-ApplicationLoaders-getClassLoader" class="headerlink" title="2.1.5 ApplicationLoaders#getClassLoader"></a>2.1.5 ApplicationLoaders#getClassLoader</h3><p>[&gt;/frameworks/base/core/java/android/app/ApplicationLoaders.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">(String zip, <span class="keyword">int</span> targetSdkVersion, <span class="keyword">boolean</span> isBundled,</span></span></span><br><span class="line"><span class="function"><span class="params">                           String librarySearchPath, String libraryPermittedPath,</span></span></span><br><span class="line"><span class="function"><span class="params">                           ClassLoader parent, String classLoaderName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// For normal usage the cache key used is the same as the zip path.</span></span><br><span class="line">    <span class="keyword">return</span> getClassLoader(zip, targetSdkVersion, isBundled, librarySearchPath,</span><br><span class="line">                          libraryPermittedPath, parent, zip, classLoaderName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> ClassLoader <span class="title">getClassLoader</span><span class="params">(String zip, <span class="keyword">int</span> targetSdkVersion, <span class="keyword">boolean</span> isBundled,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       String librarySearchPath, String libraryPermittedPath,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       ClassLoader parent, String cacheKey,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       String classLoaderName)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">synchronized</span> (mLoaders) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                parent = baseParent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 试图从缓存总去取 ClassLoader</span></span><br><span class="line">            <span class="keyword">if</span> (parent == baseParent) &#123;</span><br><span class="line">                ClassLoader loader = mLoaders.get(cacheKey);</span><br><span class="line">                <span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> loader;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建 ClassLoader</span></span><br><span class="line">            ClassLoader classloader = ClassLoaderFactory.createClassLoader(</span><br><span class="line">                    zip,  librarySearchPath, libraryPermittedPath, parent,</span><br><span class="line">                    targetSdkVersion, isBundled, classLoaderName);</span><br><span class="line">                mLoaders.put(cacheKey, classloader);</span><br><span class="line">                <span class="keyword">return</span> classloader;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-6-ClassLoaderFactory-createClassLoader"><a href="#2-1-6-ClassLoaderFactory-createClassLoader" class="headerlink" title="2.1.6 ClassLoaderFactory#createClassLoader"></a>2.1.6 ClassLoaderFactory#createClassLoader</h3><p>[&gt;/frameworks/base/core/java/com/android/internal/os/ClassLoaderFactory.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">createClassLoader</span><span class="params">(String dexPath,</span></span></span><br><span class="line"><span class="function"><span class="params">    String librarySearchPath, ClassLoader parent, String classloaderName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isPathClassLoaderName(classloaderName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PathClassLoader(dexPath, librarySearchPath, parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDelegateLastClassLoaderName(classloaderName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegateLastClassLoader(dexPath, librarySearchPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Invalid classLoaderName: "</span> + classloaderName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面这么多步，终于看到了创建创建 ClassLoader 的地方.<br>根据参数的 classloaderName 的不同，会创建  PathClassLoader 或者 DelegateLastClassLoader。 </p><p>classloaderName 参数是 app 启动的时候传下来的，见 2.1.4 节</p><p>总的来说，<strong>ClassLoader 是 app 启动的时候， ActivityThread 中经过一步步的调用，最后在 ApplicationLoaders 中用 ClassLoaderFactory 创建。</strong></p><p>ClassLoader 的分类</p><p><img src="/2020/03/28/android-so-load/android_so_2.png" width="80%" height="30%"></p><p>关于不同的 ClassLoader 有不同的作用，可以去查相关的资料</p><p>到此，我们的第一个问题解决了，ClassLoader 是 app 启动的时候在 ActivityThread 中创建。 </p><h2 id="2-2-Native-库是怎样来的"><a href="#2-2-Native-库是怎样来的" class="headerlink" title="2.2 Native 库是怎样来的"></a>2.2 Native 库是怎样来的</h2><p>通过对 DexPathList 的分析，可以知道 Native Library 来自来自两个地方</p><ul><li><p>一个是 DexPathList 创建的时候，构造函数传进来的 librarySearchPath。</p></li><li><p>另外一个是 addNativePath(Collection<string> libPaths)<br>例如 :</string></p><blockquote><p>/data/app/com.test.baidu/base.apk!/lib/armeabi-v7a</p></blockquote></li></ul><h3 id="2-2-1-DexPathList-findLibrary"><a href="#2-2-1-DexPathList-findLibrary" class="headerlink" title="2.2.1 DexPathList#findLibrary"></a>2.2.1 DexPathList#findLibrary</h3><p>在第一章的时候，加载 so 会调用到 DexPathList#findLibrary 方法，在这个方法里面会遍历 nativeLibraryPathElements。 nativeLibraryPathElements 是 NativeLibrary 路径的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String libraryName)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    String fileName = System.mapLibraryName(libraryName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (NativeLibraryElement element : nativeLibraryPathElements) &#123;</span><br><span class="line">        String path = element.findNativeLibrary(fileName);</span><br><span class="line">        <span class="keyword">if</span> (path != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> path;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>System.mapLibraryName 的实现是在 System.c 里面，返回 so 的文件名，例如 </p><blockquote><p>libraryName 是 test_baidu,<br>System.mapLibraryName(‘test_baidu’) 返回的是  libtest_baidu.so</p></blockquote><p>下面要看看 <code>nativeLibraryPathElements</code>是怎么来的<br>NativeLibraryElement 类是 Native Library 的路径元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> static class NativeLibraryElement &#123;</span><br><span class="line">        </span><br><span class="line">    private final File path;</span><br><span class="line">    private final String zipDir;</span><br><span class="line"></span><br><span class="line">    public NativeLibraryElement(File dir) &#123;</span><br><span class="line">        this.path = dir;</span><br><span class="line">        this.zipDir = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NativeLibraryElement(File zip, String zipDir) &#123;</span><br><span class="line">        this.path = zip;</span><br><span class="line">        this.zipDir = zipDir;</span><br><span class="line"></span><br><span class="line">        if (zipDir == null) &#123;</span><br><span class="line">          throw new IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-1-DexPathList-DexPathList-构造函数"><a href="#2-2-1-DexPathList-DexPathList-构造函数" class="headerlink" title="2.2.1 DexPathList#DexPathList 构造函数"></a>2.2.1 DexPathList#DexPathList 构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DexPathList(ClassLoader definingContext, String dexPath,</span><br><span class="line">            String librarySearchPath, File optimizedDirectory, boolean isTrusted) &#123;</span><br><span class="line">            </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,</span><br><span class="line">                                           suppressedExceptions, definingContext, isTrusted);</span><br><span class="line"></span><br><span class="line">    //  ① 创建是传入进来的 librarySearchPath</span><br><span class="line">    this.nativeLibraryDirectories = splitPaths(librarySearchPath, false);</span><br><span class="line">        </span><br><span class="line">   //  ② 系统的 &quot;java.library.path&quot; 路径  </span><br><span class="line">    this.systemNativeLibraryDirectories = splitPaths(System.getProperty(&quot;java.library.path&quot;), true);</span><br><span class="line">    List&lt;File&gt; allNativeLibraryDirectories = new ArrayList&lt;&gt;(nativeLibraryDirectories);</span><br><span class="line">    allNativeLibraryDirectories.addAll(systemNativeLibraryDirectories);</span><br><span class="line">    this.nativeLibraryPathElements = makePathElements(allNativeLibraryDirectories);</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 DexPathList 的构造函数中，我们可以看到 Native library 存在两个方面</p><ul><li>一个是传入进来的 librarySearchPath</li><li>另外一个是通过虚拟机属性 <code>java.library.path</code> 获取的系统 Native 库</li></ul><h3 id="2-2-2-DexPathList-addNativePath"><a href="#2-2-2-DexPathList-addNativePath" class="headerlink" title="2.2.2 DexPathList#addNativePath"></a>2.2.2 DexPathList#addNativePath</h3><p>外部添加的 libPaths 路径<br>例如 </p><blockquote><p>/data/app/com.test.baidu/base.apk!/lib/armeabi-v7a</p></blockquote><p>DexPathList#addNativePath 是在 ApplicationLoaders#addNative 中调用，见 2.2.3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void addNativePath(Collection&lt;String&gt; libPaths) &#123;</span><br><span class="line">    if (libPaths.isEmpty()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;File&gt; libFiles = new ArrayList&lt;&gt;(libPaths.size());</span><br><span class="line">    for (String path : libPaths) &#123;</span><br><span class="line">        libFiles.add(new File(path));</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;NativeLibraryElement&gt; newPaths =</span><br><span class="line">            new ArrayList&lt;&gt;(nativeLibraryPathElements.length + libPaths.size());</span><br><span class="line">    newPaths.addAll(Arrays.asList(nativeLibraryPathElements));</span><br><span class="line">    for (NativeLibraryElement element : makePathElements(libFiles)) &#123;</span><br><span class="line">        if (!newPaths.contains(element)) &#123;</span><br><span class="line">            newPaths.add(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nativeLibraryPathElements = newPaths.toArray(new NativeLibraryElement[newPaths.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-ApplicationLoaders-addNative"><a href="#2-2-3-ApplicationLoaders-addNative" class="headerlink" title="2.2.3 ApplicationLoaders#addNative"></a>2.2.3 ApplicationLoaders#addNative</h3><p>[&gt;/frameworks/base/core/java/android/app/ApplicationLoaders.java]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void addNative(ClassLoader classLoader, Collection&lt;String&gt; libPaths) &#123;</span><br><span class="line">        if (!(classLoader instanceof PathClassLoader)) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;class loader is not a PathClassLoader&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        final PathClassLoader baseDexClassLoader = (PathClassLoader) classLoader;</span><br><span class="line">        baseDexClassLoader.addNativePath(libPaths);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-4-LoadedApk-createOrUpdateClassLoaderLocked"><a href="#2-2-4-LoadedApk-createOrUpdateClassLoaderLocked" class="headerlink" title="2.2.4 LoadedApk#createOrUpdateClassLoaderLocked"></a>2.2.4 LoadedApk#createOrUpdateClassLoaderLocked</h3><p>[&gt; /frameworks/base/core/java/android/app/LoadedApk.java]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">private void createOrUpdateClassLoaderLocked(List&lt;String&gt; addedPaths) &#123;</span><br><span class="line">        </span><br><span class="line">    ...</span><br><span class="line">       </span><br><span class="line">    // ① 默认 library 的路径</span><br><span class="line">   final String defaultSearchPaths = System.getProperty(&quot;java.library.path&quot;);</span><br><span class="line">    final boolean treatVendorApkAsUnbundled = !defaultSearchPaths.contains(&quot;/vendor/lib&quot;);</span><br><span class="line">    if (mApplicationInfo.getCodePath() != null</span><br><span class="line">            &amp;&amp; mApplicationInfo.isVendor() &amp;&amp; treatVendorApkAsUnbundled) &#123;</span><br><span class="line">        isBundledApp = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ②</span><br><span class="line">    makePaths(mActivityThread, isBundledApp, mApplicationInfo, zipPaths, libPaths);</span><br><span class="line">    String libraryPermittedPath = mDataDir;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">  // ③ 创建 ClassLoader</span><br><span class="line">   if (mClassLoader == null) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mClassLoader = ApplicationLoaders.getDefault().getClassLoader(zip,</span><br><span class="line">                mApplicationInfo.targetSdkVersion, isBundledApp, librarySearchPath,</span><br><span class="line">                libraryPermittedPath, mBaseClassLoader,</span><br><span class="line">                mApplicationInfo.classLoaderName);</span><br><span class="line">        mAppComponentFactory = createAppFactory(mApplicationInfo, mClassLoader);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!libPaths.isEmpty() &amp;&amp; SystemProperties.getBoolean(PROPERTY_NAME_APPEND_NATIVE, true)) &#123;</span><br><span class="line">        ...</span><br><span class="line">        try &#123;</span><br><span class="line">            // ④ 添加 libPaths 路径</span><br><span class="line">        ApplicationLoaders.getDefault().addNative(mClassLoader, libPaths);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            StrictMode.setThreadPolicy(oldPolicy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    // ⑤ 其他的 lib 路径 到 defaultSearchPaths</span><br><span class="line">  List&lt;String&gt; extraLibPaths = new ArrayList&lt;&gt;(3);</span><br><span class="line">    String abiSuffix = VMRuntime.getRuntime().is64Bit() ? &quot;64&quot; : &quot;&quot;;</span><br><span class="line">    if (!defaultSearchPaths.contains(&quot;/vendor/lib&quot;)) &#123;</span><br><span class="line">        extraLibPaths.add(&quot;/vendor/lib&quot; + abiSuffix);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!defaultSearchPaths.contains(&quot;/odm/lib&quot;)) &#123;</span><br><span class="line">        extraLibPaths.add(&quot;/odm/lib&quot; + abiSuffix);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!defaultSearchPaths.contains(&quot;/product/lib&quot;)) &#123;</span><br><span class="line">        extraLibPaths.add(&quot;/product/lib&quot; + abiSuffix);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!extraLibPaths.isEmpty()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        try &#123;</span><br><span class="line">            // ⑥ 将 其他 lib 路径也添加到 DexPathList 中</span><br><span class="line">            ApplicationLoaders.getDefault().addNative(mClassLoader, extraLibPaths);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            StrictMode.setThreadPolicy(oldPolicy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createOrUpdateClassLoaderLocked 方法里面创建 ClassLoader 并且设置 lib 路径</p><ul><li>首先 defaultSearchPaths 默认路径，在 ①⑤中获取并放置进去，包含</li></ul><blockquote><p> /system/lib/<br>/vendor/lib/<br>/product/lib/</p></blockquote><ul><li>其次，在 ② 中 makePaths</li><li>在 ④⑥中将 libs 路径添加到 DexPathList 中</li></ul><h3 id="2-2-5-LoadedApk-makePaths"><a href="#2-2-5-LoadedApk-makePaths" class="headerlink" title="2.2.5 LoadedApk#makePaths"></a>2.2.5 LoadedApk#makePaths</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public static void makePaths(ActivityThread activityThread,</span><br><span class="line">                                 boolean isBundledApp,</span><br><span class="line">                                 ApplicationInfo aInfo,</span><br><span class="line">                                 List&lt;String&gt; outZipPaths,</span><br><span class="line">                                 List&lt;String&gt; outLibPaths) &#123;</span><br><span class="line">    final String appDir = aInfo.sourceDir;</span><br><span class="line">    // aInfo.nativeLibraryDir 的来源在 ActivityThread#getInstrumentationLibrary 中</span><br><span class="line">    final String libDir = aInfo.nativeLibraryDir;</span><br><span class="line">    final String[] sharedLibraries = aInfo.sharedLibraryFiles;</span><br><span class="line">        </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    String instrumentationLibDir = activityThread.mInstrumentationLibDir;</span><br><span class="line">    String instrumentedLibDir = activityThread.mInstrumentedLibDir;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    if (outLibPaths != null) &#123;</span><br><span class="line">        outLibPaths.add(instrumentationLibDir);</span><br><span class="line">        if (!instrumentationLibDir.equals(instrumentedLibDir)) &#123;</span><br><span class="line">            outLibPaths.add(instrumentedLibDir);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">        if (outLibPaths != null) &#123;</span><br><span class="line">        outLibPaths.add(instrumentationLibDir);</span><br><span class="line">        if (!instrumentationLibDir.equals(instrumentedLibDir)) &#123;</span><br><span class="line">            outLibPaths.add(instrumentedLibDir);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">         </span><br><span class="line">        if (outLibPaths.isEmpty()) &#123;</span><br><span class="line">            outLibPaths.add(libDir);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ① 根据 cpu 的不同添加不同路径</span><br><span class="line">        if (aInfo.primaryCpuAbi != null) &#123;</span><br><span class="line">            if (aInfo.targetSdkVersion &lt; Build.VERSION_CODES.N) &#123;</span><br><span class="line">                outLibPaths.add(&quot;/system/fake-libs&quot; +</span><br><span class="line">                    (VMRuntime.is64BitAbi(aInfo.primaryCpuAbi) ? &quot;64&quot; : &quot;&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">            for (String apk : outZipPaths) &#123;</span><br><span class="line">                outLibPaths.add(apk + &quot;!/lib/&quot; + aInfo.primaryCpuAbi);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (isBundledApp) &#123;</span><br><span class="line">outLibPaths.add(System.getProperty(&quot;java.library.path&quot;));</span><br><span class="line">        &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ① 中，会根据 cpu 架构的不同，而添加不同路径，例如，如果手机 cpu 的架构 是 armeabi-v7a, 那 <code>apk + &quot;!/lib/&quot; + aInfo.primaryCpuAbi</code> 就是</p><blockquote><p>data/app/包名==/base.apk!/lib/armeabli-v7a</p></blockquote><h3 id="2-2-6-ActivityThread-getInstrumentationLibrary"><a href="#2-2-6-ActivityThread-getInstrumentationLibrary" class="headerlink" title="2.2.6 ActivityThread#getInstrumentationLibrary"></a>2.2.6 ActivityThread#getInstrumentationLibrary</h3><p>[&gt;/frameworks/base/core/java/android/app/ActivityThread.java]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private String getInstrumentationLibrary(ApplicationInfo appInfo, InstrumentationInfo insInfo) &#123;</span><br><span class="line">    if (appInfo.primaryCpuAbi != null &amp;&amp; appInfo.secondaryCpuAbi != null</span><br><span class="line">            &amp;&amp; appInfo.secondaryCpuAbi.equals(insInfo.secondaryCpuAbi)) &#123;</span><br><span class="line">       </span><br><span class="line">        String secondaryIsa =</span><br><span class="line">                VMRuntime.getInstructionSet(appInfo.secondaryCpuAbi);</span><br><span class="line">        final String secondaryDexCodeIsa =</span><br><span class="line">                SystemProperties.get(&quot;ro.dalvik.vm.isa.&quot; + secondaryIsa);</span><br><span class="line">        secondaryIsa = secondaryDexCodeIsa.isEmpty() ? secondaryIsa : secondaryDexCodeIsa;</span><br><span class="line"></span><br><span class="line">        final String runtimeIsa = VMRuntime.getRuntime().vmInstructionSet();</span><br><span class="line">        if (runtimeIsa.equals(secondaryIsa)) &#123;</span><br><span class="line">            return insInfo.secondaryNativeLibraryDir;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return insInfo.nativeLibraryDir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ActivityThread 中的 nativeLibraryDir 通过 getInstrumentationLibrary 方法获取，也是通过 <code>SystemProperties.get(&quot;ro.dalvik.vm.isa.&quot; + secondaryIsa);</code> 系统属性获取</p><p>总的来说 NativeLibraryPath 主要是来至于几个方面</p><ul><li><p>一个是系统的 <code>java.library.path</code> 属性，是</p><blockquote><p>/system/lib<br>/vendor/lib<br>/product/lib</p></blockquote></li><li><p>一个是 <code>apk + &quot;!/lib/&quot; + aInfo.primaryCpuAbi</code> </p><blockquote><p>/data/app/包名==/base.apk!/lib/armeabli-v7a</p></blockquote></li></ul><ul><li>一个是 <code>&quot;ro.dalvik.vm.isa.&quot; + secondaryIsa</code> 属性<blockquote><p>/data/app/包名==/lib/arm</p></blockquote></li></ul><p>如下图中的 nativeLiraryPathsElements中的路径<br><img src="/2020/03/28/android-so-load/android_so_1.png" width="80%" height="30%"></p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>通过上面的分析，已经回答了我们在前言部分的三个疑问，那接下来就要解决这个异常了。<br>我们知道</p><blockquote><p>Caused by: java.lang.IllegalArgumentException: Unable to find native library  using classloader: dalvik.system.PathClassLoader</p></blockquote><p>在上面的分析知道, 通过 ClassLoader#findLibrary去 libs 路径去查找我们要加载的 so, 找不到这个 path 导致。</p><p>动态加载 so，我们在通常需要把要加载的 so 从后台下载下来，然后通过 System.load(String filename) 或者 System.loadLibrary(String libname) 方法去加载 so。</p><p>那解决这个问题就是把我们下载存放 so 的路径，添加到 ClassLoader 的 libs 路径里面，而这些 libs 路径是 app 启动的时候就应经生成了。可以利用反射，在运行时路径添加进去。</p><h3 id="将存放-so-的路径放到-ClassLoader-中"><a href="#将存放-so-的路径放到-ClassLoader-中" class="headerlink" title="将存放 so 的路径放到 ClassLoader 中"></a>将存放 so 的路径放到 ClassLoader 中</h3><p>利用反射将存放 so 的路径放到 ClassLoader 中，刚好 <a href="https://github.com/Tencent/tinker/blob/dev/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java" target="_blank" rel="noopener">tinker</a> 的 TinkerLoadLibrary 也有实现发方法，我们就不用自己实现了，可以拿过来直接使用</p><p>LoadLibrary 核心代码 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V25</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(ClassLoader classLoader, File folder)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Field pathListField = RetroShareReflectUtil.findField(classLoader, <span class="string">"pathList"</span>);</span><br><span class="line">        Object dexPathList = pathListField.get(classLoader);</span><br><span class="line"></span><br><span class="line">        Field nativeLibraryDirectories = RetroShareReflectUtil.findField(dexPathList, <span class="string">"nativeLibraryDirectories"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;File&gt; libDirs = (List&lt;File&gt;) nativeLibraryDirectories.get(dexPathList);</span><br><span class="line">        libDirs.add(<span class="number">0</span>, folder);</span><br><span class="line">        Field systemNativeLibraryDirectories =</span><br><span class="line">                RetroShareReflectUtil.findField(dexPathList, <span class="string">"systemNativeLibraryDirectories"</span>);</span><br><span class="line">        List&lt;File&gt; systemLibDirs = (List&lt;File&gt;) systemNativeLibraryDirectories.get(dexPathList);</span><br><span class="line">        Method makePathElements =</span><br><span class="line">                RetroShareReflectUtil.findMethod(dexPathList, <span class="string">"makePathElements"</span>, List.class);</span><br><span class="line">        libDirs.addAll(systemLibDirs);</span><br><span class="line">        Object[] elements = (Object[]) makePathElements.</span><br><span class="line">                invoke(dexPathList, libDirs);</span><br><span class="line">        Field nativeLibraryPathElements = RetroShareReflectUtil.findField(dexPathList, <span class="string">"nativeLibraryPathElements"</span>);</span><br><span class="line">        nativeLibraryPathElements.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        nativeLibraryPathElements.set(dexPathList, elements);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于反射的代码已放到 <a href="https://github.com/yxhuangCH/AndroidSoLoad/tree/master/soload" target="_blank" rel="noopener">github</a></p><p>我的项目下载存放 so 的路径是 /data/user/0/包名/app_libs</p><p>运行之后,我们看开点 路径已经添加进了 ClassLoader 的 nativeLibraryDirecories 中</p><p><img src="/2020/03/28/android-so-load/android_so_load_3.png" width="80%" height="30%"></p><p>至此，异常解决了。<br>同时也对 so 的加载原理有了更好的了解。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://blog.csdn.net/givemeacondom/article/details/83826645" target="_blank" rel="noopener">Android_动态加载.so文件,解决apk安装包过大的问题</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1071447" target="_blank" rel="noopener">Android 动态链接库加载原理及 HotFix 方案介绍</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1563054" target="_blank" rel="noopener">Android so 加载原理分析</a></p></li><li><p><a href="http://gityuan.com/2017/03/26/load_library/" target="_blank" rel="noopener">loadLibrary动态库加载过程分析</a></p></li><li><p><a href="http://androidxref.com/" target="_blank" rel="noopener">参考 Android 源码</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在做 Android 项目的时候，需要在 NativeActivity  中动态加载 so 。运行的时候，抛出了异常&lt;/p&gt;
&lt;bloc
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>软件设计原则（一）： 依赖倒置原则</title>
    <link href="https://yxhuangch.github.io/2020/02/23/denpendence-inversion-principle/"/>
    <id>https://yxhuangch.github.io/2020/02/23/denpendence-inversion-principle/</id>
    <published>2020-02-23T00:59:24.000Z</published>
    <updated>2020-02-23T03:48:22.105Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如何不依赖代码却可以复用它的功能</p></blockquote><p>在软件设计中为了建立清晰的软件分层关系，引入了软件分层设计，也是便于高层业务模块依赖低层模块。在一般的应用软件中，策略层会依赖方法层，业务逻辑层会依赖数据存储层。</p><p><img src="/2020/02/23/denpendence-inversion-principle/dip_1.png" width="70%" height="70%"><br>图1</p><p>这是我们正常的软件设计。</p><p>但是这样的设计会带来一些问题。</p><p>策略层对方程层和工具层是传递依赖的，如果下面两层的改动，都会对策略层产生影响，这样导致的级联改动非常不利用软件的维护。</p><p>出现了上述问题，可能会想到定义策略层和工具层的接口，毕竟接口比实现更问题。</p><p>所以，会变成下面的设计关系。</p><p><img src="/2020/02/23/denpendence-inversion-principle/dip_2.png" width="70%" height="70%"><br>图2</p><p>Policy layer 层依赖的是方法层的 MechanismService 接口，而方法层会依赖工具层的 UtilityService 接口。这是通常的编程习惯，底层模块有自己的接口，高层模块依赖低层模块提供的接口。</p><p>但是我们下面不是用这种方式，而是用依赖倒置设计原则去重构。</p><p>###依赖倒置的设计原则</p><p>按照依赖倒置原则，接口的所有权是被倒置的，也就是说，接口被定义在高层模块，高层模块拥有接口，低层模块实现接口。不是高层模块依赖低层模块的接口，而是低层模块依赖高层模块的接口，从而实现依赖关系的倒置。</p><p><img src="/2020/02/23/denpendence-inversion-principle/dip_3.png" width="70%" height="70%"><br>图3</p><p>在上面的依赖层次中，每一层的接口都被高层模块定义，由低层模块实现，高层模块完全不依赖底层模块。这样低层模块的改动不会影响高层模块，高层模块的复用也不会完全依赖低层模块。</p><h3 id="使用依赖倒置实现高层模块复用"><a href="#使用依赖倒置实现高层模块复用" class="headerlink" title="使用依赖倒置实现高层模块复用"></a>使用依赖倒置实现高层模块复用</h3><p>依赖倒置原则也适用于一个类向另一个类发送消息的场景</p><p>Button 控制灯泡，按钮按下的时候，灯泡点亮或关闭。常规的设计是，Button 类直接依赖 Lamp 灯泡类</p><p><img src="/2020/02/23/denpendence-inversion-principle/dip_4.png" width="70%" height="70%"><br>图4</p><p>这样会导致问题，Button 依赖 Lamp, Lamp 的任何改动都会牵扯到 Button, 变成联级的改动。另外，如果想要 Button 控制另外一种电器，Button 变难以重用， 以为 Button 依赖着 Lamp.</p><p>解决办法是将依赖中的具体实现，改成为依赖抽象。</p><p>重构后的设计</p><p><img src="/2020/02/23/denpendence-inversion-principle/dip_5.png" width="70%" height="70%"><br>图5</p><p>抽象接口 ButtonServer 是属于高层模块 Button 的，不属于低层模块 Lamp。这样就形成了依赖倒置。</p><p>Button 不会再依赖 Lamp，而是依赖抽象的 ButtonServer, 而 Lamp 是<br>ButtonServer 的具体实现，这样 Lamp 的改动基本上就不会牵扯 Button。另外，如果想要重用 Button 控制其他设备, 只需要这些设备实现 ButtonServer 接口即可。</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>在创建对象是，一般都会是具体实现，这样就会形成一个依赖。这时，可以选择用抽象工厂模式来解决代码依赖的问题。</p><p><img src="/2020/02/23/denpendence-inversion-principle/dip_6.png" width="70%" height="70%"><br>图6</p><p>Application 通过调用 ServiceFactory接口的 makeService 方法。这个方法由 ServiceFactoryImpl 类具体提供，该方法初始化一个 ConcreteImpl 类的实例，并且将其返回 Service 类型返回。</p><p>图6中间的虚线代表着软件架构中的抽象层与具体实现层的边界。所有跨越这条边界源码级别的依赖关系都应该是单向的，即具体实现层依赖抽象层。</p><p>抽象接口层包含了应用的所有高阶业务规则，具体实现层则包括了这些业务规则需要做的具体操作及其相关的细节信息。</p><p>图6中控制流跨越边界（虚线）的方向与源代码依赖关系跨越该边界的反向相反，源代码依赖用于是控制流方向反向，这就是依赖倒置。</p><h3 id="依赖导致原则"><a href="#依赖导致原则" class="headerlink" title="依赖导致原则"></a>依赖导致原则</h3><ul><li>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口</li><li>抽象接口不应该依赖于具体实现，而具体实现则应该依赖于抽象接口</li></ul><p>高层：业务逻辑<br>底层：UI,底层配置（数据库等）</p><p>高层模块不依赖低层模块，而是依赖抽象接口，这个接口是由高层模块定义，低层模块实现</p><p>应用规则：</p><ul><li><ol><li>应用代码多使用抽象接口，尽量避免使用多变的具体实现类</li></ol></li><li><ol start="2"><li>不要继承具体类，除非是抽象类</li></ol></li><li><ol start="3"><li>不要重写 override, 包含具体实现的函数</li></ol></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://book.douban.com/subject/30333919/" target="_blank" rel="noopener">《架构整洁之道》</a>第11章：DIP 依赖反转原则</li><li><a href="https://time.geekbang.org/column/article/179282" target="_blank" rel="noopener">极客时间-李智慧·后端技术面试38讲</a>  12 | 软件设计的依赖倒置原则：如何不依赖代码却可以复用它的功能</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;如何不依赖代码却可以复用它的功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在软件设计中为了建立清晰的软件分层关系，引入了软件分层设计，也是便于高层业务模块依赖低层模块。在一般的应用软件中，策略层会依赖方法层，业务逻辑层会依赖数据存储层。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="软件设计" scheme="https://yxhuangch.github.io/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>怎样选择保险</title>
    <link href="https://yxhuangch.github.io/2019/11/18/dedao-boxian-summary/"/>
    <id>https://yxhuangch.github.io/2019/11/18/dedao-boxian-summary/</id>
    <published>2019-11-18T15:28:45.000Z</published>
    <updated>2019-12-01T15:02:11.771Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习完得到上面的课程《保险》，做了一份总结，对保险有个大概的认知，知道以后怎样去选择对应的保险。</p><p>这里只是做一个简要的总结，如果想要详细了解，可以去得到上订阅课程。</p><h2 id="保险的功能、原则"><a href="#保险的功能、原则" class="headerlink" title="保险的功能、原则"></a>保险的功能、原则</h2><p><strong>明确保险的功能</strong></p><ul><li>对冲风险</li><li>跨时期分配资源</li></ul><p>首先要明确保险的功能，保险最主要的功能是对冲风险和跨时期分配资源，虽然部分的保险也有理财功能，但那不是最主要的功能。</p><p><strong>选择保险的原则</strong></p><ul><li>认真分析自己可能会面临的风险和自己想要达成的生活目标、再决定买什么产品，买多大保额</li><li>先保障后理财，先人身后财产、先大人后小孩，先主力后其他</li></ul><p>选择保险，一定根据自己的实际情况，不要盲目去买保险。如果买了不适合自己的保险，退保单也有相应的损失。<br>另外一点很重要就是先要保主力，不要自己都没有相应的保障，就为小孩买很多的保险。如果自己都出问题了，怎样去保障小孩的生活。</p><p><strong>保险费用控制</strong></p><ul><li>家庭保险费用总预算应该控制在家庭年收入的 10%~20%</li><li>保障型保险保费不超过家庭年收入的 15%</li><li>投资理财型、转移型保险不超过年收入的 20%</li></ul><p>保险费用的控制也是很重要的，如果太多了，就会生活质量产生影响。如果太低了，又不能覆盖相应的风险。</p><p><strong>风险的分类</strong><br>我们日常生活中面临的很多风险，这些风险可以分类为</p><ul><li>生存保障风险，一般包含疾病、身故和财产损失</li><li>支出性风险， 一般包含养老、子女教育和消费支出</li><li>所有权风险，一般包含婚姻、债务、税务和传承</li></ul><p>根据上面的风险分类，我们需要针对性的去搭建属于自己的防守体系，这个体系如下图的金字塔。</p><p><img src="/2019/11/18/dedao-boxian-summary/dedao_baoxian.png" width="70%" height="70%"></p><p>首先需要保证的是生存风险<br>其次是支出性的保障<br>最后才是所有权的保障</p><p>我们配置保险的话，也是按照这个金字塔重底部往上进行规划保障。</p><p><strong>保险的类型</strong><br>根据保险的类型，可以分为</p><ul><li>保障型保险，包含医疗险、重疾险、意外险、寿险、车险和家财险</li><li>理财型保险，包含年金险、分红险、万能险和投资连结险</li><li>转移型保险，一般是终身寿险</li></ul><h2 id="虚拟案例讲述"><a href="#虚拟案例讲述" class="headerlink" title="虚拟案例讲述"></a>虚拟案例讲述</h2><p>上面简要讲述了保险的功能作用、选择保险的原则、保险费用的控制以及我们日常生活面临的风险，并根据这些风险作出相应的保障类型的保险。</p><p>下面我会虚拟一个人，名字叫小强，根据小强个人的生活状态的变化，结合上面的一些原则，讲述他需要保障。</p><p>根据他的成长过程分为毕业期、成家期和中年期，三个时期去配置。</p><h4 id="1-刚毕业时期"><a href="#1-刚毕业时期" class="headerlink" title="1.刚毕业时期"></a>1.刚毕业时期</h4><p>小强刚大学毕业的时候，一个人，收入不太高。根据上面保障金字塔，首先要解决生存保障风险。</p><p>小强这个时候需要配置医疗险、意外险和重疾险。</p><p>工作了虽然有医保，毕竟医保的保障范围是有限的，需要医疗险进行补充，保障医保范围外风险。</p><p>#####医疗险<br>医疗险一般都是先垫付后报销的，也就是说医疗费用先自己出，最后才去找保险公司理赔的。</p><p>如果是看过电影《我不是药神》，里面王传君饰演的吕受益是白血病人，他的医药费用医保当时是不能报销的，但是医疗险就可以。</p><p><img src="/2019/11/18/dedao-boxian-summary/boxian_2.png" width="70%" height="70%"></p><p>选择医疗险的注意事项：</p><ul><li>第一点是保额，医疗险的保额一般选择在 100 万的基本能够覆盖了。</li><li>第二点是看是否有附加伤害医疗责任</li><li>第三点是看是否可以覆盖自费药</li><li>第三点是看保险里面的医院范围</li><li>第四点是看免赔额</li></ul><p>#####意外险</p><p>虽然谁也不想有意外，但是这个风险还是不可忽视。如果是因为平时意外造成的伤残，会对个人和家庭带来巨大的打击。这个时候意外险就可以起一定的作用，赔偿费用，可以减少经济负担。</p><p>意外险一般是一次性赔付的，它矿业保障我们因意外事件造成的伤亡和残疾，承担意外发生后的医疗费用支出和身故赔偿，也可以帮助我们补偿经济损失。</p><p>另外，因意外导致了身故，保险公司可以赔付受益方，如果选择了父母作为受益方，这样也算是对父母负责和尽孝。</p><p>选择意外险注意的事项：</p><ul><li>一般选择综合意外险</li><li>另外是选择包含伤残责任的</li></ul><p>最后一个重疾险。</p><p>#####重疾险<br>配置了医疗险也还是需要配置重疾险，它们有所不同</p><ul><li>保障范围不同<ul><li>医疗险保障是所有疾病</li><li>重疾险保障的是发病率高，而且花费大量治疗费用的重大疾病</li></ul></li><li><p>给付方式不同</p><ul><li>医疗险需要自己先行垫付，后找保险公司报销</li><li>重疾险是给付型支付方式，也就是一次性把钱给付，由自己分配</li></ul></li><li><p>保障时间不同</p><ul><li>医疗险基本上是一年期的</li><li>重疾险一般可以定期，例如保到六七十岁，或者是终身的</li></ul></li></ul><p>选择重疾险的注意事项：</p><ul><li>选择保额，一般设置成 5 年生活必需支出的费用总和，这样可以保证生活质量不下降</li><li>另外是可以选择轻疾、重疾分组赔付。就是说如果到了轻症疾病，可以得到赔付，而不影响后面重疾的赔付。</li></ul><p><img src="/2019/11/18/dedao-boxian-summary/boxian_5.png" width="70%" height="70%"></p><h4 id="2-成家期"><a href="#2-成家期" class="headerlink" title="2.成家期"></a>2.成家期</h4><p>话说小强毕业六七年后结婚、买房、买车和有了小孩，这个时候他应该配置什么的保险，去降低生活的风险呢。</p><p>成家后，已经不像刚毕业那样，一人吃饱全家不饿了。之前已经配置了基本的生存保障的保险，这个时期需要保障金字塔的第二级，也就是支出性风险。</p><p>成家则意味这责任，如果小强出现了什么意外，那这个责任也还在的。所以这个时候就需要配置寿险了。在小强不幸身故之后，家人可以得到一笔赔偿，这个赔偿可以保证家人的经济水平不会因为失去支柱而陷入困境。</p><h5 id="寿险"><a href="#寿险" class="headerlink" title="寿险"></a>寿险</h5><p>寿险就是为了保障被保险人身故之后，还能履行对家庭的责任。</p><p>选择寿险的注意事项：</p><ul><li>保额，考虑家里的贷款负债、基本的生活成本、子女教育、赡养父母等支出考虑进去，根据需要承担的责任这是保额</li><li>保障的时间，寿险也是分定期寿险和终身寿险，对已一般的家庭来讲选择定期寿险，保到60~70岁的即可，性价比是比价高的</li></ul><p>在选择投保重疾险和寿险时可以在保单里增加豁免条款。也就是小强给妻子投保，妻子给小强投保。例如小强出现意外死亡，由于投保人已经身故，没人交保费，但是有豁免条款，小强帮妻子买的保单不用继续交保费，而保单会继续生效。</p><p>配置了意外险、医疗险、重疾险和寿险，有了这几个工具，那生存保障风险也就应付的差不多了。这个时候需要考虑一些家财险了。</p><p>小强买了房子，这个房子在小强家庭总资产的比重是比较高的。如果房子出现火灾，那面临的损失也是比较大的，很容易陷入家庭困境。这个时候就需要家财险来规避风险了。</p><h5 id="家财险"><a href="#家财险" class="headerlink" title="家财险"></a>家财险</h5><p>家财险是一个产品组合，里面可以自己选择配置。<br>家财险一般包含 4 类功能：</p><ul><li>保房屋，是指在发生火灾、地震、爆炸等情况导致的房屋损失，保险公司进行赔偿。</li><li>保室内，是指因为出现水管爆裂、墙皮脱落需要进行重新装修，这个费用保险公司也可以赔。</li><li>保物品，是指因为家里值钱的东西被盗，保险公司进行相应的赔偿。</li><li>保责任，是指由于自己的责任造成别人的损失，需要赔偿的。例如因为自己家的水管爆了，淹到楼下邻居，这个损失保险公司也是可以进行赔偿的。另外一个例子就是最近报道比较频繁的是高空抛物事故，如果因为找不到相应责任人需要全体高层住户一起赔偿的，这个时候保险公司也可以进行赔偿。</li></ul><h5 id="车险"><a href="#车险" class="headerlink" title="车险"></a>车险</h5><p>如果是买了车子，也需要进行相应的保险的，可以根据下面的表格进行相应的配置</p><p><img src="/2019/11/18/dedao-boxian-summary/boxian_4.png" width="70%" height="70%"></p><p><img src="/2019/11/18/dedao-boxian-summary/boxian_6.png" width="70%" height="70%"></p><h4 id="3-中年期"><a href="#3-中年期" class="headerlink" title="3.中年期"></a>3.中年期</h4><p>又过了十年，这时候的小强已经步入中年了，这个时候需要进行怎样的保险配置呢。</p><p>还记得保险的两个功能，一个是对冲风险，另一个是跨时期分配资源。小强在毕业前和成家期配置的保险都是利用了保险的第一个功能，对冲风险。那后面就需要用到另一个功能，也就是跨时期分配资源。</p><p>跨时间分配资源，符合这个作用的，一般都被成为”理财型保险产品“，这个理财不是用来发财的，不能和股票、基金这样的投资产品混为一谈。</p><p>选择购买理财型保险的注意事项：</p><ul><li>保险不是用来发财的，它更多是跨期分配资源</li><li>关注期末收益没有意义，要看兑换时收益。</li><li>买理财型保险的投入比例不宜太高，一般占可投资盈余的 25%~40%。</li></ul><p>小强这个时候需要考虑小孩教育、个人的养老等问题。</p><p><img src="/2019/11/18/dedao-boxian-summary/boxian_8.png" width="70%" height="70%"></p><h2 id="购买保险注意事项"><a href="#购买保险注意事项" class="headerlink" title="购买保险注意事项"></a>购买保险注意事项</h2><p> 购买保险，一般要注意核保、理赔和服务三方面事项</p><h4 id="核保"><a href="#核保" class="headerlink" title="核保"></a>核保</h4><p>购买保险的时候，保险公司需要进行核保，也就是核实被保险人的情况，防止出现骗保的情况。</p><p>在核保时遵循<em>”真话不全说、假话全不说“</em>，也就是<strong>保险公司明确问到你的，一定要如实回答，但没有问到你的，或者问题不明确的，不需要主动告知</strong></p><p>另外一个核保或者理赔的时候，保险公司一般会通过医保卡的使用记录，医保的就诊记录；第二个是医疗机构体检、就诊记录；第三个是同业理赔记录。<br>所以，<strong>医保卡不能外借</strong>，如果用自己的医保卡给家里的老人买了治高血压、糖尿病的药，会对核保或者理赔产生不良影响。</p><h4 id="理赔"><a href="#理赔" class="headerlink" title="理赔"></a>理赔</h4><p>理赔需要的注意点：</p><ul><li>保存好所有的单据</li><li>在理赔过程中，和保险顾问及时沟通</li></ul><p>在理赔过程总出现纠纷，一般先争取通融赔付，和保险公司协商。如果实在不行，就向银保监会投诉。最后还是不能解决，那可以寻求法律诉讼。</p><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p>购买保险一般还有有一些附加服务的<br>例如一些挂号预约，绿色通道等。</p><p>如果想要更清晰去了解保险的内容，推荐去得到定义《给忙碌着的个人保险课》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近学习完得到上面的课程《保险》，做了一份总结，对保险有个大概的认知，知道以后怎样去选择对应的保险。&lt;/p&gt;
&lt;p&gt;这里只是做一个简要的总结，如果想要详细了解，可以去得到上订阅课程。&lt;/p&gt;
&lt;h2 id=&quot;保险的功能、原则&quot;&gt;&lt;a href=&quot;#保险的功能、原则&quot; cla
      
    
    </summary>
    
    
      <category term="life" scheme="https://yxhuangch.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>设计模式总结</title>
    <link href="https://yxhuangch.github.io/2019/10/02/pattarns-summary/"/>
    <id>https://yxhuangch.github.io/2019/10/02/pattarns-summary/</id>
    <published>2019-10-02T02:56:53.000Z</published>
    <updated>2019-10-02T02:58:18.324Z</updated>
    
    <content type="html"><![CDATA[<p># </p><p>以前学设计模式的时候，学地云里雾里的。最近把书本《设计模式-可复用面向对象软件的基础》重新学了一遍，收获良多，对设计模式有了更深的理解。</p><p><strong>设计模式是软件工程中一种通用的，可复用的一种解决方案，它是一种解决问题的通用模板。</strong></p><p>根据《设计模式》这本书的分类，设计模式分为三种</p><ul><li><p>创建型</p><blockquote><p>它是与对象的创建有关，包含 Abstract Factory, Builder, Factory Method, Prototype, Singleton </p></blockquote></li><li><p>结构型</p><blockquote><p>处理类和对象的组合，包含 Apdater, Bridge, Composite, Decorator, Facade,<br>Flyweight, Proxy</p></blockquote></li><li><p>行为型</p><blockquote><p>对类或对象怎样交互和怎样分配职责进行描述， 包含 Chain of Responsibility, Command, Interpreter, Iterpreter, Iterator, Meadiator, Memento, Observer, State, Strategy, Templete method, Visitor</p></blockquote></li></ul><p>每种模式都对应着它的使用场景。</p><p>在熟知了设计模式之后，切不可为了模式而模式，对模式的滥用，陷入模式痴迷。模式痴迷是指对模式过于痴迷以至于无法不在代码中使用模式。要记得，我们使用设计模式是为了让代码更加简单。</p><p>当我们把设计模式的类图都过一遍，发现几乎所有的类图都是分成稳定部分和改变部分。稳定部分是用接口、抽象类或者父类来表示，改变部分则是由接口实现类或者子类表示。</p><p><img src="/2019/10/02/pattarns-summary/imge/pattens_1.png" width="70%" height="70%"></p><blockquote><p>例如上图是 State 模式的类图，稳定部分是 Context 和 state;改变部分是 ConcreteState</p></blockquote><h3 id="设计模式的目标"><a href="#设计模式的目标" class="headerlink" title="设计模式的目标"></a>设计模式的目标</h3><p>设计模式的目标就是管理变化，提高复用</p><h3 id="设计模式的核心"><a href="#设计模式的核心" class="headerlink" title="设计模式的核心"></a>设计模式的核心</h3><p><strong>设计模式的核心是封装变化</strong></p><h3 id="设计模式的原则"><a href="#设计模式的原则" class="headerlink" title="设计模式的原则"></a>设计模式的原则</h3><h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><ul><li>高层模块（稳定）不应该依赖于低层次模块（变化）， 二者都应该依赖于抽象（稳定）</li><li>抽象（稳定）不应该依赖于实现细节（变化），实现细节应依赖于抽象（稳定）</li></ul><h4 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h4><ul><li>对扩展开放，对更改封闭</li><li>类模块应该是可扩展的，但是不可修改</li></ul><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><ul><li>一个类应该仅有一个引起它变化的原因</li><li>变化的方向隐含着类的责任</li></ul><h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><ul><li>子类必须能够替换它们的基类</li><li>继承表达类型抽象</li></ul><h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><ul><li>不应该强迫客户程序依赖它们不用的方法</li><li>接口应该小而完备</li></ul><h4 id="有限使用对象组合，而不是类继承"><a href="#有限使用对象组合，而不是类继承" class="headerlink" title="有限使用对象组合，而不是类继承"></a>有限使用对象组合，而不是类继承</h4><ul><li>类继承通常为”白箱复用“， 对象组合通常为 ”黑箱复用“</li><li>继承在某种程度上破坏了封装性，子类父类耦合度高</li><li>对象组合只要求组合的对象具有良好定义的接口，耦合度低</li></ul><h4 id="封装变化点"><a href="#封装变化点" class="headerlink" title="封装变化点"></a>封装变化点</h4><p>使用封装来创建对象的分界线。设计者可以在分界层的一侧修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合</p><h4 id="针对接口编程，而不是针对实现编程"><a href="#针对接口编程，而不是针对实现编程" class="headerlink" title="针对接口编程，而不是针对实现编程"></a>针对接口编程，而不是针对实现编程</h4><ul><li>不将变量类型声明为某个特定的具体类，而是声明为某个对象接口</li><li>客户程序无需获知对象的具体类型，只需知道对象具有的接口</li><li>减少系统中各个部分的依赖关系，从而实现”高内聚、低耦合“的类型设计方案</li></ul><p><br><br>以上只是一般性的总结，那具体对应怎样使用设计模式呢</p><h2 id="如何使用设计模式"><a href="#如何使用设计模式" class="headerlink" title="如何使用设计模式"></a>如何使用设计模式</h2><p>除非是一些比较明显的地方，一般不使用采取大规模的预先设计，而是通过演进在重构过程中趋向模式的方式。<br>在重构的过程中对应下面的情况，可以选择相应的模式</p><h3 id="选择相应的设计模式"><a href="#选择相应的设计模式" class="headerlink" title="选择相应的设计模式"></a>选择相应的设计模式</h3><p>在代码中出现的问题，选择相应的设计模式进行重构</p><h4 id="1-通过显式地指定一个类来创建对象"><a href="#1-通过显式地指定一个类来创建对象" class="headerlink" title="1.通过显式地指定一个类来创建对象"></a>1.通过显式地指定一个类来创建对象</h4><h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><p>通过显式地指定一个类来创建对象</p><h5 id="模式："><a href="#模式：" class="headerlink" title="模式："></a>模式：</h5><p>Abstract Factory, Factory Method, Prototype</p><h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><p>在创建对象时指定类名将使你受特定实现的约束而不是特定接口的约束。这会使未来的变化更复杂。要避免这种情况，应该间接地创建对象。</p><h4 id="2-对特殊操作的依赖"><a href="#2-对特殊操作的依赖" class="headerlink" title="2.对特殊操作的依赖"></a>2.对特殊操作的依赖</h4><h5 id="问题：-1"><a href="#问题：-1" class="headerlink" title="问题："></a>问题：</h5><p>对特殊操作的依赖</p><h5 id="模式：-1"><a href="#模式：-1" class="headerlink" title="模式："></a>模式：</h5><p>Chain of Resposibility, Command</p><h5 id="说明：-1"><a href="#说明：-1" class="headerlink" title="说明："></a>说明：</h5><p>当为请求指定一个特殊的操作时，完成该请求的方式就固定下来了。为避免把代码写死，可以在编译时刻或运行时刻很方便地改变响应请求的方法</p><h4 id="3-对硬件和软件平台的依赖"><a href="#3-对硬件和软件平台的依赖" class="headerlink" title="3.对硬件和软件平台的依赖"></a>3.对硬件和软件平台的依赖</h4><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>对硬件和软件平台的依赖</p><h5 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h5><p>Abstract Factory, Bridge</p><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p>外部的操作系统接口和应用编程接口（API）在不同的软硬件平台是不同的。依赖特定平台的软件将很难移植到其他平台上，甚至很难跟上本地平台的更新。所以设计系统时限制其平台相关性就很重要了。</p><h4 id="4-对对象表示或实现的依赖"><a href="#4-对对象表示或实现的依赖" class="headerlink" title="4.对对象表示或实现的依赖"></a>4.对对象表示或实现的依赖</h4><h5 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h5><p>对对象表示或实现的依赖</p><h5 id="模式-1"><a href="#模式-1" class="headerlink" title="模式"></a>模式</h5><p>Abstract Factory, Bridge, Memonto, Proxy</p><h5 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h5><p>知道对象怎样表示、保存、定位或实现的客户在对象发生变化时可能也需要变化。对客户隐藏这些信息能阻止连锁变化</p><h4 id="5-算法依赖"><a href="#5-算法依赖" class="headerlink" title="5.算法依赖"></a>5.算法依赖</h4><h5 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h5><p>算法依赖</p><h5 id="模式-2"><a href="#模式-2" class="headerlink" title="模式"></a>模式</h5><p>Builder, Iterator, Strategy, Template Method, Visitor</p><h5 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h5><p>算法在开发和复用时常常被扩展、优化和替代。依赖于某个特定算法的对象在算法发生变化时不得不变化。因此有可能发生变化的算法应该被孤立起来。</p><h4 id="6-紧耦合"><a href="#6-紧耦合" class="headerlink" title="6.紧耦合"></a>6.紧耦合</h4><h5 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h5><p>紧耦合</p><h4 id="模式-3"><a href="#模式-3" class="headerlink" title="模式"></a>模式</h4><p>Abstract Factory, Commmand, Facade, Mediator, Observer, Chain of Responsibility</p><h5 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h5><p>紧耦合的类很难独立地被复用，因为它们是相互依赖的。紧耦合产生单块的系统，要改变或删掉一个类，你必须理解和改变其他许多类。这样的系统是一个很难学习、移植和维护的密集体。<br>松散耦合提高了一个类本身被复用的可能性，并且系统更易于学习、移植、修改和扩展。设计模式使用抽象耦合和分层技术来提供系统的松散耦合醒。</p><h4 id="7-通过子类来扩充功能"><a href="#7-通过子类来扩充功能" class="headerlink" title="7. 通过子类来扩充功能"></a>7. 通过子类来扩充功能</h4><h5 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h5><p>通过子类扩充功能</p><h5 id="模式-4"><a href="#模式-4" class="headerlink" title="模式"></a>模式</h5><p>Bridge, Chain of Responsibility, Composite, Decorator, Observer, Strategy</p><h5 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h5><p>通常很难通过子类来定制对象。每一个新类都有固定的实现开销。定义子类还需要对父类有深入的了解。一个被重定义的操作可能需要调用继承下来的操作。并且子类方法会导致类爆炸，因为即使对一个简单的扩充。不等不引入许多子类。<br>一般的对象组合技术和具体的委托技术，是继承之外组合对象行为的另一种灵活方式。新的功能可以通过新的方式组合已有对象，而不是通过定义已存在类的子类的方式加到应用中去。</p><h4 id="8-不能方便地对类进行修改"><a href="#8-不能方便地对类进行修改" class="headerlink" title="8.不能方便地对类进行修改"></a>8.不能方便地对类进行修改</h4><h5 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h5><p>不能方便地对类进行修改</p><h5 id="模式-5"><a href="#模式-5" class="headerlink" title="模式"></a>模式</h5><p>Adapter, Decorator, Visitor</p><h5 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h5><p>有时不地不改变一个难以修改的类，需要源代码而又没有（第三方库），或者可能对类的任何改变会要求修改许多已存在的其他子类。</p><h3 id="怎样使用设计模式"><a href="#怎样使用设计模式" class="headerlink" title="怎样使用设计模式"></a>怎样使用设计模式</h3><p>过程</p><h4 id="1-大致浏览一遍模式"><a href="#1-大致浏览一遍模式" class="headerlink" title="1.大致浏览一遍模式"></a>1.大致浏览一遍模式</h4><p>特别注意其适用性部分和效果部分，确定它适合你的问题</p><h4 id="2-回头研究结构部分、参与者部分和协作部分"><a href="#2-回头研究结构部分、参与者部分和协作部分" class="headerlink" title="2.回头研究结构部分、参与者部分和协作部分"></a>2.回头研究结构部分、参与者部分和协作部分</h4><p>确保你理解这个模式的类和对象以及它们是怎样关联的</p><h4 id="3-看代码示例部分，看看这个模式代码形式的具体例子"><a href="#3-看代码示例部分，看看这个模式代码形式的具体例子" class="headerlink" title="3.看代码示例部分，看看这个模式代码形式的具体例子"></a>3.看代码示例部分，看看这个模式代码形式的具体例子</h4><p>研究代码将有助于你实现模式</p><h4 id="4-选择模式参与者名字，使它们在应用上下文中有意义"><a href="#4-选择模式参与者名字，使它们在应用上下文中有意义" class="headerlink" title="4.选择模式参与者名字，使它们在应用上下文中有意义"></a>4.选择模式参与者名字，使它们在应用上下文中有意义</h4><p>设计模式参与者的名字通常过于抽象而不会直接出现在应用中.然而，将参与者的名字和应用中出现的名字合并起来是很有用的。这会帮助你在实现中更显示的体验出模式来。<br>例如使用了 State 模式</p><blockquote><p>BaseDialogState</p></blockquote><h4 id="5-定义类"><a href="#5-定义类" class="headerlink" title="5.定义类"></a>5.定义类</h4><p>生命它们的接口，建立它们的继承关系，定义代表数据和对象引用的实例变量。识别模式会影响到你应用中存在的类，做出相应的修改</p><h4 id="6-定义模式中专用于应用的操作名称"><a href="#6-定义模式中专用于应用的操作名称" class="headerlink" title="6.定义模式中专用于应用的操作名称"></a>6.定义模式中专用于应用的操作名称</h4><p>名字一般依赖于应用。使用与每一个操作相关联的责任和协作作为指导</p><h4 id="7-实现执行模式中责任和协作的操作"><a href="#7-实现执行模式中责任和协作的操作" class="headerlink" title="7.实现执行模式中责任和协作的操作"></a>7.实现执行模式中责任和协作的操作</h4><p>实现部分提供线索指导你进行实现。代码示例部分的例子也能提供帮助。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>《设计模式》是一本很经典的书，每隔一两年可以拿出来再读一遍，也总会有巨大的收获</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《设计模式-可复用面向对象软件的基础》，GoF</li><li>《设计模式之禅》, 秦少波</li><li>《重构与模式（Refactoring to Patterns）》, Joshua Kerievsky</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;# &lt;/p&gt;
&lt;p&gt;以前学设计模式的时候，学地云里雾里的。最近把书本《设计模式-可复用面向对象软件的基础》重新学了一遍，收获良多，对设计模式有了更深的理解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计模式是软件工程中一种通用的，可复用的一种解决方案，它是一种解决问题的通用模板。&lt;/
      
    
    </summary>
    
    
      <category term="design patterns" scheme="https://yxhuangch.github.io/tags/design-patterns/"/>
    
  </entry>
  
  <entry>
    <title>State 状态模式在 Android 多弹窗的应用</title>
    <link href="https://yxhuangch.github.io/2019/08/24/state-pattern-in-android/"/>
    <id>https://yxhuangch.github.io/2019/08/24/state-pattern-in-android/</id>
    <published>2019-08-24T02:03:43.000Z</published>
    <updated>2019-08-25T06:49:35.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>最近项目的首页弹窗进行调整，要加几个弹窗，而且还是要按顺序弹出的。原来的只有悬浮窗权限弹窗和存储权限弹窗，用一两个标志位就可以解决了。现在加了隐私协议弹窗和青少年模式弹窗，变成了四个弹窗，如果还是按照原来的方法，即加标志位解决，逻辑机会变得非常复杂，也很容易出 Bug.</p><p>经过调研，发现可以用 state 转态模式去解决这个问题。</p><p>下面我们先看看 state 转态模式</p><h2 id="State-状态态模式"><a href="#State-状态态模式" class="headerlink" title="State 状态态模式"></a>State 状态态模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p><strong>State</strong> is a behavioral design pattern that lets an object alter its behavior when its internal state changes. It appears as if the object changed its class.<br>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类</p><p>State 模式与状态机有着类似的地方，都是从一个状态切换到另一个状态<br><img src="/2019/08/24/state-pattern-in-android/state_2.png" width="50%" height="50%"></p><p>State 模式的类图</p><p><img src="/2019/08/24/state-pattern-in-android/state_1.png" width="80%" height="70%"><br>图片来源 <a href="https://refactoring.guru/design-patterns/state" target="_blank" rel="noopener">design-patterns: State</a></p><h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><h4 id="Context-上下文"><a href="#Context-上下文" class="headerlink" title="Context 上下文"></a>Context 上下文</h4><ul><li>定义 Client 感兴趣的接口 </li><li>维护一个 ConcreteState 子类的实例，这个实例是当前的 state</li></ul><h4 id="State-状态"><a href="#State-状态" class="headerlink" title="State 状态"></a>State 状态</h4><p> 定义接口以封装与 Context 的一个特定状态相关的行为. </p><h4 id="ConcreteState-具体状态类"><a href="#ConcreteState-具体状态类" class="headerlink" title="ConcreteState 具体状态类"></a>ConcreteState 具体状态类</h4><p>每一个子类实现一个与 Context 的一个状态相关的行为</p><h3 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h3><ol><li><p>Context 将状态相关的请求委托给当前的 ConcreteState 对象处理</p></li><li><p>Context 可以将自身作为一个参数传递给 state, 让 state 可以访问到 Context</p></li><li><p>Context 是 client 使用的主要接口， 一般情况下 client 不需要直接与 state 打交道</p></li><li><p>Context 或 ConcreteState 子类都可以决定 next state, 以及设置转态转换的条件</p></li></ol><h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><ol><li><p>一个对象的行为取决于它的状态，并且必须在运行时刻根据状态改变它的行为</p></li><li><p>一个操作中含有庞大的分支条件，并且这些分支依赖该对象的状态</p></li></ol><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><ol><li><p>确定 Context 上下文</p></li><li><p>确定 state 的接口</p></li><li><p>继承 state 接口，实现具体 state 类</p></li><li><p>在 Context 中，用一个成员变量指向当前的状态，并且提供对外方法可以设置这个值</p></li></ol><ol start="5"><li>初始化一个开始的 State 并传进 context。</li></ol><h2 id="State-模式在-Android-中的应用"><a href="#State-模式在-Android-中的应用" class="headerlink" title="State 模式在 Android 中的应用"></a>State 模式在 Android 中的应用</h2><p>回到我们文章开头的问题，我们想要把弹窗顺序的弹出，刚好和 state 模式中的状态切换是一致的。 第一个弹窗弹窗后，切换到另一个状态，下个弹窗是否弹出，完全取决于所在的状态。这样就可以减少一堆的标志位判断了。</p><p>这样说比较抽象，可以结合下面的例子来看;</p><h3 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h3><p>在第一个弹窗之后，点击确认或者取消；<br>弹窗第二个弹窗，点击第二个弹窗的确认或者取消，弹窗第三个弹窗；<br>点击第三个弹窗，结束；</p><h3 id="StateDialog-的设计"><a href="#StateDialog-的设计" class="headerlink" title="StateDialog 的设计"></a>StateDialog 的设计</h3><p>下面是类图</p><p><img src="/2019/08/24/state-pattern-in-android/state_4.png" width="70%" height="70%"></p><p><strong>DialogContext</strong> 是上下文，用来存储当前 DialogState，在 nextDialogState 方法设置下个状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DialogContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BaseDialogState mCurrentDialogState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Activity mActivity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DialogContext</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        mActivity = activity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextDialogState</span><span class="params">(BaseDialogState baseDialogState)</span> </span>&#123;</span><br><span class="line">        mCurrentDialogState = baseDialogState;</span><br><span class="line">        mCurrentDialogState.setDialogContext(<span class="keyword">this</span>); <span class="comment">//　将自身作为参数传递给　DialogState</span></span><br><span class="line">        mCurrentDialogState.handle(); <span class="comment">// 同时调用 DialogState#handle 方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Activity <span class="title">getActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mActivity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCurrentDialogState != <span class="keyword">null</span>)&#123;</span><br><span class="line">            mCurrentDialogState.onResume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BaseDialogState</strong> 是做弹窗的基类，提供 nextDialogState 和  handle 方法<br>在 handle 方法里面进行自身逻辑的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDialogState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"DialogState"</span>;</span><br><span class="line">    <span class="keyword">protected</span> DialogContext mDialogContext;</span><br><span class="line">    <span class="keyword">protected</span> Activity mActivity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDialogContext</span><span class="params">(DialogContext dialogContext)</span> </span>&#123;</span><br><span class="line">        mDialogContext = dialogContext;</span><br><span class="line">        mActivity = dialogContext.getActivity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行自身逻辑处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置下一个 state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">nextDialogState</span><span class="params">()</span></span>; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>IDialogStateManager</strong> 和它的实现类 <strong>DialogStateManager</strong> 是 Activity 连接 DialogContext 的中介，相当于 Client。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDialogStateManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Activity activity)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DialogStateManager.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DialogStateManager</span> <span class="keyword">implements</span> <span class="title">IDialogStateManager</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DialogContext mDialogContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsStarted; <span class="comment">// 首次启动</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        mDialogContext = <span class="keyword">new</span> DialogContext(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mDialogContext != <span class="keyword">null</span> &amp;&amp; !mIsStarted)&#123;</span><br><span class="line">            mIsStarted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 设置第一个 state</span></span><br><span class="line">            mDialogContext.nextDialogState(<span class="keyword">new</span> DialogOneState());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mDialogContext.onResume();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h3><p>在 MainActivity 调用 DialogStateManager，进行管理</p><p>调用的时序图<br><img src="/2019/08/24/state-pattern-in-android/state_3.png" width="70%" height="70%"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> TextView mTvStartDialog;</span><br><span class="line">    <span class="keyword">private</span> IDialogStateManager mDialogStateManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mTvStartDialog = (TextView) findViewById(R.id.tv_start);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建 DialogStateManager 并进行初始化</span></span><br><span class="line">        mDialogStateManager = <span class="keyword">new</span> DialogStateManager();</span><br><span class="line">        mDialogStateManager.init(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        mTvStartDialog.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                mDialogStateManager.start(); <span class="comment">// 启动状态</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        mDialogStateManager.onResume();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们看调用的效果</p><p><img src="/2019/08/24/state-pattern-in-android/state_dialog_demo.gif" width="70%" height="70%"></p><p>完整的代码已上传到 <a href="https://github.com/yxhuangCH/AndroidDemo/tree/master/StateDialogDemo" target="_blank" rel="noopener">github</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《设计模式 可复用面向对象软件的基础》第 5 章， 5.8 State （转态）</li><li><a href="https://refactoring.guru/design-patterns/state" target="_blank" rel="noopener">design-patterns: State</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;最近项目的首页弹窗进行调整，要加几个弹窗，而且还是要按顺序弹出的。原来的只有悬浮窗权限弹窗和存储权限弹窗，用一两个标志位就可以解决了。现在加
      
    
    </summary>
    
    
      <category term="android" scheme="https://yxhuangch.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android 使用 Aspectj 限制快速点击</title>
    <link href="https://yxhuangch.github.io/2019/07/07/android-aspectj-limit-click/"/>
    <id>https://yxhuangch.github.io/2019/07/07/android-aspectj-limit-click/</id>
    <published>2019-07-07T09:40:11.000Z</published>
    <updated>2019-07-07T09:43:53.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-使用-Aspectj-限制快速点击"><a href="#Android-使用-Aspectj-限制快速点击" class="headerlink" title="Android 使用 Aspectj 限制快速点击"></a>Android 使用 Aspectj 限制快速点击</h1><p>在<a href="https://github.com/yxhuangCH/CSLearn/blob/master/android/Aspectj%20%E5%9C%A8Android%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8.md" target="_blank" rel="noopener">AspectJ 在 Android 中的使用</a>中，介绍了 Aspectj 的基本知识及其在 Android 中的基本使用，在这篇将会介绍如何使用 Aspectj 在 Android 中限制快速点击</p><h3 id="1-配置依赖"><a href="#1-配置依赖" class="headerlink" title="1. 配置依赖"></a>1. 配置依赖</h3><p>建立 clicklimt 的 lib，添加对 Aspect 的依赖，之前我们要做很多的配置工作，沪江的开源库 <a href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx" target="_blank" rel="noopener">gradle_plugin_android_aspectjx</a> 已经帮我们弄了，省了很多工作。</p><p>在根项目的 build.gradle 配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:3.3.2&apos;</span><br><span class="line">        </span><br><span class="line">        // 添加 hujiang.aspectjx</span><br><span class="line">        classpath &apos;com.hujiang.aspectjx:gradle-android-plugin-aspectjx:2.0.4&apos;</span><br><span class="line"></span><br><span class="line">        classpath &apos;com.jakewharton:butterknife-gradle-plugin:9.0.0-rc2&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 app 工程的 build.gradle 中使用 AspectJX 插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.android.application&apos;</span><br><span class="line">apply plugin: &apos;android-aspectjx&apos;  // 使用 AspectJX 插件</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion 28</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId &quot;com.yxhuang.aspectjlimitclickdemo&quot;</span><br><span class="line">        minSdkVersion 21</span><br><span class="line">        targetSdkVersion 28</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0&quot;</span><br><span class="line">        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android-optimize.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Butterknife requires Java 8.</span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aspectjx &#123;</span><br><span class="line">    //指定只对含有关键字&apos;universal-image-loader&apos;, &apos;AspectJX-Demo/library&apos;的库进行织入扫描，忽略其他库，提升编译效率</span><br><span class="line">//    includeJarFilter &apos;universal-image-loader&apos;, &apos;AspectJX-Demo/library&apos;</span><br><span class="line">//    excludeJarFilter &apos;.jar&apos;</span><br><span class="line">//    ajcArgs &apos;-Xlint:warning&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</span><br><span class="line">    implementation &apos;com.android.support:appcompat-v7:28.0.0&apos;</span><br><span class="line">    implementation &apos;com.android.support.constraint:constraint-layout:1.1.3&apos;</span><br><span class="line">    testImplementation &apos;junit:junit:4.12&apos;</span><br><span class="line">    androidTestImplementation &apos;com.android.support.test:runner:1.0.2&apos;</span><br><span class="line">    androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.2&apos;</span><br><span class="line"></span><br><span class="line">    implementation project(&apos;:clicklimit&apos;)</span><br><span class="line"></span><br><span class="line">    implementation &apos;com.jakewharton:butterknife:9.0.0-rc1&apos;</span><br><span class="line">    annotationProcessor &apos;com.jakewharton:butterknife-compiler:9.0.0-rc1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 clicklimt 库的 build.gradle 中添加 aspectj 依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</span><br><span class="line"></span><br><span class="line">    api &apos;org.aspectj:aspectjrt:1.8.9&apos;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-具体的处理"><a href="#2-具体的处理" class="headerlink" title="2. 具体的处理"></a>2. 具体的处理</h3><h4 id="1-建立-ClickLimit-注解"><a href="#1-建立-ClickLimit-注解" class="headerlink" title="1. 建立 ClickLimit 注解"></a>1. 建立 ClickLimit 注解</h4><p>我们会对整个项目中的点击事件做点击限制，如果不需要限制的方法，可以设置 value = 0 即可, 我们默认设置为 500 毫秒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ClickLimit &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 500</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-选择-Pointcut"><a href="#2-选择-Pointcut" class="headerlink" title="2. 选择 Pointcut"></a>2. 选择 Pointcut</h4><p> 我们这里选择 View#setOnClickListener 作为切入点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// View#setOnClickListener</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String POINTCUT_ON_VIEW_CLICK =</span><br><span class="line">            <span class="string">"execution(* android.view.View.OnClickListener.onClick(..))"</span>;</span><br></pre></td></tr></table></figure><p>对 Joint 的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processJoinPoint</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"-----method is click--- "</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        <span class="keyword">if</span> (!(signature <span class="keyword">instanceof</span> MethodSignature))&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"method is no MethodSignature, so proceed it"</span>);</span><br><span class="line">            joinPoint.proceed();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) signature;</span><br><span class="line">        Method method = methodSignature.getMethod();</span><br><span class="line">        <span class="keyword">boolean</span> isHasLimitAnnotation = method.isAnnotationPresent(ClickLimit.class);</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        <span class="keyword">int</span> intervalTime = CHECK_FOR_DEFAULT_TIME;</span><br><span class="line">        <span class="comment">// 这里判断是否使用了 ClickLimit 注解</span></span><br><span class="line">        <span class="comment">// 如果用注解，并且修改了限制点击的时间</span></span><br><span class="line">        <span class="comment">// 如果时间 &lt;= 0 ，代表着不做限制，直接执行</span></span><br><span class="line">        <span class="comment">// 如果是其他时间，则更新限制时间</span></span><br><span class="line">        <span class="keyword">if</span> (isHasLimitAnnotation)&#123;</span><br><span class="line">            ClickLimit clickLimit = method.getAnnotation(ClickLimit.class);</span><br><span class="line">            <span class="keyword">int</span> limitTime = clickLimit.value();</span><br><span class="line">            <span class="comment">// not limit click</span></span><br><span class="line">            <span class="keyword">if</span> (limitTime &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"method: "</span> + methodName + <span class="string">" limitTime is zero, so proceed it"</span>);</span><br><span class="line">                joinPoint.proceed();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            intervalTime = limitTime;</span><br><span class="line">            Log.d(TAG, <span class="string">"methodName "</span> +  methodName + <span class="string">" intervalTime is "</span> + intervalTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 传进来的参数不是 View, 则直接执行</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        View view = getViewFromArgs(args);</span><br><span class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"view is null, proceed"</span>);</span><br><span class="line">            joinPoint.proceed();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过 viewTag 存储上次点击的时间</span></span><br><span class="line">        Object viewTimeTag =  view.getTag(R.integer.yxhuang_click_limit_tag_view);</span><br><span class="line">        <span class="comment">// first click viewTimeTag is null.</span></span><br><span class="line">        <span class="keyword">if</span> (viewTimeTag == <span class="keyword">null</span>)&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"lastClickTime is zero , proceed"</span>);</span><br><span class="line">            proceedAnSetTimeTag(joinPoint, view);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> lastClickTime = (<span class="keyword">long</span>) viewTimeTag;</span><br><span class="line">        <span class="keyword">if</span> (lastClickTime &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"lastClickTime is zero , proceed"</span>);</span><br><span class="line">            proceedAnSetTimeTag(joinPoint, view);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// in limit time</span></span><br><span class="line">        <span class="keyword">if</span> (!canClick(lastClickTime, intervalTime))&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"is in limit time , return"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        proceedAnSetTimeTag(joinPoint, view);</span><br><span class="line">        Log.d(TAG, <span class="string">"view proceed."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        Log.d(TAG, e.getMessage());</span><br><span class="line">        joinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">proceedAnSetTimeTag</span><span class="params">(ProceedingJoinPoint joinPoint, View view)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    view.setTag(R.integer.yxhuang_click_limit_tag_view, System.currentTimeMillis());</span><br><span class="line">    joinPoint.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 ViewTag 来存储上次点击的时间，如果上次的点击时间为 0， 说明是第一次点击，则立即执行；<br>如果有存储上次点击时间，则通过 canClick 方法配对时间，如果是在时间间隔之内，不执行。</p><h3 id="3-对-clicklimit-库的使用"><a href="#3-对-clicklimit-库的使用" class="headerlink" title="3. 对 clicklimit 库的使用"></a>3. 对 clicklimit 库的使用</h3><p>在 app module 的 build.gradle 中添加 clicklimit 库的引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation project(&apos;:clicklimit&apos;)</span><br></pre></td></tr></table></figure><p>我们一个使用 View#setOnClickListener 方法，一个使用 ButterKnife 绑定的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindView</span>(R.id.btn_click)</span><br><span class="line">Button mBtnClick;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    ButterKnife.bind(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    TextView tvSay = findViewById(R.id.tv_say);</span><br><span class="line">    tvSay.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@ClickLimit</span>(value = <span class="number">1000</span>)</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            Log.i(TAG, <span class="string">"-----onClick----"</span>);</span><br><span class="line">            showToast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showToast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"被点击"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@OnClick</span>(R.id.btn_click)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewClicked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Log.i(TAG, <span class="string">"-----butterknife method onClick  execution----"</span>);</span><br><span class="line">    showToast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对 tvSay 快速点击两次，看到 log</p><p><img src="/2019/07/07/android-aspectj-limit-click/aspectj_7.png" width="80%" height="70%"></p><p>第一次执行了， 第二在时间限制内，return 掉了</p><p>我们点击一下 butterknife 绑定的 button,看看 log</p><p><img src="/2019/07/07/android-aspectj-limit-click/aspectj_8.png" width="80%" height="70%"></p><p>我们看到 butterknife 绑定的方法也被限制，但是我们的 Poincut 并没有对它做限制。</p><p>在 app/build/intermediates/transforms/ajx/debug 的路径下会生成 jar 包， ajx 这个路径就是使用了 android-aspectjx 生成</p><p><img src="/2019/07/07/android-aspectj-limit-click/aspectj_9.png" width="50%" height="50%"></p><p>我们将 0.jar 文件放到软件 JD-GUI 上面可以看到里面的代码</p><p><img src="/2019/07/07/android-aspectj-limit-click/aspectj_11.png" width="70%" height="60%"></p><p>其实是因为 ButterKnife 会生成一个 ViewBinding 的类，在里面调用了<br>View#setOnClickListener 方法</p><p>很多文章都需要对 butterknife 设置 Pointcut,  其实这完全是没有必要的.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android-使用-Aspectj-限制快速点击&quot;&gt;&lt;a href=&quot;#Android-使用-Aspectj-限制快速点击&quot; class=&quot;headerlink&quot; title=&quot;Android 使用 Aspectj 限制快速点击&quot;&gt;&lt;/a&gt;Android 使用 
      
    
    </summary>
    
    
      <category term="Android" scheme="https://yxhuangch.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>AspectJ在Android中的使用</title>
    <link href="https://yxhuangch.github.io/2019/06/29/AspectJ%E5%9C%A8Android%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://yxhuangch.github.io/2019/06/29/AspectJ在Android中的使用/</id>
    <published>2019-06-29T10:25:01.000Z</published>
    <updated>2019-06-29T10:33:52.809Z</updated>
    
    <content type="html"><![CDATA[<p>#AspectJ 在 Android 中的使用<br>在介绍 AspectJ 之前，我们先看看常见的几种编程架构思想。</p><ul><li>面向对象编程 Object Oriented Programming</li><li>面向过程编程 Procedure Oriented Programming</li><li>面向切面编程 Aspect Oriented Programming</li></ul><p>面向对象、面向过程、面向切面， 这三种是我们常见的三种编程架构思想，在日常的编程中， OOP 是 Android 开发中最常见的，其他的两种比较少见。</p><h3 id="一、AOP"><a href="#一、AOP" class="headerlink" title="一、AOP"></a>一、AOP</h3><p>AOP 是面向切面编程，它在我们的日志系统、权限管理方面有着比较好的应用。<br>在项目中，我们的很多功能都是分散到各个模块，例如日志打印，AOP 的目标就是要把这些功能集中起来，放到一个统一的地方来控制和管理。</p><h3 id="二、AspectJ"><a href="#二、AspectJ" class="headerlink" title="二、AspectJ"></a>二、AspectJ</h3><p>AOP 是一种编程的思想，在具体的编程中需要实际的工具去实现这套思想。 AspectJ 就是这样的一个工具。使用 AspectJ 有两种方式</p><ul><li><ol><li>完全使用 AspectJ 的语言开发；</li></ol></li><li><ol start="2"><li>使用 AspectJ 注解，完全的使用纯 Java 开发</li></ol></li></ul><p>我们后续讲的，基本上都是以 AspectJ 注解的方法，同时在最后也会附上 AspectJ 和 AspectJ 注解的等价。</p><h4 id="1-AspectJ-语法"><a href="#1-AspectJ-语法" class="headerlink" title="1.AspectJ 语法"></a>1.AspectJ 语法</h4><p>这里只是介绍简单的一些概念，如果想要去了解深入的用法，可参考文后的链接，去官网查看。</p><h5 id="1-JoinPoint"><a href="#1-JoinPoint" class="headerlink" title="1. JoinPoint"></a>1. JoinPoint</h5><p>JoinPoint: A particular point in a program that might be the target of code injection.<br>JoinPoint 简单一点说就是程序运行时要执行一些动作的点。</p><p> AspectJ 中可以选择的 JoinPoint</p><table><thead><tr><th>JoinPoint</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>method call</td><td>函数调用</td><td>例如调用 Log.e( )</td></tr><tr><td>method execution</td><td>函数执行</td><td>例如 Log.e( ) 的执行内部。<br> method call 是调用某个函数的地方<br> execution 是某个函数执行的内部</td></tr><tr><td>constructor call</td><td>构造函数调用</td><td>和 method call 类似</td></tr><tr><td>constructor execution</td><td>构造函数执行</td><td>和 method execution 类似</td></tr><tr><td>field get</td><td>获取某个变量</td><td>例如读取 MainActivity.mTest 成员</td></tr><tr><td>field set</td><td>设置某个变量</td><td>例如设置 MainActivity.mTest 成员</td></tr><tr><td>pre-initialization</td><td>Object 在构造函数中做的一些工作</td><td></td></tr><tr><td>initialization</td><td>Object 在构造函数中做的工作</td><td></td></tr><tr><td>static initialization</td><td>类初始化</td><td>例如类的 static{}</td></tr><tr><td>handler</td><td>异常处理</td><td>例如 try catch(xxx) 中，对应 catch 内的执行</td></tr><tr><td>advice execution</td><td>AspectJ 的内容</td></tr></tbody></table><p>JoinPoint 的选择要结合下面的 Pointcuts 表达式来看</p><h5 id="2-Pointcut"><a href="#2-Pointcut" class="headerlink" title="2. Pointcut"></a>2. Pointcut</h5><p>Pointcut: An expression which tell a code injection tool where to inject a particular piece of code<br>Pointcut 简单的说就是从一堆的 JoinPoint 中挑选感兴趣的 JoinPoint 的表达式。</p><p>例如</p><blockquote><pre><code>pointcut anyCall(): call(* *.println(..)) &amp;&amp; !within(TestAspect);</code></pre></blockquote><p>在 AspectJ 的语言中定义一个 Pointcout 需要用关键词 <em>pointcut</em> .<br>上面的这里是</p><ul><li>pointcut: 是定一个 Pointcut 的关键词</li><li>anyCall(): 是 Pointcut 的名称</li><li>call : 表示 JoinPoint 的类型为 call</li><li>第一个 ‘*‘ 号是返回值， ‘*’ 代表是任意返回值； 第二个 ‘*’ 号代表是包名，‘*’ 代表是任意包名,这边表明我们是选择任意包名下的 println 函数；在 （..） 中指定参数类型，‘..’ 通配符表示任意类型；</li><li>&amp;&amp;！ 表示组合条件，有 &amp;&amp;， || 以及 ！</li><li>within(TestAspect): within 是 JoinPoint 间接选择过滤的一个方法，后面会讲到。 ！within(TestAspect) 表示调用者的类型不是 TestAspect.</li></ul><h5 id="3-JointPoint-的选择"><a href="#3-JointPoint-的选择" class="headerlink" title="3. JointPoint 的选择"></a>3. JointPoint 的选择</h5><p>JointPoint 的选择有分成直接选择和间接选择两种方式</p><ul><li>JointPoint 的直接选择就是通过和 Pointcut 的语法一一对应关系中选择；</li><li>JointPoint 的间接选择就是通过一些通配符进行筛选过滤的选择，上面例子中的 within 就是间接选择的一种。</li></ul><h6 id="1-JointPoint-直接选择"><a href="#1-JointPoint-直接选择" class="headerlink" title="1.JointPoint 直接选择"></a>1.JointPoint 直接选择</h6><p>JoinPoint 的选择策略和 Pointcut 的语法对应关系</p><table><thead><tr><th>JoinPoint Category</th><th>Pointcut Syntax</th></tr></thead><tbody><tr><td>Method execution</td><td>execution(MethodSignature)</td></tr><tr><td>Method call</td><td>call(MethodSignature)</td></tr><tr><td>Constructor execution</td><td>execution(ConstructorSignature)</td></tr><tr><td>Constructor call</td><td>call(ConstructorSignature)</td></tr><tr><td>Class initialization</td><td>staticinitialization(TypeSignature)</td></tr><tr><td>Field read access</td><td>get(FieldSignature)</td></tr><tr><td>Field write access</td><td>set(FieldSignature)</td></tr><tr><td>Exception handler execution</td><td>handler(TypeSignature)</td></tr><tr><td>Object initialization</td><td>initialization(ConstructorSignature)</td></tr><tr><td>Object pre-initialization</td><td>preinitialization(ConstructorSignature)</td></tr><tr><td>Advice execution</td><td>adviceexecution()</td></tr></tbody></table><p>JoinPoint 的策略的选择对应着不同 Pointcut，特别是 Pointcut 里面有着不同的 Signature。</p><p>以下有详细的说明：</p><p><strong>Method Signature 表达式</strong><br>语法</p><blockquote><p>@注解 访问权限 返回值的类型 包名.函数名(参数)<br>例子：<br>@before(“execution(* android.app.Activity.on**(..))”);</p></blockquote><ul><li>注解：  是可选项; 这里是 @before,关于注解的在后面 Adivce 中有更详细的说明</li><li>访问权限: 可选项; 有 public, private, protected 类型；例子没有设置</li><li>返回值的类型: 与普通函数的返回值类型是一样的，如果不限定类型，用通配符 <em> 表示。例子中是 </em></li><li><p>包名.函数名：用于查找匹配的函数，可以使用通配符<br>  <br> 通配符的类型</p><ul><li>‘ * ‘表示用于匹配处 . 号之外的任意字符；</li><li>‘ .. ‘ 表示任意子 package</li><li><p>‘ + ‘号表示子类</p><p><br> 例子：</p><ul><li>java.*.Data: 可以表示 java.sql.Data ，也可以表示 java.util.Date;</li><li>Test* : 表示Test开头的函数，可以表示 TestBase, 也可以表示 TestDervied</li><li>java..* : 表示 java 任意子类</li><li>java..*Model+: 表示 Java 任意 package 中名字以 Model 结尾的子类，比如 TabelModel, TreeModel 等</li></ul></li></ul></li><li><p>函数参数<br>参数有不同的型式</p><ul><li>(int, char): 表示参数只有两个， 并且第一个参数是 int, 第二个参数是 char;</li><li>(String, ..): 表示参数至少有一个。并且第一个参数是 String, 后面参数类型不限。在参数匹配中， .. 代表任意参数个数和类型；</li><li>（Oject …）: 表示不定个数的参数，并且类型都是 Object, 这里的 … 不是通配符，而是 java 中不定参数的意思；</li></ul></li></ul><p><strong>Constructor Signature 表达式</strong><br>和 Method Signature 类似<br>            不同点：<br>                构造函数没有返回值，并且函数名必须叫 new<br>例子：</p><blockquote><p>public *..TestDeived.new(..)</p></blockquote><ul><li>public: 表示选择 public 访问权限的</li><li>*.. : 代表任意包名</li><li>TestDeived.new: 代表 TestDerived 的构造函数</li><li>(..): 代表参数个数和类型都是任意的 </li></ul><p><strong>Field Signature表达式</strong><br>语法</p><blockquote><p>@注解 访问权限 类型 类名.成员变量名</p></blockquote><ul><li>@注解和访问权限是可选的</li><li>类型：成员变量类型， * 表示任意类型</li><li>类名.成员变量名： 成员变量名可以是*， 代表任意成员变量</li></ul><p>例子, 用 AspectJ 打印成员变量赋值前后的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TraceAspect.java　set field 的切面</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String POINTCUT_FILEED =</span><br><span class="line">        <span class="string">"set(int org.android10.viewgroupperformance.activity.MainActivity.mTest) &amp;&amp; args(newValue) &amp;&amp; target(t)"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span>(POINTCUT_FILEED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFiled</span><span class="params">(JoinPoint joinPoint, Object newValue, Object t)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">    Object object = joinPoint.getThis();</span><br><span class="line"></span><br><span class="line">    FieldSignature fieldSignature = (FieldSignature) joinPoint.getSignature();</span><br><span class="line">    String fileName = fieldSignature.getName();</span><br><span class="line">    Field field = fieldSignature.getField();</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Class clazz = fieldSignature.getFieldType();</span><br><span class="line">    String clazzName = clazz.getSimpleName();</span><br><span class="line"></span><br><span class="line">    Object oldValue = field.get(t);</span><br><span class="line"></span><br><span class="line">    Log.i(<span class="string">"MainActivity"</span>, <span class="string">"\nonFiled value = "</span> + newValue.toString() + <span class="string">"\n fieldSignature ="</span> + fieldSignature.toString()</span><br><span class="line">                + <span class="string">"\nfield = "</span> + field.toString() + <span class="string">" +  \nFileName = "</span> + fileName</span><br><span class="line">                + <span class="string">"\nclazzName = "</span> + clazzName + <span class="string">" \noldValue = "</span> + oldValue.toString() );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 MainActivity.java 中</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        mTest = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果</p><blockquote><p>onFiled value = 100<br>     fieldSignature =int org.android10.viewgroupperformance.activity.MainActivity.mTest<br>    field = private int org.android10.viewgroupperformance.activity.MainActivity.mTest +<br>    FileName = mTest<br>    clazzName = int<br>    oldValue = -1</p></blockquote><p><strong>TypeSignature表达式</strong><br>    例子：<br>    staticinitlization(test..TestBase): 表示 TestBase 类的 static block<br>handler(NullPointException): 表示 catch 到 NullPointerException 的 JPoin</p><h6 id="2-JointPoint-间接选择"><a href="#2-JointPoint-间接选择" class="headerlink" title="2.JointPoint 间接选择"></a>2.JointPoint 间接选择</h6><p>JointPoint 的直接选择是通过 Signature 信息匹配的，除此之外还有其他的方式，这些方式都可以归类到间接选择</p><table><thead><tr><th>关键词</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>within(TypePattern)</td><td>TypePattern 表示 package 或者类<br> TypePattern 可以使用通配符</td><td>表示某个 Package 或者类中的 Point<br>within(Test): Test　类中（包括内部类）所有的 JointPoint</td></tr><tr><td>withcode(Constructor Signature\</td><td>Method Signature)</td><td>表示某个构造函数或其他函数执行过程涉及到的 JointPoint</td><td>withinCode(<em> Test.testMethod(..))<br>表示 testMethod 涉及的 JointPoint<br>withinCode(</em>.Test.new(..))<br>表示 Test 的构造函数涉及的 JointPoint</td></tr><tr><td>cflow(pointcuts)</td><td>cflow 表示 call flow<br>cflow 的条件是一个 pointcut</td><td>cflow(call Test.testMethod)<br>表示调用 Test.testMethod 函数是所包含的 JointPoint,包含 testMethod 的 call 这个 JointPoint 本身</td></tr><tr><td>cflowbelow(pointcuts)</td><td>cflowbelow 表示不包含自身的 cflow</td><td>cflowbelow(call Test.testMethod)<br>表示调用 Test.testMethod 函数是所包含的 JointPoint, <strong><em>不包含</em></strong> testMethod 的 call 这个 JointPoint 本身</td></tr><tr><td>this(Type)</td><td>JointPoint 的 this 对象是 Type 类型</td><td>JPoint是代码段（不论是函数，异常处理，static block），从语法上说，它都属于一个类。如果这个类的类型是Type标示的类型，则和它相关的JPoint将全部被选中。</td></tr><tr><td>target(Type)</td><td>JoinPoint 的 target 对象是 Type 类型</td><td>和this相对的是target。不过target一般用在call的情况。call一个函数，这个函数可能定义在其他类。比如testMethod是TestDerived类定义的。那么target(TestDerived)就会搜索到调用testMethod的地方。但是不包括testMethod的execution JointPoint</td></tr><tr><td>args(TypeSignature)</td><td>用来对 JointPoint 的参数进行条件搜索</td><td>例如 arg(int, ..)<br>表示第一个参数是 int, 后面参数个数和类型不限的 JointPoint</td></tr></tbody></table><h6 id="3-call-与-execution-区别"><a href="#3-call-与-execution-区别" class="headerlink" title="3.call 与 execution 区别"></a>3.call 与 execution 区别</h6><p>当 call 捕获 joinPoint 时，捕获的签名方法的<strong>调用点</strong>;execution 捕获 joinPoint 时，捕获的则是<strong>执行点</strong>。<br>两个的区别在于一个是 ”调用点“， 一个是 ”执行点“</p><p>对于 call 来讲</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">call(Before)</span><br><span class="line">Pointcut &#123;</span><br><span class="line">    Pointcut Method</span><br><span class="line">&#125;</span><br><span class="line">call(After)</span><br></pre></td></tr></table></figure><p>对于 execution 来说</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pointcut &#123;</span><br><span class="line">   Execution(Before)</span><br><span class="line">   Pointcut Method</span><br><span class="line">   Execution(After)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-AspectJ-注解的等价"><a href="#3-AspectJ-注解的等价" class="headerlink" title="3.AspectJ 注解的等价"></a>3.AspectJ 注解的等价</h6><p>AspectJ 提供了相应的注解，注解的方式和 AspectJ 语言编写是等效的。我们在 Android 中一般也是采用注解的方式</p><p><strong>Aspect</strong></p><blockquote><pre><code>public aspect Foo{}</code></pre><p>等效<br>@Aspect<br>public class Foo{}</p></blockquote><p><strong>call</strong></p><blockquote><p>@Pointcut(“call(<em> </em>.<em>(..))”)<br>    void anyCall(){}<br>    等效<br>    pointcut anyCall(): call(</em> <em>.</em>(..))</p></blockquote><p>要绑定参数的时候，只需要将参数作为备注解的方法的参数即可</p><blockquote><p>@Pointcut(“call(<em> </em>.<em>(int)) &amp;&amp; arg(i) &amp;&amp; target(callee)”)<br>    void anyCall(int i, Fool callee){}<br>    等效<br>    pointcut anyCall(int i, Foo callee): call(</em> <em>.</em>(int)) &amp;&amp; arg(i) &amp;&amp; target(callee){};<br>说明要先定义参数 int i, Foo callee</p></blockquote><p><strong>before</strong></p><blockquote><p>@Before(“call(<em> org.android10.viewgroupperformance.activity..</em>(..)) &amp;&amp; this(foo)”)<br>public void callFromFoo(Foo foo){}<br>等效<br>before(Foo foo): call(<em> org.android10.viewgroupperformance.activity..</em>(..)) &amp;&amp; this(foo){}</p></blockquote><p><strong>returning</strong></p><blockquote><p>@AfterReturning(pointcut=”call(Foo+.new(..))”, returning=”f”)<br>public void itsAFoo(foo f){}<br>等效<br>after returning(Foo f): call(Foo+.new(..)){}</p></blockquote><p>其他的表达式也是类似的</p><h5 id="4-Advice"><a href="#4-Advice" class="headerlink" title="4. Advice"></a>4. Advice</h5><p>Advice: Advice defines pieces of aspect implementation that execute at well-defined points in the execution of the program.</p><p>通过前面的 Pointcuts 找到了相应的 JointPoint, 需要对这些 JointPoint 最一些事情，相当于对 JointPoint 进行 hook, 这就是 advice 要做的事。</p><p>advice 的分类</p><table><thead><tr><th>关键词</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>before()</td><td>before advice</td><td>表示在 JointPoint 执行之前要干 的事</td></tr><tr><td>after()</td><td>after advice</td><td>表示在 JointPoint 执行之后要干的事</td></tr><tr><td>after(): returning(返回值类型)<br>after():throwing(异常类型)</td><td>returning 和 throwing 后面都可以指定具体的类型，如果不指定则匹配类型不限制</td><td>假设 JointPoint 是一个函数调用<br>那么函数调用执行完有两种方式退出<br>一个是正常的 return, 另一个是抛异常<br>after() 默认包括 returing 和 throwing 两种情况</td></tr><tr><td>返回值类型<br> around()</td><td>around 替代原来的 JointPoint</td><td>around 替代了原来的 JointPoint，如果要执行原 JointPoint 的话，需要调用 procced</td></tr></tbody></table><p>例子：<br>我们需要在 Activity 中的 onResume 方法调用前后输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainActivity.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    Log.i(TAG, <span class="string">"--- onResume---"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TraceAspect.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String POINTCUT_ONMETHOD =</span><br><span class="line">        <span class="string">"execution(* android.app.Activity.on**(..))"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span>(POINTCUT_ONMETHOD)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeOnMethod</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">    String className = methodSignature.getDeclaringType().getSimpleName();</span><br><span class="line">    String methodName = methodSignature.getName();</span><br><span class="line">    Log.i(className, <span class="string">"before "</span> + methodName + <span class="string">" log"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@After</span>(POINTCUT_ONMETHOD)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMethLog</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">    MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">    String className = methodSignature.getDeclaringType().getSimpleName();</span><br><span class="line">    String methodName = methodSignature.getName();</span><br><span class="line">    Log.i(className, <span class="string">"after "</span> + methodName + <span class="string">" log"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看输出</p><p><img src="/2019/06/29/AspectJ在Android中的使用/aspectj_1.png" width="80%" height="100%"></p><p>改成 Around 的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TraceAspect.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String POINTCUT_ONMETHOD =</span><br><span class="line">        <span class="string">"execution(* android.app.Activity.on**(..))"</span>;</span><br><span class="line"><span class="meta">@Pointcut</span>(POINTCUT_ONMETHOD)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">annotationOnMethodTrace</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Around</span>(<span class="string">"annotationOnMethodTrace()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">weaveOnMethodJoinPoint</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">  MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">  String className = methodSignature.getDeclaringType().getSimpleName();</span><br><span class="line">  String methodName = methodSignature.getName();</span><br><span class="line"></span><br><span class="line">  Log.i(<span class="string">"MainActivity"</span>, <span class="string">"before joinPoint proceed className = "</span> + className + <span class="string">" methodName = "</span> + methodName);</span><br><span class="line"></span><br><span class="line">  Object result  = joinPoint.proceed();</span><br><span class="line">  Log.i(<span class="string">"MainActivity"</span>, <span class="string">"after joinPoint proceed className = "</span> + className + <span class="string">" methodName = "</span> + methodName);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><p><img src="/2019/06/29/AspectJ在Android中的使用/aspectj_2.png" width="80%" height="100%"></p><p>从上面例子的输出我们可以看到 around 等价于 before + after, 另外 JointPoint#proceed 是原来的 JointPoint，在这里是 onResume 方法， 输出中的 <em>“— onResume—”</em> 就是在 onResume 中打印的。</p><h5 id="5-参数传递和-JointPoint-信息"><a href="#5-参数传递和-JointPoint-信息" class="headerlink" title="5. 参数传递和 JointPoint 信息"></a>5. 参数传递和 JointPoint 信息</h5><p>经过前面的几个步骤，我们已经拿到了 JointPoint,但是我们经常需要对一些 advice 传入参数，然后进行处理的。例如如果传入的参数不合法，就不用调 JointPoint#proceed 方法处理了。</p><p><strong>参数传递</strong></p><p>advice 参数的方法由  <strong><em>this, target(), args()</em></strong></p><ul><li><strong>this(Type or Id):</strong> 捕获当前对象（被绑定 this）实例执行的连接点 – 实例由 Type 或者 Id 描述</li><li><strong>target(Type or Id):</strong> 捕获目标对象（被应用与对象上的调用和属性操作）实例的连接点 – 实例由 Type 和 Id 描述（必须绑定和封装后放入通知或者切点定义）。它不匹配任何静态的调用、应用和设置成员。</li><li><strong>args(Type or Id):</strong>  捕获具有适当类型样式的实例连接点</li></ul><p>下面是例子说明<br>我们在 MainActivity 定义一个成员变量 mTest, 初始值为 -1，在 OnResume() 方法对它进行赋值，用 target 和 args 对 mTest 赋值前后的值进行监听</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainActivity.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mTest = -<span class="number">1</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    Log.i(TAG, <span class="string">"--- onResume---"</span>);</span><br><span class="line">    mTest = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TraceAspect.java</span></span><br><span class="line"><span class="comment">//　set field 的切面</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String POINTCUT_FILEED =</span><br><span class="line">        <span class="string">"set(int org.android10.viewgroupperformance.activity.MainActivity.mTest) &amp;&amp; args(newValue) &amp;&amp; target(t)"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span>(POINTCUT_FILEED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFiled</span><span class="params">(JoinPoint joinPoint, Object newValue, Object t)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line">    FieldSignature fieldSignature = (FieldSignature) joinPoint.getSignature();</span><br><span class="line">    String fileName = fieldSignature.getName();</span><br><span class="line">    Field field = fieldSignature.getField();</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Class clazz = fieldSignature.getFieldType();</span><br><span class="line">    String clazzName = clazz.getSimpleName();</span><br><span class="line"></span><br><span class="line">    Object oldValue = field.get(t);</span><br><span class="line"></span><br><span class="line">    Log.i(<span class="string">"MainActivity"</span>,</span><br><span class="line">               <span class="string">"\nonFiled value = "</span> + newValue.toString()</span><br><span class="line">                    + <span class="string">"\ntarget = "</span> + t.toString()</span><br><span class="line">                    + <span class="string">"\n fieldSignature ="</span> + fieldSignature.toString()</span><br><span class="line">                    + <span class="string">"\nfield = "</span> + field.toString()</span><br><span class="line">                    + <span class="string">"\nFileName = "</span> + fileName</span><br><span class="line">                    + <span class="string">"\nclazzName = "</span> + clazzName</span><br><span class="line">                    + <span class="string">" \noldValue = "</span> + oldValue.toString() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看输出</p><p><img src="/2019/06/29/AspectJ在Android中的使用/aspectj_3.png" width="80%" height="100%"></p><p>定义切面表达式使用 <em>args(newValue) &amp;&amp; target(t)</em> 它们的参数值 <em>newValue, t</em>,必须要和方法中的定义的对的上 </p><blockquote><p>public void onFiled(JoinPoint joinPoint, Object newValue, Object t)</p></blockquote><p><strong>JointPoint 信息</strong><br>在 advice 中我们可以拿到 JointPoint 的信息，一般包含</p><ul><li><p>JointPoint 对象信息：例如参数、前面之类的</p><blockquote><p>JoinPoint.getSignature() 包含有</p><ol><li>MethodSignature 方法的签名</li><li>FieldSignature 成员变量的签名</li><li>ConstructorSignature 构造函数的签名</li><li>InitializerSignature 初始化的签名</li></ol></blockquote></li></ul><p>不同的签名对应不同的场景</p><ul><li>JointPoint 源代码部分的信息，例如类型、所处的位置</li><li>JointPoint 静态部分信息</li></ul><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"methodAnnotatedWithDebugTrace() || constructorAnnotatedDebugTrace()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">weaveJoinPoint</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// joint 对象信息</span></span><br><span class="line">    MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">    String className = methodSignature.getDeclaringType().getSimpleName();</span><br><span class="line">    String methodName = methodSignature.getName();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 源代码部分信息</span></span><br><span class="line">    SourceLocation sourceLocation = joinPoint.getSourceLocation();</span><br><span class="line">    String fileName = sourceLocation.getFileName();</span><br><span class="line">    <span class="keyword">int</span> line = sourceLocation.getLine();</span><br><span class="line">    String soucreClassName = sourceLocation.getWithinType().getName();</span><br><span class="line">    DebugLog.log(className, <span class="string">"\nfileName = "</span> + fileName + <span class="string">"\nline = "</span> + line + <span class="string">"\nsoucreClassName = "</span> + soucreClassName);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 静态部分</span></span><br><span class="line">    JoinPoint.StaticPart staticPart = joinPoint.getStaticPart();</span><br><span class="line">        </span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更详细的信息参考文档<br><a href="https://www.eclipse.org/aspectj/doc/released/runtime-api/index.html" target="_blank" rel="noopener">https://www.eclipse.org/aspectj/doc/released/runtime-api/index.html</a></p><p>总结一下，使用 AspectJ 的步骤：</p><blockquote><ol><li>设置 Pointcut 的表达式</li><li>选择相应的 advice</li><li>对 JointPoint 或参数进行相应的处理</li></ol></blockquote><h3 id="三、AspectJ-集成在-Android-studio-中"><a href="#三、AspectJ-集成在-Android-studio-中" class="headerlink" title="三、AspectJ 集成在 Android studio 中"></a>三、AspectJ 集成在 Android studio 中</h3><p>前面已经介绍完了 AspectJ, 那接下来看看在 Android 中的实际使用；<br>实例代码是在这个例子上进行修改的<a href="https://github.com/android10/Android-AOPExample" target="_blank" rel="noopener">Android-AOPExample</a>。</p><h4 id="1-Library-库依赖方式使用"><a href="#1-Library-库依赖方式使用" class="headerlink" title="1. Library 库依赖方式使用"></a>1. Library 库依赖方式使用</h4><p>项目的结构如下</p><p><img src="/2019/06/29/AspectJ在Android中的使用/aspectj_4.png" width="60%" height="40%"></p><p>在 library 项目 gintoinc 的 build.gradle 文件要添加 aspectj 的依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">  &#125;</span><br><span class="line">  dependencies &#123;</span><br><span class="line">    classpath &apos;com.android.tools.build:gradle:2.1.0&apos;</span><br><span class="line">    classpath &apos;org.aspectj:aspectjtools:1.8.1&apos;  // aspectjtools</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: &apos;com.android.library&apos;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">  mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  compile &apos;org.aspectj:aspectjrt:1.8.1&apos;  // aspectjrt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">  compileSdkVersion 21</span><br><span class="line">  buildToolsVersion &apos;21.1.2&apos;</span><br><span class="line"></span><br><span class="line">  lintOptions &#123;</span><br><span class="line">    abortOnError false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// -showWeaveInfo，输出编织过程信息</span><br><span class="line">// -1.5 设置规范1.5，匹配java1.5</span><br><span class="line">// -inpath class文件目录或者jar包， 源字节码，需要处理的类</span><br><span class="line">// -aspectpath  定义的切面类</span><br><span class="line">// -d 存放编辑产生的class文件</span><br><span class="line">// -classpath ，所有class文件，源class，java包，编织时需要用到的一些处理类</span><br><span class="line">android.libraryVariants.all &#123; variant -&gt;</span><br><span class="line">  LibraryPlugin plugin = project.plugins.getPlugin(LibraryPlugin)</span><br><span class="line">  JavaCompile javaCompile = variant.javaCompile</span><br><span class="line">  javaCompile.doLast &#123;</span><br><span class="line">    String[] args = [&quot;-showWeaveInfo&quot;,</span><br><span class="line">                     &quot;-1.5&quot;,</span><br><span class="line">                     &quot;-inpath&quot;, javaCompile.destinationDir.toString(),</span><br><span class="line">                     &quot;-aspectpath&quot;, javaCompile.classpath.asPath,</span><br><span class="line">                     &quot;-d&quot;, javaCompile.destinationDir.toString(),</span><br><span class="line">                     &quot;-classpath&quot;, javaCompile.classpath.asPath,</span><br><span class="line">                     &quot;-bootclasspath&quot;, plugin.project.android.bootClasspath.join(File.pathSeparator)]</span><br><span class="line"></span><br><span class="line">    MessageHandler handler = new MessageHandler(true);</span><br><span class="line">    new Main().run(args, handler)</span><br><span class="line"></span><br><span class="line">    def log = project.logger</span><br><span class="line">    for (IMessage message : handler.getMessages(null, true)) &#123;</span><br><span class="line">      switch (message.getKind()) &#123;</span><br><span class="line">        case IMessage.ABORT:</span><br><span class="line">        case IMessage.ERROR:</span><br><span class="line">        case IMessage.FAIL:</span><br><span class="line">          log.error message.message, message.thrown</span><br><span class="line">          break;</span><br><span class="line">        case IMessage.WARNING:</span><br><span class="line">        case IMessage.INFO:</span><br><span class="line">          log.info message.message, message.thrown</span><br><span class="line">          break;</span><br><span class="line">        case IMessage.DEBUG:</span><br><span class="line">          log.debug message.message, message.thrown</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在引用库工程的工程 build.gradle 也要进行相应的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">import org.aspectj.bridge.IMessage</span><br><span class="line">import org.aspectj.bridge.MessageHandler</span><br><span class="line">import org.aspectj.tools.ajc.Main</span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">  &#125;</span><br><span class="line">  dependencies &#123;</span><br><span class="line">    classpath &apos;org.aspectj:aspectjtools:1.8.1&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: &apos;com.android.application&apos;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">  mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  compile project(&apos;:gintonic&apos;)</span><br><span class="line">  compile &apos;org.aspectj:aspectjrt:1.8.1&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">  compileSdkVersion 21</span><br><span class="line">  buildToolsVersion &apos;21.1.2&apos;</span><br><span class="line"></span><br><span class="line">  defaultConfig &#123;</span><br><span class="line">    applicationId &apos;android10.org.viewgroupperformance&apos;</span><br><span class="line">    minSdkVersion 15</span><br><span class="line">    targetSdkVersion 21</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lintOptions &#123;</span><br><span class="line">    abortOnError true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final def log = project.logger</span><br><span class="line">final def variants = project.android.applicationVariants</span><br><span class="line"></span><br><span class="line">variants.all &#123; variant -&gt;</span><br><span class="line">  if (!variant.buildType.isDebuggable()) &#123;</span><br><span class="line">    log.debug(&quot;Skipping non-debuggable build type &apos;$&#123;variant.buildType.name&#125;&apos;.&quot;)</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  JavaCompile javaCompile = variant.javaCompile</span><br><span class="line">  javaCompile.doLast &#123;</span><br><span class="line">    String[] args = [&quot;-showWeaveInfo&quot;,</span><br><span class="line">                     &quot;-1.5&quot;,</span><br><span class="line">                     &quot;-inpath&quot;, javaCompile.destinationDir.toString(),</span><br><span class="line">                     &quot;-aspectpath&quot;, javaCompile.classpath.asPath,</span><br><span class="line">                     &quot;-d&quot;, javaCompile.destinationDir.toString(),</span><br><span class="line">                     &quot;-classpath&quot;, javaCompile.classpath.asPath,</span><br><span class="line">                     &quot;-bootclasspath&quot;, project.android.bootClasspath.join(File.pathSeparator)]</span><br><span class="line">    log.debug &quot;ajc args: &quot; + Arrays.toString(args)</span><br><span class="line"></span><br><span class="line">    MessageHandler handler = new MessageHandler(true);</span><br><span class="line">    new Main().run(args, handler);</span><br><span class="line">    for (IMessage message : handler.getMessages(null, true)) &#123;</span><br><span class="line">      switch (message.getKind()) &#123;</span><br><span class="line">        case IMessage.ABORT:</span><br><span class="line">        case IMessage.ERROR:</span><br><span class="line">        case IMessage.FAIL:</span><br><span class="line">          log.error message.message, message.thrown</span><br><span class="line">          break;</span><br><span class="line">        case IMessage.WARNING:</span><br><span class="line">          log.warn message.message, message.thrown</span><br><span class="line">          break;</span><br><span class="line">        case IMessage.INFO:</span><br><span class="line">          log.info message.message, message.thrown</span><br><span class="line">          break;</span><br><span class="line">        case IMessage.DEBUG:</span><br><span class="line">          log.debug message.message, message.thrown</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文章<a href="https://fernandocejas.com/2014/08/03/aspect-oriented-programming-in-android/" target="_blank" rel="noopener">Aspect Oriented Programming in Android</a> 是通过注解去查看方法执行的时间，我们在这个基础上进行修改，去监听一个成员变量赋值变化的监听。</p><p>我们需要监听 <em>MainActivity</em> 中 <em>mTest</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mTest = -<span class="number">1</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    Log.i(TAG, <span class="string">"--- onResume---"</span>);</span><br><span class="line">    mTest = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第一步. 设置 Pointcut 的表达式</strong><br>在 <em>TraceAspect.java</em>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//　set field 的切面</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String POINTCUT_FILEED =</span><br><span class="line">           <span class="string">"set(int org.android10.viewgroupperformance.activity.MainActivity.mTest) &amp;&amp; args(newValue) &amp;&amp; target(t)"</span>;</span><br></pre></td></tr></table></figure><p>根据 JoinPoint 的选择策略和 Pointcut 的语法对应关系，成员变量选择的 <em>set</em>, 参数传递的监听使用 <em>args(newValue) &amp;&amp; target(t)</em></p><p><strong>第二步. 选择相应的 advice</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(POINTCUT_FILEED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFiled</span><span class="params">(JoinPoint joinPoint, Object newValue, Object t)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们选择的是 <em>Before</em>, 注意在第一步  args(newValue) &amp;&amp; target(t) 中的 <em>newValue 和 t</em> 是要在 advice 函数中定义的 <em>Object newValue, Object t</em>.</p><p><strong>第三步. 对 JointPoint 或参数进行相应的处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(POINTCUT_FILEED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFiled</span><span class="params">(JoinPoint joinPoint, Object newValue, Object t)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line">    FieldSignature fieldSignature = (FieldSignature) joinPoint.getSignature();</span><br><span class="line">    String fileName = fieldSignature.getName();</span><br><span class="line">    Field field = fieldSignature.getField();</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Class clazz = fieldSignature.getFieldType();</span><br><span class="line">    String clazzName = clazz.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取旧的值</span></span><br><span class="line">    Object oldValue = field.get(t);</span><br><span class="line"></span><br><span class="line">    Log.i(<span class="string">"MainActivity"</span>,</span><br><span class="line">               <span class="string">"\nonFiled value = "</span> + newValue.toString()</span><br><span class="line">                    + <span class="string">"\ntarget = "</span> + t.toString()</span><br><span class="line">                    + <span class="string">"\n fieldSignature ="</span> + fieldSignature.toString()</span><br><span class="line">                    + <span class="string">"\nfield = "</span> + field.toString()</span><br><span class="line">                    + <span class="string">"\nFileName = "</span> + fileName</span><br><span class="line">                    + <span class="string">"\nclazzName = "</span> + clazzName</span><br><span class="line">                    + <span class="string">" \noldValue = "</span> + oldValue.toString() );</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 JoinPoint 获取相应的信息。</p><p>在 build 之后，在 app/intermediates/classes/debug 目录下的 </p><p><img src="/2019/06/29/AspectJ在Android中的使用/aspectj_5.png" width="60%" height="40%"></p><p>MainActivity.class 文件中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    Log.i(<span class="string">"MainActivity"</span>, <span class="string">"--- onResume---"</span>);</span><br><span class="line">    <span class="keyword">byte</span> var1 = <span class="number">100</span>;</span><br><span class="line">    JoinPoint var3 = Factory.makeJP(ajc$tjp_2, <span class="keyword">this</span>, <span class="keyword">this</span>, Conversions.intObject(var1));</span><br><span class="line">    TraceAspect.aspectOf().onFiled(var3, Conversions.intObject(var1), <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.mTest = var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现上面生成了一下代码，这些生成的代码就是 AspectJ 根据我们前面设置的 Pointcut 和 adive 生成的。</p><p>输出<br>在 build 之后，在 app/intermediates/classes/debug 目录下的 </p><p><img src="/2019/06/29/AspectJ在Android中的使用/aspectj_3.png" width="70%" height="100%"></p><h4 id="2-Plugin-插件方式使用"><a href="#2-Plugin-插件方式使用" class="headerlink" title="2. Plugin 插件方式使用"></a>2. Plugin 插件方式使用</h4><p>如果是多个 Module 都依赖 AspectJ, 可以写成 plugin 插件的型式</p><p><img src="/2019/06/29/AspectJ在Android中的使用/aspectj_6.png" width="40%" height="50%"></p><p>关于如果使用 Android studio 的 Plugin 插件，可以去查看相关资料</p><p>项目的 build.gradle</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">        // 本地仓库</span><br><span class="line">        maven &#123;</span><br><span class="line">            url uri(&apos;repo&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:2.1.0&apos;</span><br><span class="line">        // 引入插件</span><br><span class="line">        classpath &apos;com.yxhuang:autotrack.android:1.0.1&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">      maven &#123;</span><br><span class="line">          url &apos;https://maven.google.com/&apos;</span><br><span class="line">          name &apos;Google&apos;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//task wrapper(type: Wrapper) &#123;</span><br><span class="line">//  gradleVersion = &apos;2.12&apos;</span><br><span class="line">//&#125;</span><br><span class="line">task clean(type: Delete) &#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gintonic 的 build.gradle 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">    //　本地代码仓</span><br><span class="line">    maven&#123;</span><br><span class="line">      url uri(&apos;../repo&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dependencies &#123;</span><br><span class="line">    classpath &apos;com.android.tools.build:gradle:2.1.0&apos;</span><br><span class="line">    classpath &apos;com.yxhuang:autotrack.android:1.0.1&apos; // 引用插件</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: &apos;com.android.library&apos;</span><br><span class="line">apply plugin: &apos;com.yxhuang.android&apos; // 引用插件</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">  mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">  compileSdkVersion 21</span><br><span class="line">  buildToolsVersion &apos;21.1.2&apos;</span><br><span class="line"></span><br><span class="line">  lintOptions &#123;</span><br><span class="line">    abortOnError false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>app module 的 build.gradle 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.android.application&apos;</span><br><span class="line">apply plugin: &apos;com.yxhuang.android&apos;  //引入插件</span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line"></span><br><span class="line">    //　本地代码仓</span><br><span class="line">    maven&#123;</span><br><span class="line">      url uri(&apos;../repo&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dependencies &#123;</span><br><span class="line">    classpath &apos;com.yxhuang:autotrack.android:1.0.1&apos; //引入插件</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">  mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  compile project(&apos;:gintonic&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">  compileSdkVersion 21</span><br><span class="line">  buildToolsVersion &apos;21.1.2&apos;</span><br><span class="line"></span><br><span class="line">  defaultConfig &#123;</span><br><span class="line">    applicationId &apos;android10.org.viewgroupperformance&apos;</span><br><span class="line">    minSdkVersion 15</span><br><span class="line">    targetSdkVersion 21</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lintOptions &#123;</span><br><span class="line">    abortOnError true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的代码可以去 github <a href="https://github.com/yxhuangCH/AndroidAopDemo" target="_blank" rel="noopener">AndroidAopDemo</a> 选择 tag v2 即可。</p><h3 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h3><ul><li>1.<a href="https://blog.csdn.net/innost/article/details/49387395" target="_blank" rel="noopener">深入理解Android之AOP</a></li><li>2.<a href="https://fernandocejas.com/2014/08/03/aspect-oriented-programming-in-android/" target="_blank" rel="noopener">Aspect Oriented Programming in Android</a></li><li>3.《Android 全埋点解决方案》第 8 章，<em>AppClick 全埋点方案5：AspectJ</em></li><li>4.极客时间专栏《Android 开发高手课》第 27 讲， <em>编译插桩的三种方法： AspectJ, ASM, ReDex</em></li><li>5.<a href="https://www.eclipse.org/aspectj/doc/next/adk15notebook/index.html" target="_blank" rel="noopener">AspectJ 官方手册</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#AspectJ 在 Android 中的使用&lt;br&gt;在介绍 AspectJ 之前，我们先看看常见的几种编程架构思想。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向对象编程 Object Oriented Programming&lt;/li&gt;
&lt;li&gt;面向过程编程 Procedure Ori
      
    
    </summary>
    
    
      <category term="Android" scheme="https://yxhuangch.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Glide 源码简要分析</title>
    <link href="https://yxhuangch.github.io/2019/02/23/glide-source-spimple-analyze/"/>
    <id>https://yxhuangch.github.io/2019/02/23/glide-source-spimple-analyze/</id>
    <published>2019-02-23T03:59:23.000Z</published>
    <updated>2019-02-23T09:41:36.646Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>Glide 是 Android 比较好的图片加载库，最近的项目中使用到了，所以有必要去了解一下 Glide 的源码。Glide 的源码非常多，不可能所有的东西都去了解，所以结合 <a href="https://blog.csdn.net/guolin_blog/article/details/53759439" target="_blank" rel="noopener">郭霖的博客</a> 对 Glide 的源码做了简要的分析。</p><p>对 Glide 的了解，主要想解决一下的几个问题：</p><ul><li><ol><li>Glide 加载图片的流程</li></ol></li><li><ol start="2"><li>Glide 加载图片流程的监听回调</li></ol></li><li><ol start="3"><li>Glide 是如何感知外部宿主的生命周期的</li></ol></li><li><ol start="4"><li>Glide 是如何处理缓存</li></ol></li><li><ol start="5"><li>Glide 是如何处理转换的</li></ol></li><li><ol start="6"><li>Glide 如何自定义 GlideModule</li></ol></li><li><ol start="7"><li>其他重要的方法和类</li></ol></li></ul><p>本文是基于 Glide 3.7.0 版本分析的。</p><h3 id="二、正文"><a href="#二、正文" class="headerlink" title="二、正文"></a>二、正文</h3><h4 id="1-Glide-加载图片的流程"><a href="#1-Glide-加载图片的流程" class="headerlink" title="1. Glide 加载图片的流程"></a>1. Glide 加载图片的流程</h4><p>Glide 加载图片</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(context).load(url).into(ImageView);</span><br></pre></td></tr></table></figure><ul><li>Glide.with() 返回是 RequestManager, RequestManager 是用来管理请求的，同时根据外部宿主（Activity/Fragment）生命周期的变化来管理请求；</li><li>Glide.with(context).load(url), 调用的是 DrawableTypeRequest.load(url), 返回是 DrawableRequestBuilder</li><li>DrawableRequestBuilder.into() 调用父类的 GenericRequestBuilder.into()</li></ul><p>图片加载的核心流程开始于 GenericRequest#begin()，中间重要的类是 Engine、EngineRunnable、DecodeJob、EngineJob。</p><ul><li><p>简要的流程分析：<br><img src="/2019/02/23/glide-source-spimple-analyze/glide_load_1.png" width="100%" height="100%"></p></li><li><p>简要的时序图：<br><img src="/2019/02/23/glide-source-spimple-analyze/glide_load_2.png" width="100%" height="100%"></p></li></ul><h4 id="2-Glide-加载图片流程的监听回调"><a href="#2-Glide-加载图片流程的监听回调" class="headerlink" title="2. Glide 加载图片流程的监听回调"></a>2. Glide 加载图片流程的监听回调</h4><p>当  EngineRunnable#run() 从数据源（缓存或者网络）获取数据，调用 onLoadComplete（） 方法，并通过回调到 EngineJob#onResourceReady， 然后通过 Handler 讲数据切换回主线程，最后回调 GenericRequest#onResourceReady() 通知完成数据的加载。<br>EngineRunnable#onLoadComplete()<br>    -&gt;EngineJob#onResourceReady()<br>    -&gt;EngineJob#handleResultOnMainThread()<br>    -&gt;GenericRequest#onResourceReady()</p><p>当我们设置了 Glide 的 listener 时，调用的时机是在 GenericRequest#onResourceReady() 里面</p><h4 id="3-Glide-是如何感知外部宿主的生命周期的"><a href="#3-Glide-是如何感知外部宿主的生命周期的" class="headerlink" title="3. Glide 是如何感知外部宿主的生命周期的"></a>3. Glide 是如何感知外部宿主的生命周期的</h4><p>Glide 在内部生成一个空的RequestManagerFragment, RequestManagerFragment 用来感知外部宿主的生命周期，然后这个 Fragment t通过 ActivityFragmentLifecycle 影响 RequestManager，来决定 Glide 请求过程中的决定</p><p>Glide.with() 是入口；<br>涉及的类<br>RequestManagerRetriever、RequestManagerFragment、ActivityFragmentLifecycle</p><h4 id="4-Glide-是如何处理缓存"><a href="#4-Glide-是如何处理缓存" class="headerlink" title="4. Glide 是如何处理缓存"></a>4. Glide 是如何处理缓存</h4><p>内存缓存，防止应用重复将图片数据读取到内存当中<br>硬盘缓存， 防止应用重复从网络或其他地方重复下载和读取数据</p><p>LruResourceCache  内存缓存<br>InternalCacheDiskCacheFactory  磁盘缓存策略，默认是 250 MB, DiskCache 类中<br>DiskLruCacheWrapper 默认的磁盘缓存类</p><ul><li>加载的时候， Engine.load() 方法中会调用 <ul><li>loadFromCache() 从缓存中获取</li><li>loadFromActiveResources()  从弱引用中获取</li></ul></li><li>放入到缓存中<ul><li>从网络获取数据成功是 EngineRunnable#run() 中回调用 onLoadComplete 回调，然后通过 handle 发送消息回到主线程，调用了EngineJob#handleResultOnMainThread，<br>  通过回调 Engine#onEngineJobComplete() 中放入到 弱引用缓存中<br>  EngineResource#acquire() 当前使用资源会加 1；<br>  EngineResource#release() 不再使用资源减 1； 回调 ResourceListener#onResourceReleased 回到 Engine 中, 放入到LRU内存缓存中</li></ul></li></ul><pre><code>- 放到磁盘缓存中 DecodeJob#cacheAndDecodeSourceData()                writeTransformedToCache#writeTransformedToCache()     这两个方法中存入磁盘, 使用 DiskLruCacheWrapper 类</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EngineRunnable#decodeFromCache</span></span><br><span class="line"><span class="keyword">private</span> Resource&lt;?&gt; decodeFromCache() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Resource&lt;?&gt; result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = decodeJob.decodeResultFromCache(); 先尝试取出 result 的缓存</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Exception decoding result from cache: "</span> + e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = decodeJob.decodeSourceFromCache(); 然后再取出 source 的缓存</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>Glide 的缓存策略是在创建 Glide 时确定的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GlideBuilder.java</span></span><br><span class="line"><span class="function">Glide <span class="title">createGlide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (sourceService == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> cores = Math.max(<span class="number">1</span>, Runtime.getRuntime().availableProcessors());</span><br><span class="line">          sourceService = <span class="keyword">new</span> FifoPriorityThreadPoolExecutor(cores);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (diskCacheService == <span class="keyword">null</span>) &#123;</span><br><span class="line">          diskCacheService = <span class="keyword">new</span> FifoPriorityThreadPoolExecutor(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      MemorySizeCalculator calculator = <span class="keyword">new</span> MemorySizeCalculator(context);</span><br><span class="line">      <span class="keyword">if</span> (bitmapPool == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">              <span class="keyword">int</span> size = calculator.getBitmapPoolSize();</span><br><span class="line">              bitmapPool = <span class="keyword">new</span> LruBitmapPool(size);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              bitmapPool = <span class="keyword">new</span> BitmapPoolAdapter();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (memoryCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">          memoryCache = <span class="keyword">new</span> LruResourceCache(calculator.getMemoryCacheSize());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (diskCacheFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">          diskCacheFactory = <span class="keyword">new</span> InternalCacheDiskCacheFactory(context);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (engine == <span class="keyword">null</span>) &#123;</span><br><span class="line">          engine = <span class="keyword">new</span> Engine(memoryCache, diskCacheFactory, diskCacheService, sourceService);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (decodeFormat == <span class="keyword">null</span>) &#123;</span><br><span class="line">          decodeFormat = DecodeFormat.DEFAULT;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Glide(engine, memoryCache, bitmapPool, context, decodeFormat);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果想要改变这些策略，需要自定义 GlideModule,在其 applyOptions 中设置；</p><p><img src="/2019/02/23/glide-source-spimple-analyze/glide_cache_1.png" width="100%" height="100%"></p><h4 id="5-Glide-是如何处理转换的"><a href="#5-Glide-是如何处理转换的" class="headerlink" title="5. Glide 是如何处理转换的"></a>5. Glide 是如何处理转换的</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(getContext()).load(R.drawable.ic_launchers)</span><br><span class="line">                   .transform(<span class="keyword">new</span> CircleTransform())</span><br><span class="line">                   .into(mImgUserAdver);</span><br></pre></td></tr></table></figure><p> .transform（） 方法设置了 Transformation 的实例，会一直传递到 DecodeJob 中，在 DecodeJob#transform() 中调用</p><p>调用的流程<br><img src="/2019/02/23/glide-source-spimple-analyze/glide_decode_1.png" width="100%" height="100%"></p><p>所有的变换都需要继承 Transformation</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transformation</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"> <span class="function">Resource&lt;T&gt; <span class="title">transform</span><span class="params">(Resource&lt;T&gt; resource, <span class="keyword">int</span> outWidth, <span class="keyword">int</span> outHeight)</span></span>;</span><br><span class="line"> <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 有 Glide 常用变换的开源库可用 <a href="https://github.com/wasabeef/glide-transformations" target="_blank" rel="noopener">https://github.com/wasabeef/glide-transformations</a></p><h4 id="6-Glide-如何自定义-GlideModule"><a href="#6-Glide-如何自定义-GlideModule" class="headerlink" title="6. Glide 如何自定义 GlideModule"></a>6. Glide 如何自定义 GlideModule</h4><p>继承 GlideModule，在 AndroidManifest.xml 中加入配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"com.example.glidetest.MyGlideModule"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">"GlideModule"</span> /&gt;</span></span><br><span class="line">        ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Glide.get() 方法里会把 GlideModule 解析出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Glide <span class="title">get</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (glide == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Glide.class) &#123;</span><br><span class="line">               <span class="keyword">if</span> (glide == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   Context applicationContext = context.getApplicationContext();</span><br><span class="line">                   List&lt;GlideModule&gt; modules = <span class="keyword">new</span> ManifestParser(applicationContext).parse();</span><br><span class="line"></span><br><span class="line">                   GlideBuilder builder = <span class="keyword">new</span> GlideBuilder(applicationContext);</span><br><span class="line">                   <span class="keyword">for</span> (GlideModule <span class="keyword">module</span> : modules) &#123;</span><br><span class="line">                       <span class="keyword">module</span>.applyOptions(applicationContext, builder);</span><br><span class="line">                   &#125;</span><br><span class="line">                   glide = builder.createGlide();</span><br><span class="line">                   <span class="keyword">for</span> (GlideModule <span class="keyword">module</span> : modules) &#123;</span><br><span class="line">                       <span class="keyword">module</span>.registerComponents(applicationContext, glide);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> glide;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="7-其他重要的方法和类"><a href="#7-其他重要的方法和类" class="headerlink" title="7. 其他重要的方法和类"></a>7. 其他重要的方法和类</h4><ul><li>into() 方法，可以传入自定义 Target</li><li>preload() 方法， 预加载</li><li>downloadOnly() 只下载</li><li><p>更改 Glide 的配置，在 GlideBuilder 类中</p><ul><li><p>setMemoryCache()<br>用于配置Glide的内存缓存策略，默认配置是LruResourceCache。</p></li><li><p>setBitmapPool()<br>用于配置Glide的Bitmap缓存池，默认配置是LruBitmapPool。</p></li><li><p>setDiskCache()<br>用于配置Glide的硬盘缓存策略，默认配置是InternalCacheDiskCacheFactory。</p></li><li><p>setDiskCacheService()<br>用于配置Glide读取缓存中图片的异步执行器，默认配置是FifoPriorityThreadPoolExecutor，也就是先入先出原则。</p></li><li><p>setResizeService()<br>用于配置Glide读取非缓存中图片的异步执行器，默认配置也是FifoPriorityThreadPoolExecutor。</p></li><li><p>setDecodeFormat()<br>用于配置Glide加载图片的解码模式，默认配置是RGB_565。</p></li></ul></li></ul><p>在自定义的 GlideMedule 的 applyOptions 中改配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGlideModule</span> <span class="keyword">implements</span> <span class="title">GlideModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyOptions</span><span class="params">(Context context, GlideBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 改配置</span></span><br><span class="line">        builder.setDiskCache(<span class="keyword">new</span> ExternalCacheDiskCacheFactory(context));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerComponents</span><span class="params">(Context context, Glide glide)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义组件</span></span><br><span class="line">    glide.register(GlideUrl.class, InputStream.class, <span class="keyword">new</span> OkHttpGlideUrlLoader.Factory());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h3><ul><li>LruBitmapPool 使用 LRU 算法实现的一个 Bitmap 缓存池，可以参考</li><li>DiskCacheWriteLocker 锁的实现</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;Glide 是 Android 比较好的图片加载库，最近的项目中使用到了，所以有必要去了解一下 Glide 的源码。Glid
      
    
    </summary>
    
    
      <category term="android; glide" scheme="https://yxhuangch.github.io/tags/android-glide/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock、synchronized 与 ReadWriteLock</title>
    <link href="https://yxhuangch.github.io/2019/01/07/ReentrantLock_synchronized%E4%B8%8EReadWriteLock/"/>
    <id>https://yxhuangch.github.io/2019/01/07/ReentrantLock_synchronized与ReadWriteLock/</id>
    <published>2019-01-07T14:22:41.000Z</published>
    <updated>2019-01-07T14:27:00.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ReentrantLock、synchronized-与-ReadWriteLock"><a href="#ReentrantLock、synchronized-与-ReadWriteLock" class="headerlink" title="ReentrantLock、synchronized 与 ReadWriteLock"></a>ReentrantLock、synchronized 与 ReadWriteLock</h2><h3 id="一-ReentrantLock"><a href="#一-ReentrantLock" class="headerlink" title="一. ReentrantLock"></a>一. ReentrantLock</h3><p>ReentrantLock 并不是内置锁 synchronized 的替代方式，而是当 synchronized 加锁机制不适用时，作为一种可选择的高级功能。<br>ReentrantLock 是 Lock 的实现类，Lock 提供无条件的、可轮询的、定时的以及可中断的锁获取操作，所有加锁和解锁的方法是显式的，因此 ReentrantLock 也被称为显示锁。</p><h4 id="1-Lock-的源码"><a href="#1-Lock-的源码" class="headerlink" title="1. Lock 的源码"></a>1. Lock 的源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;  <span class="comment">// 加锁</span></span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>; <span class="comment">// 尝试获取锁，如果加锁成功，返回 true</span></span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>; <span class="comment">// 在一定时间内获取锁，如果在时间内没有加锁成功，则提前结束</span></span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;  <span class="comment">// 解锁</span></span><br><span class="line">   </span><br><span class="line">   <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>; <span class="comment">// 返回锁的条件实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-ReentrantLock-的用法"><a href="#2-ReentrantLock-的用法" class="headerlink" title="2. ReentrantLock 的用法"></a>2. ReentrantLock 的用法</h4><h5 id="2-1-ReentrantLock-的标准用法"><a href="#2-1-ReentrantLock-的标准用法" class="headerlink" title="2.1 ReentrantLock 的标准用法"></a>2.1 ReentrantLock 的标准用法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Lock 的标准用法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">luckExp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line"></span><br><span class="line">    lock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 更新对象转态</span></span><br><span class="line">        <span class="comment">// 捕获异常，并在必要时恢复不变性条件</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();  <span class="comment">// 一定要在 finally 中解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-ReentrantLock-带时间的加锁"><a href="#2-2-ReentrantLock-带时间的加锁" class="headerlink" title="2.2 ReentrantLock 带时间的加锁"></a>2.2 ReentrantLock 带时间的加锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 带有时间限制的加锁</span></span><br><span class="line"><span class="comment">// 如果操作不能再指定的时间内给出结果，程序会提前结束</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">trySend</span><span class="params">(String message, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">long</span> nanosToLock = unit.toNanos(timeout) - estimatedNanosToSend(message);</span><br><span class="line">    <span class="keyword">if</span> (!lock.tryLock(nanosToLock, TimeUnit.NANOSECONDS))&#123;  <span class="comment">// 定时锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sendOnSharedLine(message); <span class="comment">// 操作</span></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二-Synchronized"><a href="#二-Synchronized" class="headerlink" title="二. Synchronized"></a>二. Synchronized</h3><p>使用了 synchronized 方法在同一时间只能被一个线程使用，其他线程必须等到这方法释放。<br>线程在进入了同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁。</p><h4 id="同步代码块包含两部分"><a href="#同步代码块包含两部分" class="headerlink" title="同步代码块包含两部分"></a>同步代码块包含两部分</h4><ul><li>一个作为锁的对象引用</li><li>一个作为由这个锁保护的代码块</li></ul><h4 id="两种使用方法"><a href="#两种使用方法" class="headerlink" title="两种使用方法"></a>两种使用方法</h4><ul><li><strong>以锁的对象使用</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁的对象引用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lockObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">        <span class="comment">// 访问或修改由锁保护的共享状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>锁保护的代码块</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 锁保护代码块</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Class对象锁</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventBus instance = defaultInstance;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (EventBus.class) &#123;</span><br><span class="line">            instance = EventBus.defaultInstance;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = EventBus.defaultInstance = <span class="keyword">new</span> EventBus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-Synchronized-与-ReentrantLock-之间选择"><a href="#三-Synchronized-与-ReentrantLock-之间选择" class="headerlink" title="三. Synchronized 与 ReentrantLock 之间选择"></a>三. Synchronized 与 ReentrantLock 之间选择</h3><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><ul><li>开发人员熟悉，简洁紧凑</li><li>不用担心解锁的问题</li><li>在线程转储中能给出在哪些调用帧获得了哪些锁，并能检测和识别发生了死锁的线程</li></ul><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><ul><li>提供了可定时的、可轮询的与可中断的锁</li><li>如果忘记 unlock， 会发生死锁的问题</li></ul><h4 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h4><p>在 synchronized 无法满足的情况下才会使用 ReentrantLock</p><h3 id="3-ReadWriteLock-读写锁"><a href="#3-ReadWriteLock-读写锁" class="headerlink" title="3. ReadWriteLock 读写锁"></a>3. ReadWriteLock 读写锁</h3><ul><li>当读线程多于写线程时，使用 ReadWrite 线程会更好一些</li><li>ReentrantReadWriteLocks 可以用作提高一些并发容器的性能</li><li><p>当锁的持有时间比较长并且大部分操作都不会修改被守护资源是，ReadWriteLock 能提高并发性</p></li><li><p><strong>ReadWriteLock 接口</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;  <span class="comment">// 返回一个读的锁</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>; <span class="comment">// 返回一个写的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>提高一些并发容器的性能</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当锁的持有较长并且大部分操作都不会修改被守护的资源时， ReadWriteLock 可以提高并发性</span></span><br><span class="line"><span class="comment"> * 避免了 "读-写" 与 "写-写"的冲突，</span></span><br><span class="line"><span class="comment"> * 可以多个同时 "读-读"</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock readLock = lock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock writeLock = lock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadWriteMap</span><span class="params">(Map&lt;K, V&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.map = map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 remove(), putAll(), clear() 等方法执行相同的操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ReentrantLock、synchronized-与-ReadWriteLock&quot;&gt;&lt;a href=&quot;#ReentrantLock、synchronized-与-ReadWriteLock&quot; class=&quot;headerlink&quot; title=&quot;Reentran
      
    
    </summary>
    
    
      <category term="java" scheme="https://yxhuangch.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java 的反射</title>
    <link href="https://yxhuangch.github.io/2018/11/24/java-reflect/"/>
    <id>https://yxhuangch.github.io/2018/11/24/java-reflect/</id>
    <published>2018-11-24T09:03:20.000Z</published>
    <updated>2018-11-24T09:09:53.144Z</updated>
    
    <content type="html"><![CDATA[<p>#Java 反射<br>Java 反射是在 java.lang.reflect 包类，包含 Constructor、Method、Field 的反射。</p><table><thead><tr><th style="text-align:left">域</th><th style="text-align:left">涉及的方法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">创建类 Constructor</td><td style="text-align:left">Class.getConstructor( ) Constructor.newInstance(args)</td><td style="text-align:left">newInstance( ) 方法可以为无参调用</td></tr><tr><td style="text-align:left">方法 Method</td><td style="text-align:left">Class.getMethods( ) Class.getDeclaredMethods( )</td><td style="text-align:left">getMethods( ) 返回自身和父类的方法; getDeclaredMethods( ) 只返回自身的方法</td></tr><tr><td style="text-align:left">变量 Field</td><td style="text-align:left">Class.getFields( ) Class.getDeclaredFields( )</td><td style="text-align:left">getFields() 获取这个类和它父类的 public 成员变量; getDeclaredFields() 获取这个类和它父类的全部成员变量</td></tr></tbody></table><h3 id="1-通过反射创建类-Constructor"><a href="#1-通过反射创建类-Constructor" class="headerlink" title="1.  通过反射创建类 Constructor"></a>1.  通过反射创建类 Constructor</h3><h4 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"类的路径"</span>);</span><br><span class="line">Constructor constructor = cl.getConstructor();</span><br><span class="line">Object object = constructor.newInstance();</span><br></pre></td></tr></table></figure><h4 id="有参构造"><a href="#有参构造" class="headerlink" title="有参构造"></a>有参构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class classType = Class.forName(classPath);</span><br><span class="line">Constructor constructor = classType.getConstructor(intArgsClass);</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);  <span class="comment">// 压制 java 检查，防止当构造函数时 private 时拿不到</span></span><br><span class="line">Object object = constructor.newInstance(intArgs);</span><br></pre></td></tr></table></figure><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>getConstructor（Class[]）Class[] 是构造函数参数类型</li></ul><blockquote><p>例如 Employee(String name, long salary), 则  Class[] 就是 new Class[]{String.class, long.class}</p></blockquote><ul><li>onstructor.newInstance(Object[]) Object[] 是构造函数的具体参数值</li></ul><blockquote><p>例如 Employee(String name, long salary) 则 Object[] 就是 new Object[]{“张三”, 5000}</p></blockquote><ul><li>如果是无参构造函数使用 Class.newInstance( ) 即可，可不用反射</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="调用了无参构造函数"><a href="#调用了无参构造函数" class="headerlink" title="调用了无参构造函数"></a>调用了无参构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">createEmployeeByClassPath</span><span class="params">(String classPath)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class cl = Class.forName(classPath);</span><br><span class="line">        Constructor constructor = cl.getConstructor();</span><br><span class="line">        Object object = constructor.newInstance();</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="如果是-private-的构造函数"><a href="#如果是-private-的构造函数" class="headerlink" title="如果是 private 的构造函数"></a>如果是 private 的构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 private 的构造函数</span></span><br><span class="line">Class cl = Class.forName(classPath);</span><br><span class="line">Constructor constructor = cl.getDeclaredConstructor();</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);           </span><br><span class="line">Object object = constructor.newInstance();</span><br></pre></td></tr></table></figure><h5 id="调用有参构造函数"><a href="#调用有参构造函数" class="headerlink" title="调用有参构造函数"></a>调用有参构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createEmployeeByConstructor</span><span class="params">(String classPath, Class[] intArgsClass, Object[] intArgs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class classType = Class.forName(classPath);</span><br><span class="line">        Constructor constructor = classType.getConstructor(intArgsClass);</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);  <span class="comment">// 压制 java 检查，防止当构造函数时 private 时拿不到</span></span><br><span class="line">        Object object = constructor.newInstance(intArgs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-通过反射调用方法-Method"><a href="#2-通过反射调用方法-Method" class="headerlink" title="2.通过反射调用方法 Method"></a>2.通过反射调用方法 Method</h3><h4 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class.getMethods() 返回自身和父类的方法</span><br><span class="line">Class.getDeclaredMethods() 只返回自身的方法</span><br></pre></td></tr></table></figure><h4 id="获取指定的方法"><a href="#获取指定的方法" class="headerlink" title="获取指定的方法"></a>获取指定的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// methodName 是方法名，intArgsClass 是方法签名参数类型</span></span><br><span class="line">Method method = clazz.getDeclaredMethod(methodName, intArgsClass);</span><br></pre></td></tr></table></figure><h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method.invoke(Object, intArgs) <span class="comment">// intArgs 是具体的参数类型</span></span><br></pre></td></tr></table></figure><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><h5 id="获取方法-1"><a href="#获取方法-1" class="headerlink" title="获取方法"></a>获取方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getMethods</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取所有方法，包括父类的</span></span><br><span class="line">    Method[] methods = object.getClass().getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods)&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"getMethods method "</span> + method.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 至获取自身定义的方法</span></span><br><span class="line">    Method[] methods1 = object.getClass().getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods1)&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"getMethods method "</span> + method.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="调用方法-1"><a href="#调用方法-1" class="headerlink" title="调用方法"></a>调用方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反射调用方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeMethod</span><span class="params">(Object object, String methodName, Class[] intArgsClass, Object[] intArgs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class clazz =  object.getClass();</span><br><span class="line">        Method method = clazz.getDeclaredMethod(methodName, intArgsClass);</span><br><span class="line">        method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object returnValue = method.invoke(object, intArgs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-通过反射获取成员变量-Field"><a href="#3-通过反射获取成员变量-Field" class="headerlink" title="3. 通过反射获取成员变量 Field"></a>3. 通过反射获取成员变量 Field</h3><h4 id="获取-Field"><a href="#获取-Field" class="headerlink" title="获取 Field"></a>获取 Field</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fields[] fields = Class.getFields()  <span class="comment">// 获取这个类和它父类的 public 成员变量</span></span><br><span class="line">Fields[] fields = Class.getDeclaredFields()  <span class="comment">//获取这个类和它父类的全部成员变量</span></span><br></pre></td></tr></table></figure><h4 id="设置成员变量的值"><a href="#设置成员变量的值" class="headerlink" title="设置成员变量的值"></a>设置成员变量的值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class.getDeclaredField(fieldName) <span class="comment">// 获取具体的成员变量</span></span><br><span class="line">Field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Field.set(object, value) <span class="comment">// 设值</span></span><br></pre></td></tr></table></figure><h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><h5 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取成员变量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getFields</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">    Field[] fields = object.getClass().getFields();</span><br><span class="line">    <span class="keyword">for</span> (Field field : fields)&#123;</span><br><span class="line">        Class type = field.getType();</span><br><span class="line">        String name = field.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取具体的成员变量"><a href="#获取具体的成员变量" class="headerlink" title="获取具体的成员变量"></a>获取具体的成员变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getField</span><span class="params">(Object object, String fieldName)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Field field = object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object fieldVale = field.get(object);</span><br><span class="line">        String name = (String) fieldVale;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="设置成员变量的值-1"><a href="#设置成员变量的值-1" class="headerlink" title="设置成员变量的值"></a>设置成员变量的值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Field field = object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-获取注解"><a href="#4-获取注解" class="headerlink" title="4. 获取注解"></a>4. 获取注解</h3><p>Metho, Field, Constructor 都可以直接调用getAnnotationgetAnnotation(Class&lt;&gt; annotationType) 获取</p><blockquote><p>使用注解的开源库都会用到 EeventBus, ARouter 等</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAnnotationMethod</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">    Method[] methods = object.getClass().getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method: methods)&#123;</span><br><span class="line">        MyAnnotation annoType = method.getAnnotation(MyAnnotation.class);</span><br><span class="line">        <span class="keyword">if</span> (annoType != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Log.i(TAG, <span class="string">"getAnnotationMethod name = "</span> + method.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-获取修饰符"><a href="#5-获取修饰符" class="headerlink" title="5.获取修饰符"></a>5.获取修饰符</h3><p>Metho, Field, Constructor 都可以直接调用 getModifier() 获取<br>Modifier 这个类可以分析这个返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getModifiers</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">    Field[] fields1 = object.getClass().getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field field : fields1)&#123;</span><br><span class="line">        Class type = field.getType();</span><br><span class="line">        String name = field.getName();</span><br><span class="line">        printModifier(name, field.getModifiers());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printModifier</span><span class="params">(String name, <span class="keyword">int</span> modifier)</span></span>&#123;</span><br><span class="line">    String modifiers = Modifier.toString(modifier);</span><br><span class="line">    <span class="keyword">boolean</span> isFinal = Modifier.isFinal(modifier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h4><h4 id="setAccessible-true"><a href="#setAccessible-true" class="headerlink" title="setAccessible(true)"></a>setAccessible(true)</h4><p>Metho, Field, Constructor 都可以设置 setAccessible(true)，  压制 java 检查，防止 private 时拿不到</p><h4 id="getConstructor-与-getDeclaredConstructor-的区别"><a href="#getConstructor-与-getDeclaredConstructor-的区别" class="headerlink" title="getConstructor 与 getDeclaredConstructor 的区别"></a>getConstructor 与 getDeclaredConstructor 的区别</h4><ul><li>getDeclaredConstructor 可以返回 private 的构造函数，但是需要 Constructor.setAccessible(true)， 配合一起使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class cl = Class.forName(classPath);</span><br><span class="line">Constructor constructor = cl.getDeclaredConstructor();</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object object = constructor.newInstance();</span><br></pre></td></tr></table></figure><ul><li>getConstructor 只是返回 public 的构造函数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class cl = Class.forName(classPath);</span><br><span class="line">Constructor constructor = cl.getConstructor();</span><br><span class="line">Object object = constructor.newInstance();</span><br></pre></td></tr></table></figure><h3 id="7-完整的示例代码"><a href="#7-完整的示例代码" class="headerlink" title="7.完整的示例代码"></a>7.完整的示例代码</h3><p>ReflectActivity.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反射的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ReflectActivity"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLASS_PATH = <span class="string">"com.yxhuang.myapplication.reflect.Employee"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Employee mEmployee;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_reflect);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        createEmployeeByConstructor(CLASS_PATH, new Class[]&#123;String.class, long.class&#125;, new Object[]&#123;"张三", 5000&#125;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        Object object =  createEmployeeByClassPath(CLASS_PATH);</span></span><br><span class="line"><span class="comment">//        getMethods(object);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        invokeMethod(object, "setName", new Class[]&#123;String.class&#125;, new Object[]&#123;"李四"&#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        mEmployee = new Employee("李四", 5000, 22);</span></span><br><span class="line"><span class="comment">//        mEmployee.setAddress("广东");</span></span><br><span class="line"><span class="comment">//        getFields(mEmployee);</span></span><br><span class="line"><span class="comment">//        getField(mEmployee, "mName");</span></span><br><span class="line"><span class="comment">//        setFieldValue(mEmployee, "mName", "张三");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        getAnnotationMethod(mEmployee);</span></span><br><span class="line"></span><br><span class="line">        classInstance();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用了无参构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">createEmployeeByClassPath</span><span class="params">(String classPath)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class cl = Class.forName(classPath);</span><br><span class="line">            Constructor constructor = cl.getConstructor();</span><br><span class="line">            Object object = constructor.newInstance();</span><br><span class="line">            Employee employee = (Employee) object;</span><br><span class="line">            Log.i(TAG, <span class="string">"createEmployeeByClassPath "</span> + employee.toString());</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Log.e(TAG, <span class="string">"Error"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 private 的构造函数</span></span><br><span class="line"><span class="comment">//        Class cl = Class.forName(classPath);</span></span><br><span class="line"><span class="comment">//        Constructor constructor = cl.getDeclaredConstructor();</span></span><br><span class="line"><span class="comment">//        constructor.setAccessible(true);</span></span><br><span class="line"><span class="comment">//        Object object = constructor.newInstance();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用有参构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createEmployeeByConstructor</span><span class="params">(String classPath, Class[] intArgsClass, Object[] intArgs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class classType = Class.forName(classPath);</span><br><span class="line">            Constructor constructor = classType.getConstructor(intArgsClass);</span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);  <span class="comment">// 压制 java 检查，防止当构造函数时 private 时拿不到</span></span><br><span class="line">            Object object = constructor.newInstance(intArgs);</span><br><span class="line">            Employee employee = (Employee) object;</span><br><span class="line"></span><br><span class="line">            Log.i(TAG, <span class="string">"createEmployeeByConstructor "</span> + employee.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Log.e(TAG, <span class="string">"createEmployeeByConstructor error "</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getMethods</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 获取所有方法，包括父类的</span></span><br><span class="line">        Method[] methods = object.getClass().getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods)&#123;</span><br><span class="line">            Log.i(TAG, <span class="string">"getMethods method "</span> + method.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">" ----------------------------------------"</span>);</span><br><span class="line">        <span class="comment">// 至获取自身定义的方法</span></span><br><span class="line">        Method[] methods1 = object.getClass().getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods1)&#123;</span><br><span class="line">            Log.i(TAG, <span class="string">"getMethods method "</span> + method.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反射调用方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeMethod</span><span class="params">(Object object, String methodName, Class[] intArgsClass, Object[] intArgs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz =  object.getClass();</span><br><span class="line">            Method method = clazz.getDeclaredMethod(methodName, intArgsClass);</span><br><span class="line">            method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object returnValue = method.invoke(object, intArgs);</span><br><span class="line">            Log.i(TAG, <span class="string">"invokeMethod returnValue "</span>);</span><br><span class="line">            print(object);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Log.e(TAG, <span class="string">"invokeMethod error "</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getFields</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        Field[] fields = object.getClass().getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields)&#123;</span><br><span class="line">            Class type = field.getType();</span><br><span class="line">            String name = field.getName();</span><br><span class="line">            Log.i(TAG, <span class="string">" getFields type= "</span> + type + <span class="string">"  name= "</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">" ----------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取方法的标识符</span></span><br><span class="line">        Field[] fields1 = object.getClass().getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields1)&#123;</span><br><span class="line">            Class type = field.getType();</span><br><span class="line">            String name = field.getName();</span><br><span class="line">            Log.i(TAG, <span class="string">" getFields type= "</span> + type + <span class="string">"  name= "</span> + name);</span><br><span class="line">            printModifier(name, field.getModifiers());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取具体的成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getField</span><span class="params">(Object object, String fieldName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field field = object.getClass().getDeclaredField(fieldName);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object fieldVale = field.get(object);</span><br><span class="line">            String name = (String) fieldVale;</span><br><span class="line">            Log.i(TAG, <span class="string">" getField name= "</span> + name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Log.i(TAG, <span class="string">" getField error= "</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置成员变量的值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span></span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"before set field "</span>);</span><br><span class="line">        print(object);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field field = object.getClass().getDeclaredField(fieldName);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            field.set(object, value);</span><br><span class="line"></span><br><span class="line">            Log.i(TAG, <span class="string">"after set field ---- "</span>);</span><br><span class="line">            print(object);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Log.i(TAG, <span class="string">" getField error= "</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取注解的</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAnnotationMethod</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        Method[] methods = object.getClass().getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method: methods)&#123;</span><br><span class="line">            MyAnnotation annoType = method.getAnnotation(MyAnnotation.class);</span><br><span class="line">            <span class="keyword">if</span> (annoType != <span class="keyword">null</span>)&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"getAnnotationMethod name = "</span> + method.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        Employee employee = (Employee) object;</span><br><span class="line">        Log.i(TAG, <span class="string">"print "</span> + employee.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printModifier</span><span class="params">(String name, <span class="keyword">int</span> modifier)</span></span>&#123;</span><br><span class="line">        String modifiers = Modifier.toString(modifier);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> isFinal = Modifier.isFinal(modifier);</span><br><span class="line">        Log.i(TAG, <span class="string">"name = "</span> + name + <span class="string">" modifier= "</span> + modifiers + <span class="string">" isFinal= "</span> + isFinal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不是用反射</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">classInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Employee employee  =  Employee.class.newInstance();</span><br><span class="line">            Log.i(TAG, <span class="string">"classInstance "</span> + employee.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Employee.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yxhuang</span></span><br><span class="line"><span class="comment"> * Date: 2018/11/10</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"Employee"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mSalary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String mAddress;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">20</span>);</span><br><span class="line">        Log.i(TAG, <span class="string">"调用 Employee 无参构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">long</span> salary, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(age);</span><br><span class="line">        mName = name;</span><br><span class="line">        mSalary = salary;</span><br><span class="line">        Log.i(TAG, <span class="string">"调用 Employee 有参参构造函数 name= "</span> + name + <span class="string">" salary= "</span> + salary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"set name "</span> + name);</span><br><span class="line">        mName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mSalary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">long</span> salary)</span> </span>&#123;</span><br><span class="line">        mSalary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        mAddress = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Employee&#123;"</span> +</span><br><span class="line">                <span class="string">"mName='"</span> + mName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", mSalary="</span> + mSalary +</span><br><span class="line">                <span class="string">", mAag="</span> + mAag +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> mAag;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> aag)</span> </span>&#123;</span><br><span class="line">        mAag = aag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyAnnotation.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#Java 反射&lt;br&gt;Java 反射是在 java.lang.reflect 包类，包含 Constructor、Method、Field 的反射。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;域&lt;/th&gt;
&lt;
      
    
    </summary>
    
    
      <category term="java" scheme="https://yxhuangch.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java 注解</title>
    <link href="https://yxhuangch.github.io/2018/09/12/java-annotation/"/>
    <id>https://yxhuangch.github.io/2018/09/12/java-annotation/</id>
    <published>2018-09-12T15:15:22.000Z</published>
    <updated>2018-09-12T15:22:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-注解"><a href="#Java-注解" class="headerlink" title="Java 注解"></a>Java 注解</h2><p>了解 Java 注解，对于我们了解 JavaPoet, ARouter, Butterknife 这些开源库是必须的。<br>同时也可以结合 Android 中独有的注解，一起看，会加深理解。我之前写过<br><a href="https://blog.csdn.net/yxhuang2008/article/details/71330637" target="_blank" rel="noopener">Android 中的注解</a> 一文。</p><p>以下是正题：</p><p>注解是那些插入到源码中使用其他工具可以对其进行处理的便签。这些工具可以在源码层次上进线操作，或者可以出来编译在其中放置了注解的类文件。</p><p>This allows annotations to be retained by Java VM at run-time and read via reflection。[1]</p><p>Annotation are tags or meta-data, which can be inserted in to source code. So that it could be process at runtime and can take decision according to that annotations。[2]</p><h3 id="1-注解的语法"><a href="#1-注解的语法" class="headerlink" title="1. 注解的语法"></a>1. 注解的语法</h3><p>注解是由注解接口定义的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">modifiers <span class="meta">@interface</span> AnnotationName&#123;</span><br><span class="line">    <span class="function">type <span class="title">elementName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//或者</span></span><br><span class="line">    <span class="function">type <span class="title">elementName</span><span class="params">()</span> <span class="keyword">default</span> value</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BugReport&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">severity</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function">String <span class="title">assignedTo</span><span class="params">()</span> <span class="keyword">default</span> "[none]"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-注解的类型"><a href="#2-注解的类型" class="headerlink" title="2. 注解的类型"></a>2. 注解的类型</h3><table><thead><tr><th>用于编译的注解</th><th>作用</th></tr></thead><tbody><tr><td>@Deprecated</td><td>用于不再鼓励使用的项</td></tr><tr><td>@SuppressWarning</td><td>阻止某个给定类型的警告信息</td></tr><tr><td>@Override</td><td>检查改方法是否覆盖了某一个超类方法</td></tr><tr><td>@Generated</td><td>作为代码生成工具使用</td></tr></tbody></table><p><br></p><table><thead><tr><th>用于管理资源的注解</th><th>作用</th></tr></thead><tbody><tr><td>@PostConstruct</td><td>被标记的方法应该在构造之后立即被调用</td></tr><tr><td>@PreDestroy</td><td>被标记的方法应该在被移除之前立即被调用</td></tr><tr><td>@Resource</td><td>用于资源的注入</td></tr></tbody></table><p><br></p><table><thead><tr><th>元注解</th><th>作用</th></tr></thead><tbody><tr><td>@Target</td><td>指明可以应用这个注解的那些项</td></tr><tr><td>@Retention</td><td>指明这个注解可以保留多久</td></tr><tr><td>@Documented</td><td>指明这个注解应该包含在注解项的文档中</td></tr><tr><td>@Inherited</td><td>指明这个注解应用与一个类的时候，能够自动被它的子类继承</td></tr></tbody></table><p><br></p><h5 id="Target-注解的元素类型"><a href="#Target-注解的元素类型" class="headerlink" title="@Target 注解的元素类型"></a>@Target 注解的元素类型</h5><table><thead><tr><th>元素类型</th><th>注解适用场合</th></tr></thead><tbody><tr><td>TYPE</td><td>类（包括 enum）及接口（包括注解类型）</td></tr><tr><td>ANNOTATION_TYPE</td><td>注解类型声明</td></tr><tr><td>PACKAGE</td><td>包</td></tr><tr><td>METHOD</td><td>方法</td></tr><tr><td>CONSTRUTOR</td><td>构造器</td></tr><tr><td>FIELD</td><td>成员域（包括 enum 常量）</td></tr><tr><td>PARAMETER</td><td>方法或构造参数</td></tr><tr><td>LOCAL_VARIABLE</td><td>局部变量</td></tr></tbody></table><p><br></p><h5 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h5><p>用于指定一条注解应该保留多长时间</p><table><thead><tr><th>保留规则</th><th>描述</th></tr></thead><tbody><tr><td>SOURCE</td><td>不包括在类文件中的注解</td></tr><tr><td>CLASS</td><td>包括在类文件中的注解，但是虚拟机不需要将它们载入</td></tr><tr><td>RUNTIME</td><td>包括在类文件中的注解，并由虚拟机载入。通过反射API 可获得它们</td></tr></tbody></table><p>例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ActionListener &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-注解处理器类库"><a href="#3-注解处理器类库" class="headerlink" title="3. 注解处理器类库"></a>3. 注解处理器类库</h3><h5 id="1-java-lang-reflectAnnotatedElement"><a href="#1-java-lang-reflectAnnotatedElement" class="headerlink" title="1. java.lang.reflectAnnotatedElement"></a>1. java.lang.reflectAnnotatedElement</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAnnotationPresent</span><span class="params">(Class&lt;? extends Annotation&gt; annotationType)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果该项具有给定类型的注解，则返回 true</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">&lt;T extends Annotation&gt; T <span class="title">getAnnotation</span><span class="params">(Class&lt;T&gt; annotationType)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取给定类型的注解, 如果垓项目不具有这样的注解，则返回 Null</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">Annotation[] <span class="title">getAnnotation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取该项的所有注解，包括继承而来的注解.如果没有出现任何注解，则返回一个长度为 0 的数组</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">Annotation[] <span class="title">getDeclaredAnnotation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取该项的所有注解，不包括继承而来的注解.如果没有出现任何注解，则返回一个长度为 0 的数组</span></span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; testClass = Class.forName(className);</span><br><span class="line">    Object object = testClass.newInstance();</span><br><span class="line">    Method[] methods = testClass.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods)&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(Test.class))&#123;</span><br><span class="line">            Test annotation = method.getAnnotation(Test.class);</span><br><span class="line">            Class&lt;? extends Exception&gt; expectedClass = annotation.Expected();</span><br><span class="line">            <span class="keyword">if</span> (expectedClass != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    method.invoke(object);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.getTargetException().getClass() == expectedClass)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Test Case Pass With Custom Exception"</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-AbstractProcessor"><a href="#2-AbstractProcessor" class="headerlink" title="2. AbstractProcessor"></a>2. AbstractProcessor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoService</span>(Processor.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Filer mFiler;</span><br><span class="line">    <span class="keyword">private</span> Elements mElementUtils;</span><br><span class="line">    <span class="keyword">private</span> Messager mMessager;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(processingEnvironment);</span><br><span class="line"></span><br><span class="line">        mFiler = processingEnv.getFiler();</span><br><span class="line">        mElementUtils = processingEnv.getElementUtils();</span><br><span class="line">        mMessager = processingEnv.getMessager();</span><br><span class="line"></span><br><span class="line">        mGenerationClass = <span class="keyword">new</span> GenerationClass();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SourceVersion.latestSupported();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(MyAnnotation.class.getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4.参考资料"></a>4.参考资料</h4><ol><li>Wiki 中的 <a href="https://en.wikipedia.org/wiki/Java_annotation" target="_blank" rel="noopener">Java annotation</a>；</li><li>《Java 核心技术 卷 II 》第十章 注解部分；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java-注解&quot;&gt;&lt;a href=&quot;#Java-注解&quot; class=&quot;headerlink&quot; title=&quot;Java 注解&quot;&gt;&lt;/a&gt;Java 注解&lt;/h2&gt;&lt;p&gt;了解 Java 注解，对于我们了解 JavaPoet, ARouter, Butterknife 这
      
    
    </summary>
    
    
      <category term="java" scheme="https://yxhuangch.github.io/tags/java/"/>
    
  </entry>
  
</feed>
