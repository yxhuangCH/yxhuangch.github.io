<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yxhuang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yxhuangch.github.io/"/>
  <updated>2022-05-29T09:13:04.235Z</updated>
  <id>https://yxhuangch.github.io/</id>
  
  <author>
    <name>yxhuang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Koltin 协程 (二)</title>
    <link href="https://yxhuangch.github.io/2022/05/29/kotlin-coroutine-two/"/>
    <id>https://yxhuangch.github.io/2022/05/29/kotlin-coroutine-two/</id>
    <published>2022-05-29T09:09:35.000Z</published>
    <updated>2022-05-29T09:13:04.235Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="3-协程的整个配套体系"><a href="#3-协程的整个配套体系" class="headerlink" title="3. 协程的整个配套体系"></a>3. 协程的整个配套体系</h2><h3 id="3-1-启动流程"><a href="#3-1-启动流程" class="headerlink" title="3.1 启动流程"></a>3.1 启动流程</h3><p><img src="/2022/05/29/kotlin-coroutine-two/kotlin_corotinue_3.png"></p><p>说明：<br>SuspendLambda 是协程体类对象，封装协程体的操作</p><p>继承关系<br>SuspendLambda –&gt; ContinuationImpl –&gt; BaseContinuationImpl</p><p>①</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> actual <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="params">(suspend R.()</span></span> -&gt; T).createCoroutineUnintercepted(</span><br><span class="line">    receiver: R,</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> probeCompletion = probeCoroutineCreated(completion)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> BaseContinuationImpl)</span><br><span class="line">        create(receiver, probeCompletion) <span class="comment">// 调用生成代码里面的 create</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        createCoroutineFromSuspendFunction(probeCompletion) &#123;</span><br><span class="line">            (<span class="keyword">this</span> <span class="keyword">as</span> Function2&lt;R, Continuation&lt;T&gt;, Any?&gt;).invoke(receiver, it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(@NotNull String[] args)</span> </span>&#123;</span><br><span class="line">     Intrinsics.checkParameterIsNotNull(args, <span class="string">"args"</span>);</span><br><span class="line">     BuildersKt.launch$<span class="keyword">default</span>((CoroutineScope)GlobalScope.INSTANCE, (CoroutineContext)<span class="keyword">null</span>, (CoroutineStart)<span class="keyword">null</span>, (Function2)(<span class="keyword">new</span> Function2((Continuation)<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> label;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// BaseContinuationImpl 的 invokeSuspend() 调用</span></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">invokeSuspend</span><span class="params">(@NotNull Object $result)</span> </span>&#123;</span><br><span class="line">           Object var2 = IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">           <span class="keyword">switch</span>(<span class="keyword">this</span>.label) &#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">              ResultKt.throwOnFailure($result);</span><br><span class="line">              Item var10000 = <span class="keyword">new</span> Item();</span><br><span class="line">              <span class="keyword">this</span>.label = <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">if</span> (CoroutineKt.postItem(var10000, <span class="keyword">this</span>) == var2) &#123;</span><br><span class="line">                 <span class="keyword">return</span> var2;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">              ResultKt.throwOnFailure($result);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"call to 'resume' before 'invoke' with coroutine"</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> Unit.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 调用到这里的 create 方法</span></span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Continuation <span class="title">create</span><span class="params">(@Nullable Object value, @NotNull Continuation completion)</span> </span>&#123;</span><br><span class="line">           Intrinsics.checkParameterIsNotNull(completion, <span class="string">"completion"</span>);</span><br><span class="line">           Function2 var3 = <span class="keyword">new</span> &lt;anonymous constructor&gt;(completion);</span><br><span class="line">           <span class="keyword">return</span> var3;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">invoke</span><span class="params">(Object var1, Object var2)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> ((&lt;undefinedtype&gt;)<span class="keyword">this</span>.create(var1, (Continuation)var2)).invokeSuspend(Unit.INSTANCE);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;), <span class="number">3</span>, (Object)<span class="keyword">null</span>).start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>② CoroutineScheduler 是个线程池</p><p>BaseContinuationImpl 的 resumeWith() 会调用 invokeSuspend() 函数， invokeSuspend() 会调用生成协程体的 invokeSuspend()</p><h3 id="3-2-协程体系"><a href="#3-2-协程体系" class="headerlink" title="3.2 协程体系"></a>3.2 协程体系</h3><p>根据个人的理解将整个协程体系分为 Core, 调度部分，管理协程生命周期，启动模式四部分，这样的划分不一定正确，只是为了更加方便理解协程而划分的。</p><p><img src="/2022/05/29/kotlin-coroutine-two/kotlin_corotine_4.png"></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseContinuationImpl</span></span>(</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> completion: Continuation&lt;Any?&gt;?</span><br><span class="line">) : Continuation&lt;Any?&gt;, CoroutineStackFrame, Serializable &#123;</span><br><span class="line">    <span class="comment">// This implementation is final. This fact is used to unroll resumeWith recursion.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">// This loop unrolls recursion in current.resumeWith(param) to make saner and shorter stack traces on resume</span></span><br><span class="line">        <span class="keyword">var</span> current = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">var</span> param = result</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            probeCoroutineResumed(current)</span><br><span class="line">            with(current) &#123;</span><br><span class="line">                <span class="keyword">val</span> completion = completion!!</span><br><span class="line">                <span class="keyword">val</span> outcome: Result&lt;Any?&gt; =</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 调用 invokeSuspend 函数， 协程体真正执行</span></span><br><span class="line">                        <span class="keyword">val</span> outcome = invokeSuspend(param) </span><br><span class="line">                        <span class="comment">//// invokeSuspend方法返回值为COROUTINE_SUSPENDED，resumeWith方法被return，结束执行，说明执行了</span></span><br><span class="line">                        <span class="keyword">if</span> (outcome === COROUTINE_SUSPENDED) <span class="keyword">return</span></span><br><span class="line">                        Result.success(outcome)</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (exception: Throwable) &#123;</span><br><span class="line">                        Result.failure(exception)</span><br><span class="line">                    &#125;</span><br><span class="line">                releaseIntercepted()</span><br><span class="line">                <span class="keyword">if</span> (completion <span class="keyword">is</span> BaseContinuationImpl) &#123;</span><br><span class="line">                    current = completion</span><br><span class="line">                    param = outcome</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    completion.resumeWith(outcome)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这会调用协程体的 invokeSuspend 函数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">invokeSuspend</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span>: Any?</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-async-await"><a href="#3-3-async-await" class="headerlink" title="3.3 async / await"></a>3.3 async / await</h3><p> 使用 async 可以让 supend 函数并发执行，减少整个函数的执行时间</p><h3 id="3-5-挂起和恢复"><a href="#3-5-挂起和恢复" class="headerlink" title="3.5 挂起和恢复"></a>3.5 挂起和恢复</h3><p>挂起的本质是切线程，并且在相应的逻辑处理完成之后再重新切回线程。</p><p>挂起函数内执行挂起操作的时候会返回 coroutine_suspended 标志，结束协程体的运行，使协程挂起。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;3-协程的整个配套体系&quot;&gt;&lt;a href=&quot;#3-协程的整个配套体系&quot; class=&quot;headerlink&quot; title=&quot;3. 协程的整个配套体系&quot;&gt;&lt;/a&gt;3. 协程的整个配套体系&lt;/h2&gt;&lt;h3 id=&quot;3-1-启动流程&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="kotlin" scheme="https://yxhuangch.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 协程 (一)</title>
    <link href="https://yxhuangch.github.io/2022/05/29/kotlin-coroutine-one/"/>
    <id>https://yxhuangch.github.io/2022/05/29/kotlin-coroutine-one/</id>
    <published>2022-05-29T09:06:29.000Z</published>
    <updated>2022-05-29T09:09:15.658Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="学习前的疑问："><a href="#学习前的疑问：" class="headerlink" title="学习前的疑问："></a>学习前的疑问：</h2><ol><li>为什么需要协程，它解决了什么问题</li><li>协程的原理是怎样的</li><li>协程的优点和缺点是什么</li><li>协程的整个配套体系是怎样的</li><li>与其他语言，例如Go, 相比，Kotlin 的协程有什么差别</li></ol><h2 id="1-为什么需要协程，它解决了什么问题"><a href="#1-为什么需要协程，它解决了什么问题" class="headerlink" title="1. 为什么需要协程，它解决了什么问题"></a>1. 为什么需要协程，它解决了什么问题</h2><ul><li>用同步代码解决异步问题</li><li>使用挂起和恢复的方式，替代了回调</li></ul><h3 id="1-1-用同步代码解决异步问题"><a href="#1-1-用同步代码解决异步问题" class="headerlink" title="1.1 用同步代码解决异步问题"></a>1.1 用同步代码解决异步问题</h3><p><strong>回调方式</strong></p><p>平时我们做异步操作，例如网络、 IO ，这里耗时的操作，一般是通过 callback 的方式，这样可以避免在主线程中的阻塞。</p><p>通过下面的示例代码说明：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(item: <span class="type">Item</span>)</span></span>&#123;</span><br><span class="line">    requestToken(<span class="keyword">object</span> :ITokenCallback&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onToken</span><span class="params">(token: <span class="type">Token</span>)</span></span> &#123; <span class="comment">// 回调</span></span><br><span class="line">            createPost(token, item, <span class="keyword">object</span> :ICreatePostCallback&#123;  <span class="comment">// 回调</span></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPost</span><span class="params">(post: <span class="type">Post</span>)</span></span> &#123;</span><br><span class="line">                    processPost(post)  <span class="comment">// 处理最终结果</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例代码中，</p><ul><li><ol><li><code>requestToken</code> 通过 <code>ITokenCallback</code> 回调 Token, </li></ol></li><li><ol start="2"><li>然后再将这个 token 给 <code>createPost</code>函数作为参数，同时传入 <code>ICreatePostCallback</code> 回调</li></ol></li><li><ol start="3"><li>createPost 通过回调返回 post, 然后将它作为参数调用 <code>processPost</code> 函数</li></ol></li></ul><p>在上面的例子，我们看看到通过回调的方式非常麻烦，一个个回调，如果回调多了，就会陷入回调地狱。</p><p>如果是用 kotlin 的协程，看看是怎样解决这个问题的。</p><p><strong>koltin 协程</strong><br>那我们看看协程是如何解决的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> token = requestToken()</span><br><span class="line">    <span class="keyword">val</span> post = createPost(token, item)</span><br><span class="line">    processPost(post)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">requestToken</span><span class="params">()</span></span>: Token &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">createPost</span><span class="params">(token: <span class="type">Token</span>, item: <span class="type">Item</span>)</span></span>: Post &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码使用协程的方式，对比用 callback 的异步,<strong>这种用同步代码的方式，解决了回调地狱的问题。</strong> 更近一步，还可以解决不同函数在不同线程的调用。<br>下面的代码就是将耗时的 <code>requestToken</code> 函数放到子线程中执行.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(item: <span class="type">Item</span>)</span></span> = withContext(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="comment">// 切换到 IO 线程中执行</span></span><br><span class="line">    <span class="keyword">val</span> token = withContext(Dispatchers.IO)&#123;</span><br><span class="line">        requestToken()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> post = createPost(token, item)</span><br><span class="line">    processPost(post)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-使用挂起和恢复的方式，替代了回调"><a href="#1-2-使用挂起和恢复的方式，替代了回调" class="headerlink" title="1.2 使用挂起和恢复的方式，替代了回调"></a>1.2 使用挂起和恢复的方式，替代了回调</h3><p>协程的解决的另外一个问题，就是使用挂起和恢复的方式，替代了回调，</p><p>先看原来的代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">firebaseAuthWithGoogle</span><span class="params">(token: <span class="type">Token</span>, iTokenCallback: <span class="type">ITokenCallback</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> auth: FirebaseAuth = FirebaseAuth.getInstance()</span><br><span class="line">    <span class="keyword">val</span> credential = GoogleAuthProvider.getCredential(googleToken, <span class="literal">null</span>)</span><br><span class="line">    iTokenCallback.onToken(credential.token)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来的代码，使用 callback 的方式执行</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">firebaseAuthWithGoogle</span><span class="params">(token: <span class="type">Token</span>)</span></span> = suspendCoroutine &#123; continuation -&gt;</span><br><span class="line">    <span class="keyword">val</span> auth: FirebaseAuth = FirebaseAuth.getInstance()</span><br><span class="line">    <span class="keyword">val</span> credential = GoogleAuthProvider.getCredential(googleToken, <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">if</span> (credential != <span class="literal">null</span>)&#123;</span><br><span class="line">        continuation.resumeWith(credential.token)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        continuation.resumeWithException(IllegalArgumentException(<span class="string">"firebaseAuthWithGoogle googleToken is wrong"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们指定 kotlin 协程可以解决的两个问题</p><ul><li><ol><li>用同步代码解决异步问题</li></ol></li><li><ol start="2"><li>使用挂起和恢复的方式，替代了回调</li></ol></li></ul><p>那下面我们要看看 koltin 是怎样做到的，那就是它的原理是怎样的。</p><h2 id="2-协程的原理"><a href="#2-协程的原理" class="headerlink" title="2. 协程的原理"></a>2. 协程的原理</h2><p>在讲述协程原理之前，先讲述一些基本知识做铺垫，包含</p><ul><li>高阶函数</li><li>CPS, 既 Continuation-Passing Style</li><li>CDS，既 Coroutines Direct Style</li></ul><h3 id="2-1-高阶函数"><a href="#2-1-高阶函数" class="headerlink" title="2.1 高阶函数"></a>2.1 高阶函数</h3><p>高阶函数就是将函数作为参数或者返回值是函数的函数。<br>这就话有些拗口，可以拆成两部分：</p><ul><li>第一种情况是函数作为参数</li><li>第二种情况是返回值是函数</li></ul><p>通过下面的实例代码进行说明</p><p><strong>函数作为参数的情况</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">highFunction</span><span class="params">(block:()</span></span> -&gt;<span class="built_in">Unit</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(Debug.isTest)&#123;</span><br><span class="line">        block.invoke()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFunction</span><span class="params">(post: <span class="type">Post</span>)</span></span> &#123;</span><br><span class="line">    highFunction &#123; <span class="comment">// processPost(...) 函数作为参数</span></span><br><span class="line">        processPost(post)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>highFuction</code> 函数的参数是 <code>block:() -&gt;Unit</code> 它是一个函数</p><p><strong>返回值是函数的情况</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lock</span><span class="params">(lock: <span class="type">Lock</span>, body: ()</span></span> -&gt; T): T &#123;</span><br><span class="line">    lock.lock()    </span><br><span class="line"><span class="keyword">try</span> &#123;        </span><br><span class="line"><span class="keyword">return</span> body()</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码可以看到 return 的返回值是 <code>body()</code> 函数</p><p>通过上面的两个例子</p><h3 id="2-2-CPS"><a href="#2-2-CPS" class="headerlink" title="2.2 CPS"></a>2.2 CPS</h3><p>CPS 是 Continuation-Passing Style 的缩写， 是指一种代码风格，</p><p><strong>CPS</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">     requestToken&#123; token -&gt;</span><br><span class="line">         <span class="keyword">val</span> post = createPost(token, item)</span><br><span class="line">         processPost(post)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> post = createPost(token, item)</span><br><span class="line">processPost(post)</span><br></pre></td></tr></table></figure><p>是 Continuation, 这里使用了高阶函数。</p><p>这样的代码称为， CPS</p><h3 id="2-3-CDS"><a href="#2-3-CDS" class="headerlink" title="2.3 CDS"></a>2.3 CDS</h3><p>CDS 是 Coroutines Direct Style，就是直接用协程的方式。<br>看下来的d代码，用 CDS 的方式呈现。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(item: <span class="type">Item</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">val</span> token = requestToken()</span><br><span class="line">    <span class="keyword">val</span> post = createPost(token, item)</span><br><span class="line">    processPost(post)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了前面的铺垫，我们可以正式讲述协程的原理了。</p><h3 id="2-4-koltin-协程原理"><a href="#2-4-koltin-协程原理" class="headerlink" title="2.4 koltin 协程原理"></a>2.4 koltin 协程原理</h3><p>如果用 kotlin 协程的代码反编译成 java 代码，看到非常复杂，很难理解。<br>如果简单的老说，<strong>kotlin 协程的原理就是通过包装 callback, 同时利用状态机进行切换，实现函数的不同调用</strong>。</p><p>通过下面的例子进行说明。</p><p>协程的写法<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(item: <span class="type">Item</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">val</span> token = requestToken()</span><br><span class="line">    <span class="keyword">val</span> post = createPost(token, item)</span><br><span class="line">    processPost(post)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>kotlin 是如何实现让异步的代码用同步来表达的？</p><p><strong>第一种方式是把它变成 CPS 的代码风格</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(item: <span class="type">Item</span>)</span></span>  &#123;</span><br><span class="line">    requestToken&#123; token -&gt;</span><br><span class="line">        createPost(token, item)&#123; post -&gt;</span><br><span class="line">            processPost(post)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样能解决问题，但是它的缺点也是很明显，每个函数都会创建一个闭包，对内存有影响。</p><p><img src="/2022/05/29/kotlin-coroutine-one/kotlin_corotine_1.png"></p><p>如果是在一个循环里面，那就是回调地狱了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(items: <span class="type">List</span>&lt;<span class="type">Item</span>&gt;)</span></span>  &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果用状态机的型式就比较简单了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(items: <span class="type">List</span>&lt;<span class="type">Item</span>&gt;)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> items)&#123;</span><br><span class="line">        <span class="keyword">val</span> token = requestToken()</span><br><span class="line">        <span class="keyword">val</span> post = createPost(token, item)</span><br><span class="line">        processPost(post)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二种方式就是编译成状态机</strong><br>实际上 kotlin 也是编译成状态机的型式实现协程的原理</p><p>在介绍状态机之前，先看一下在 koltin 源码中的 <code>Continuation.kt</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Continuation</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWithException</span><span class="params">(exception: <span class="type">Throwable</span>)</span></span> <span class="comment">// 拓展函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Continuation 是一个接口，它其实就是一个回调。</p><p>原始代码<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(item: <span class="type">Item</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">val</span> token = requestToken()</span><br><span class="line">    <span class="keyword">val</span> post = createPost(token, item)</span><br><span class="line">    processPost(post)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用状态机的方式等效写法表示<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(items: <span class="type">Item</span>, cont: <span class="type">Continuation</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">val</span> sm = <span class="keyword">object</span> :CoroutineImpl(.., const)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">resume</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">            postItem(<span class="literal">null</span>, <span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swith(sm.label)&#123;</span><br><span class="line">        case <span class="number">0</span>:</span><br><span class="line">            sm.item = items</span><br><span class="line">            sm.label = <span class="number">1</span></span><br><span class="line">            requestToken(sm)</span><br><span class="line">        case <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">val</span> item  = sm.item</span><br><span class="line">            <span class="keyword">val</span> token = sm.result <span class="keyword">as</span> Token</span><br><span class="line">            sm.label = <span class="number">2</span></span><br><span class="line">            createPost(token, item, sm)</span><br><span class="line">        case <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">val</span> post = sm.result <span class="keyword">as</span> Post</span><br><span class="line">            processPost(post)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面进行详细的讲解：</p><ul><li><p>postItem 函数在在编译的时候，会生成一个<code>Continuation</code>作为参数传入进去。</p></li><li><p>在 postItem 里面会生成一个 <code>CoroutineImpl</code> 的对象。这个对象是 <code>Continuation</code> 的实现类，也带有 resume 方法和 label 变量。</p></li><li><p>当第一次调用 postItm 的时候，会在内部生成  <code>CoroutineImpl</code> 的对象，并且 sm.label 默认是 0， 于是进入了状态机的第 0 个状态。</p></li><li><p>在 case 0, 会将 items 作为参数赋值给 sm.item 同时将 label = 1，设置成状态机的下一个状态，然后调用 <code>requestToken</code> 函数， <code>CoroutineImpl</code> 作为参数。<code>requestToken</code> 函数完成后，会通过 <code>CoroutineImpl</code> 的 resume 方法调用 <code>postItem</code>。于是函数再一次到了 <code>postItem</code> 这个方法里面。</p></li><li><p>由于这次进来的 label 值是 1，会跳到 case 1 执行。<br>在 case 1 里面，通过 sm.result 取出在上一个状态 case 0 获取到的 token。将 label = 2 设置为下一个状态。token、item 和 sm 作为<code>createPost</code> 的参数传入进去执行。</p></li><li><p>这次进来的 label 值是2， 会跳到 case 2 中执行。<br>在 case 2 里面，通过 sm.result 获取到 <code>createPost</code> 执行的结果 token ,然后调用  <code>processPost</code> 函数。</p></li></ul><p>通过上面几步详细的讲解，我们知道<strong>kotlin 协程的原理就是通过包装 callback, 同时利用状态机进行切换，实现函数的不同调用</strong>。</p><p>如果仅仅通过反编译 kotlin 的字节码去看协程的原理的话，会发现是非常困难的，里面包含着太多不规则的命名变量和函数调用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.youtube.com/watch?v=YrrUCSi72E8" target="_blank" rel="noopener">Deep Dive into Coroutines on JVM</a></li><li><a href="https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md" target="_blank" rel="noopener">官方关于 kotlin 协程设计的文档</a></li><li><a href="https://blog.csdn.net/suyimin2010/article/details/91125803" target="_blank" rel="noopener">Kotlin 协程实现原理</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUyMDAxMjQ3Ng==&amp;mid=2247495170&amp;idx=1&amp;sn=b54e233699fd7bba0e940e2837258002&amp;chksm=f9f279d1ce85f0c741857443332c20a82caedc24d8ea798219c2098c2d09ee58e11a6aba9296&amp;mpshare=1&amp;scene=23&amp;srcid=1212Jz0IsITrVDTTTBRNCn0j&amp;sharer_sharetime=1607751713936&amp;sharer_shareid=65073698ab9ac2983b955fa53b4ff585%23rd" target="_blank" rel="noopener">硬核万字解读——Kotlin协程原理解析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;学习前的疑问：&quot;&gt;&lt;a href=&quot;#学习前的疑问：&quot; class=&quot;headerlink&quot; title=&quot;学习前的疑问：&quot;&gt;&lt;/a&gt;学习前的疑问：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;为什么需要协程，它解决了什么问题&lt;/li&gt;
&lt;li&gt;协程的原理
      
    
    </summary>
    
    
      <category term="kotlin" scheme="https://yxhuangch.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>PopupWindow 的 BadTokenException</title>
    <link href="https://yxhuangch.github.io/2022/01/22/popupwindow-badtokenexception/"/>
    <id>https://yxhuangch.github.io/2022/01/22/popupwindow-badtokenexception/</id>
    <published>2022-01-22T08:37:08.000Z</published>
    <updated>2022-01-22T08:44:37.280Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>PopupWindow 的 BadTokenException</p><p>2.0.0 版本出现这个崩溃</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Fatal Exception: android.view.WindowManager$BadTokenException: Unable to add window -- token null is not valid; is your activity running?</span><br><span class="line">       at android.view.ViewRootImpl.setView(ViewRootImpl.java:890)</span><br><span class="line">       at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:337)</span><br><span class="line">       at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:109)</span><br><span class="line">       at android.widget.PopupWindow.invokePopup(PopupWindow.java:1333)</span><br><span class="line">       at android.widget.PopupWindow.showAsDropDown(PopupWindow.java:1156)</span><br><span class="line">       at androidx.core.widget.PopupWindowCompat.showAsDropDown(PopupWindowCompat.java:69)</span><br><span class="line">       at com.dianyun.pcgo.gift.api.RelativePopupWindow.showOnAnchor(RelativePopupWindow.java:196)</span><br><span class="line">       at com.dianyun.pcgo.gift.api.RelativePopupWindow.showOnAnchor(RelativePopupWindow.java:133)</span><br><span class="line">       at com.dianyun.pcgo.gift.api.RelativePopupWindow.showOnAnchor(RelativePopupWindow.java:108)</span><br><span class="line">       at com.dianyun.pcgo.home.explore.discover.ui.HomeExploreTopRightView.showReceiveGiftTips(HomeExploreTopRightView.java:112)</span><br><span class="line">       at com.dianyun.pcgo.home.explore.discover.ui.HomeExploreTopRightView.access$showReceiveGiftTips(HomeExploreTopRightView.java:42)</span><br><span class="line">       at com.dianyun.pcgo.home.explore.discover.ui.HomeExploreTopRightView$startObserver$$inlined$apply$lambda$1.onChanged(HomeExploreTopRightView.java:81)</span><br><span class="line">       at com.dianyun.pcgo.home.explore.discover.ui.HomeExploreTopRightView$startObserver$$inlined$apply$lambda$1.onChanged(HomeExploreTopRightView.java:42)</span><br><span class="line">       at androidx.lifecycle.LiveData.considerNotify(LiveData.java:133)</span><br><span class="line">       at androidx.lifecycle.LiveData.dispatchingValue(LiveData.java:151)</span><br><span class="line">       at androidx.lifecycle.LiveData.setValue(LiveData.java:309)</span><br><span class="line">       at androidx.lifecycle.MutableLiveData.setValue(MutableLiveData.java:50)</span><br><span class="line">       at com.dianyun.pcgo.home.explore.HomeExploreMainViewModel$queryGiftObtainStatus$1.invokeSuspend(HomeExploreMainViewModel.java:91)</span><br><span class="line">       at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(BaseContinuationImpl.java:33)</span><br><span class="line">       at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.java:106)</span><br><span class="line">       at android.os.Handler.handleCallback(Handler.java:739)</span><br><span class="line">       at android.os.Handler.dispatchMessage(Handler.java:95)</span><br><span class="line">       at android.os.Looper.loop(Looper.java:148)</span><br></pre></td></tr></table></figure><h1 id="1-初步分析"><a href="#1-初步分析" class="headerlink" title="1 初步分析"></a>1 初步分析</h1><p>原始的代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">showReceiveGiftTips</span><span class="params">(tips: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    L.info(TAG, <span class="string">"showReceiveGiftTips tips <span class="variable">$tips</span>"</span>)</span><br><span class="line">    <span class="keyword">val</span> activity = getContextToActivity()</span><br><span class="line">    <span class="keyword">if</span> ((tips.isNotEmpty() &amp;&amp; mHomeReceiveGiftTipsPopupWindow == <span class="literal">null</span></span><br><span class="line">                    &amp;&amp; activity?.isFinishing == <span class="literal">false</span> &amp;&amp; !activity.isDestroyed) &amp;&amp; mVisibleToUser) &#123;</span><br><span class="line">        mHomeReceiveGiftTipsPopupWindow = HomeReceiveGiftTipsPopupWindow(context!!)</span><br><span class="line">        mHomeReceiveGiftTipsPopupWindow!!.setData(tips)</span><br><span class="line">        mHomeReceiveGiftTipsPopupWindow!!.showOnAnchor(</span><br><span class="line">                fl_gift,</span><br><span class="line">                RelativePopupWindow.VerticalPosition.BELOW,</span><br><span class="line">                RelativePopupWindow.HorizontalPosition.CENTER</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在找到抛出异常的地方</p><p>ViewRootImpl#setView</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * We have one child</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mView = view;</span><br><span class="line">              mAttachInfo.mDisplayState = mDisplay.getState();</span><br><span class="line">                mDisplayManager.registerDisplayListener(mDisplayListener, mHandler);</span><br><span class="line"></span><br><span class="line">                mViewLayoutDirectionInitial = mView.getRawLayoutDirection();</span><br><span class="line">                mFallbackEventHandler.setView(view);</span><br><span class="line">                mWindowAttributes.copyFrom(attrs);</span><br><span class="line">                <span class="keyword">if</span> (mWindowAttributes.packageName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mWindowAttributes.packageName = mBasePackageName;</span><br><span class="line">                &#125;</span><br><span class="line">                attrs = mWindowAttributes;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">              requestLayout();  &lt;--注意这里</span><br><span class="line">            </span><br><span class="line">              <span class="keyword">int</span> res; <span class="comment">/* = WindowManagerImpl.ADD_OKAY; */</span></span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mOrigWindowType = mWindowAttributes.type;</span><br><span class="line">                    mAttachInfo.mRecomputeGlobalAttributes = <span class="keyword">true</span>;</span><br><span class="line">                    collectViewAttributes();</span><br><span class="line">                    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                            getHostVisibility(), mDisplay.getDisplayId(), mTmpFrame,</span><br><span class="line">                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                            mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel,</span><br><span class="line">                            mTempInsets);</span><br><span class="line">                    setFrame(mTmpFrame);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    ..</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                 <span class="keyword">if</span> (res &lt; WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">                    mAttachInfo.mRootView = <span class="keyword">null</span>;</span><br><span class="line">                    mAdded = <span class="keyword">false</span>;</span><br><span class="line">                    mFallbackEventHandler.setView(<span class="keyword">null</span>);</span><br><span class="line">                    unscheduleTraversals();</span><br><span class="line">                    setAccessibilityFocus(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">switch</span> (res) &#123;  <span class="comment">//  &lt;------------------ 这里抛出异常</span></span><br><span class="line">                        <span class="keyword">case</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN:</span><br><span class="line">                        <span class="keyword">case</span> WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> WindowManager.BadTokenException(</span><br><span class="line">                                    <span class="string">"Unable to add window -- token "</span> + attrs.token</span><br><span class="line">                                    + <span class="string">" is not valid; is your activity running?"</span>);</span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line">                </span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-初步解决"><a href="#2-初步解决" class="headerlink" title="2 初步解决"></a>2 初步解决</h1><p>看到这个问题，一般会认为是 Activity 已经 finished 或者应 destroyed 了，所以我们在前面加判断。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">showReceiveGiftTips</span><span class="params">(tips: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">    L.info(TAG, <span class="string">"showReceiveGiftTips tips <span class="variable">$tips</span>"</span>)</span><br><span class="line">    <span class="keyword">if</span> (!mVisibleToUser) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tips.isNullOrEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mHomeReceiveGiftTipsPopupWindow != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> activity = getContextToActivity()  <span class="comment">// 这里加了 activity 的判断</span></span><br><span class="line">    <span class="keyword">if</span> (ActivityUtils.activityIsDestroyed(activity)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    mHomeReceiveGiftTipsPopupWindow = HomeReceiveGiftTipsPopupWindow(context!!)</span><br><span class="line">    mHomeReceiveGiftTipsPopupWindow!!.setData(tips)</span><br><span class="line">    mHomeReceiveGiftTipsPopupWindow!!.showOnAnchor(</span><br><span class="line">            fl_gift,</span><br><span class="line">            RelativePopupWindow.VerticalPosition.BELOW,</span><br><span class="line">            RelativePopupWindow.HorizontalPosition.CENTER</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们开心的修复，在 2.0.1 跟了出去</p><p>然而，还是有问题</p><p><img src="/2022/01/22/popupwindow-badtokenexception/bad_token_1.png"></p><h1 id="3-分析过程"><a href="#3-分析过程" class="headerlink" title="3 分析过程"></a>3 分析过程</h1><p>第一次解决尝试失败，我们在重新审视这个崩溃。</p><p>下面是平时我们遇到的 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android.view.WindowManager$BadTokenException: Unable to add window — token android.os.BinderProxy@<span class="number">447</span>a6748 is not valid; is your activity running?</span><br><span class="line">at android.view.ViewRoot.setView(ViewRoot.java:<span class="number">468</span>)</span><br><span class="line">at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:<span class="number">177</span>)</span><br><span class="line">at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:<span class="number">91</span>)</span><br><span class="line">at android.view.Window$LocalWindowManager.addView(Window.java:<span class="number">424</span>)</span><br><span class="line">at android.app.Dialog.show(Dialog.java:<span class="number">239</span>)</span><br><span class="line">at android.app.Activity.showDialog(Activity.java:<span class="number">2488</span>)</span><br><span class="line">…</span><br><span class="line">at android.os.Handler.dispatchMessage(Handler.java:<span class="number">99</span>)</span><br></pre></td></tr></table></figure><p>结合抛出的异常信息，我们发现 chikii 抛出的这个 BadTokenException token 的值为空。它和我们平时遇到的 BadTokenException 有点不一样.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WindowManager$BadTokenException: Unable to add window -- token null is not valid; is your activity running?</span><br></pre></td></tr></table></figure><p>这个 token 是 null 就是突破口</p><p>我们先看看这个  token 是从哪里来的</p><h2 id="3-1-PopupWindow-show-的流程"><a href="#3-1-PopupWindow-show-的流程" class="headerlink" title="3.1 PopupWindow#show 的流程"></a>3.1 PopupWindow#show 的流程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">RelativePopupWindow -&gt; RelativePopupWindow: showOnAnchor(anchor)</span><br><span class="line">RelativePopupWindow -&gt; PopupWindow: showAtLocation(parent) ①</span><br><span class="line"></span><br><span class="line">PopupWindow -&gt; PopupWindow: showAtLocation(token) ②  </span><br><span class="line"></span><br><span class="line">PopupWindow -&gt; PopupWindow: createPopupLayoutParams(token): WindowManager.LayoutParams③</span><br><span class="line"></span><br><span class="line">PopupWindow -&gt; PopupWindow: invokePopup(WindowManager.LayoutParams) ④</span><br><span class="line"></span><br><span class="line">PopupWindow -&gt; WindowManagerImpl:addView(View, iewGroup.LayoutParams)</span><br><span class="line"></span><br><span class="line">WindowManagerImpl -&gt; WindowManagerGlobal:addView(View,ViewGroup.LayoutParams ...) ⑤</span><br><span class="line"></span><br><span class="line">WindowManagerGlobal -&gt; ViewRootImpl:setView(view,WindowManager.LayoutParams,panelParentView) ⑥</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p>说明：<br>①<br>PopupWindow#showAtLocation<br>在这个方法拿到 anchor 锚点 View 的 windowToken，然后一路传着下去<br>仍然会</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAtLocation</span><span class="params">(View parent, <span class="keyword">int</span> gravity, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    mParentRootView = <span class="keyword">new</span> WeakReference&lt;&gt;(parent.getRootView());</span><br><span class="line">    showAtLocation(parent.getWindowToken(), gravity, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②③<br>创建 WindowManager.LayoutParams</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PopupWindow#showAtLocation</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAtLocation</span><span class="params">(IBinder token, <span class="keyword">int</span> gravity, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams p = createPopupLayoutParams(token);</span><br><span class="line">    preparePopup(p);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    invokePopup(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> WindowManager.<span class="function">LayoutParams <span class="title">createPopupLayoutParams</span><span class="params">(IBinder token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams p = <span class="keyword">new</span> WindowManager.LayoutParams();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    p.token = token;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④<br>PopupWindow#invokePopup<br>将 DecorView 添加到 WindowManager 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokePopup</span><span class="params">(WindowManager.LayoutParams p)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> PopupDecorView decorView = mDecorView;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       mWindowManager.addView(decorView, p);</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>⑤<br>WindowManagerGlobal#addView 里面创建 ViewRootImpl 并调用 ViewRootImpl 的 addView 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WindowManagerGlobal#addView </span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams      params,Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     ....</span><br><span class="line"></span><br><span class="line">    ViewRootImpl root;</span><br><span class="line"></span><br><span class="line">    root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">    view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    root.setView(view, wparams, panelParentView);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>⑥<br>调用 WindowSession.addToDisplay 显示 PopuWindow</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl#setView</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mView = view;</span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">                attrs = mWindowAttributes;</span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">                requestLayout();</span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    ...</span><br><span class="line">                     <span class="comment">// 调用 WindowSession.addToDisplay 显示 PopupWindow</span></span><br><span class="line">                    res = mWindowSession.addToDisplay(...);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line"></span><br><span class="line">                    ...</span><br><span class="line"></span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>现在整个调用的 链路都非常清楚了，调用  HomeReceiveGiftTipsPopupWindow 的 锚点 View 的 token 为空，即<br>fl_gift 的token 为空</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mHomeReceiveGiftTipsPopupWindow = HomeReceiveGiftTipsPopupWindow(context!!)</span><br><span class="line">    mHomeReceiveGiftTipsPopupWindow!!.setData(tips)</span><br><span class="line">    mHomeReceiveGiftTipsPopupWindow!!.showOnAnchor(</span><br><span class="line">            fl_gift,  &lt;---- 这个 View 的 token 为空</span><br><span class="line">            RelativePopupWindow.VerticalPosition.BELOW,</span><br><span class="line">            RelativePopupWindow.HorizontalPosition.CENTER</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h2 id="3-2-View-的-token-来源"><a href="#3-2-View-的-token-来源" class="headerlink" title="3.2  View 的 token 来源"></a>3.2  View 的 token 来源</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// View# getWindowToken</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IBinder <span class="title">getWindowToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mAttachInfo != <span class="keyword">null</span> ? mAttachInfo.mWindowToken : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>View 的 Token 是从 mAttachInfo 拿的，因此要知道 mAttachInfo 是怎么来的</p><h3 id="3-2-1-View-AttachInfo"><a href="#3-2-1-View-AttachInfo" class="headerlink" title="3.2.1 View$AttachInfo"></a>3.2.1 View$AttachInfo</h3><p>AttachInfo 是 View 的一个内部类，里面包含信息主要有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// View$AttachInfo.java</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A set of information given to a view when it is attached to its parent</span></span><br><span class="line"><span class="comment">     * window.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AttachInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> IWindowSession mSession;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">final</span> IWindow mWindow;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> IBinder mWindowToken;  <span class="comment">// 这个就是要拿的 token</span></span><br><span class="line"></span><br><span class="line">        Display mDisplay;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Callbacks mRootCallbacks;</span><br><span class="line"></span><br><span class="line">        IWindowId mIWindowId;</span><br><span class="line">        WindowId mWindowId;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The top view of the hierarchy.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        View mRootView;</span><br><span class="line"></span><br><span class="line">        IBinder mPanelParentWindowToken;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> mHardwareAccelerated;</span><br><span class="line">        <span class="keyword">boolean</span> mHardwareAccelerationRequested;</span><br><span class="line">        ThreadedRenderer mThreadedRenderer;</span><br><span class="line">        List&lt;RenderNode&gt; mPendingAnimatingRenderNodes;</span><br><span class="line"></span><br><span class="line">        ....</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>AttachInfo 的创建在 ViewRootImpl </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewRootImpl.java</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">    mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class="line"></span><br><span class="line">    mWindow = <span class="keyword">new</span> W(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里创建 mAttachInfo</span></span><br><span class="line">    mAttachInfo = <span class="keyword">new</span> View.AttachInfo(mWindowSession, mWindow, display, <span class="keyword">this</span>, mHandler, <span class="keyword">this</span>,</span><br><span class="line">            context);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-AttachInfo-传递给-View-的过程"><a href="#3-2-2-AttachInfo-传递给-View-的过程" class="headerlink" title="3.2.2 AttachInfo 传递给 View 的过程"></a>3.2.2 AttachInfo 传递给 View 的过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ViewRootImpl#setView</span><br><span class="line">-&gt; ViewRootImpl#requestLayout</span><br><span class="line">-&gt; ViewRootImpl#scheduleTraversals</span><br><span class="line">-&gt; Choreographer#postCallback</span><br><span class="line">-&gt; TraversalRunnable#run</span><br><span class="line">-&gt; ViewRootImpl#doTraversal</span><br><span class="line">-&gt; ViewRootImpl#performTraversals</span><br><span class="line">-&gt; View#dispatchAttachedToWindow(mAttachInfo, 0); // 这里创建好的 AttachInfo 赋值给 View</span><br></pre></td></tr></table></figure><p>View#dispatchAttachedToWindow</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchAttachedToWindow</span><span class="params">(AttachInfo info, <span class="keyword">int</span> visibility)</span> </span>&#123;</span><br><span class="line">       mAttachInfo = info;</span><br><span class="line">       </span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 View 中的 token 是要经过 View#dispatchAttachedToWindow  方法才能有值的，这要求我们在显示 PopupWindow 的时候，要选择相应的时机。</p><h1 id="4-最终解决"><a href="#4-最终解决" class="headerlink" title="4 最终解决"></a>4 最终解决</h1><p>通过上面的 PopupWindow 的 show 流程和 View 的token 赋值流程的分析，<br>在去看看 为啥我们在第一步加了对 Activity 状态的判断还出现崩溃。</p><p>主要是因为锚点 View 的 token 为空导致的。</p><p>导致 token 为空，也是因为调用 show 的时机不对。</p><p><strong>解决办法是在调用 PopupWindow 的 show 之前先判断一下锚点 View 的 applicationWindowToken ,并且调用的时机也要调整一下，不能在 View 一创建的时候就调用。</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showReceiveGiftTips</span><span class="params">(tips: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">     ...</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> (giftIcon.applicationWindowToken == <span class="literal">null</span>) &#123; <span class="comment">// 一 token 判断</span></span><br><span class="line">         L.error(TAG, <span class="string">"showReceiveGiftTips giftIcon.applicationWindowToken return"</span>)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">val</span> activity = getContextToActivity() <span class="comment">// 二 activity 的判断</span></span><br><span class="line">     <span class="keyword">if</span> (ActivityUtils.activityIsDestroyed(activity)) &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">     &#125;</span><br><span class="line">     mHomeReceiveGiftTipsPopupWindow = HomeReceiveGiftTipsPopupWindow(context!!)</span><br><span class="line">     mHomeReceiveGiftTipsPopupWindow!!.setData(tips)</span><br><span class="line">     mHomeReceiveGiftTipsPopupWindow!!.showOnAnchor(fl_gift, ...</span><br><span class="line">     )</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>1. 后续在使用 PopupWindow 的时候要注意调用 show 的时机</strong><br><strong>2. show 之前最好判断一下锚点 View 的 token 和 Activity 的状态</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;PopupWindow 的 BadTokenException&lt;/p&gt;
&lt;p&gt;2.0.0 版本出现这个崩溃&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
    
      <category term="Android" scheme="https://yxhuangch.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>xCrash 分析</title>
    <link href="https://yxhuangch.github.io/2021/11/20/xcrash-note/"/>
    <id>https://yxhuangch.github.io/2021/11/20/xcrash-note/</id>
    <published>2021-11-20T07:39:42.000Z</published>
    <updated>2021-11-20T08:04:05.086Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>XCrash 的崩溃捕获分为, java 崩溃捕获，Native 崩溃捕获 和 Anr 崩溃捕获。</p><p>这是 xcrash 是的架构图</p><p><img src="/2021/11/20/xcrash-note/architecture.png"></p><p>图片来自 <a href="https://github.com/iqiyi/xCrash" target="_blank" rel="noopener">xCrash 的 github</a></p><ul><li>JavaCrashHandler 捕获 Java 崩溃，handleException 处理 java 崩</li><li>NativeHandler 捕获 native 崩溃</li><li>AnrHandler 捕获 ABI &lt; 21 的 anr ,高于等于 21 的在 native 层捕获</li></ul><h1 id="1-Java-崩溃的捕获"><a href="#1-Java-崩溃的捕获" class="headerlink" title="1 Java　崩溃的捕获"></a>1 Java　崩溃的捕获</h1><h1 id="2-Native-崩溃的捕获"><a href="#2-Native-崩溃的捕获" class="headerlink" title="2. Native 崩溃的捕获"></a>2. Native 崩溃的捕获</h1><p>Native 崩溃的捕获主要是两方面：</p><ul><li>一是捕获到崩溃信号</li><li>二是堆栈的回溯，还原崩溃现场</li></ul><p><img src="/2021/11/20/xcrash-note/capture_native_crash.png"></p><p>图片来自 <a href="https://github.com/iqiyi/xCrash" target="_blank" rel="noopener">xCrash 的 github</a></p><h2 id="2-1-Native-崩溃捕获的时序"><a href="#2-1-Native-崩溃捕获的时序" class="headerlink" title="2.1 Native 崩溃捕获的时序"></a>2.1 Native 崩溃捕获的时序</h2><p><img src="/2021/11/20/xcrash-note/xcrash_1.png"></p><ul><li><strong>初始化</strong></li></ul><p>NativeHandler#initialize<br>加载 xcrash.so<br>初始化 nativeInit</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initialize</span><span class="params">(...)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ... </span><br><span class="line">     </span><br><span class="line">    System.loadLibrary(<span class="string">"xcrash"</span>);  </span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> r = nativeInit(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>xc_jni.c初始化</strong></li></ul><p>xc_jni.c 文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">xc_jni_init</span><span class="params">(..)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    xc_common_init(...)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(crash_enable)&#123;</span><br><span class="line">         <span class="keyword">if</span>(crash_dump_all_threads_whitelist)&#123;</span><br><span class="line"></span><br><span class="line">             ...</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//crash init</span></span><br><span class="line">        <span class="comment">// 初始化的重点</span></span><br><span class="line">        r_crash = xc_crash_init(...)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(trace_enable)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//trace init</span></span><br><span class="line">        r_trace = xc_trace_init(...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 Native 的入口</p><ul><li><p>xc_common_init<br>这是初始化一下公共信息，例如版本、 ABI、app_version 版本等信息</p></li><li><p>crash_dump_all_threads_whitelist<br>设置崩溃是 dump 白名单线程</p></li><li><p>xc_crash_init<br>这个是初始化的重点, 后面会详细讲述</p></li><li><p>xc_trace_init</p></li></ul><h2 id="2-2-xc-crash-init"><a href="#2-2-xc-crash-init" class="headerlink" title="2.2 xc_crash_init"></a>2.2 xc_crash_init</h2><p>xc_crash.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xc_crash_init</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    xc_crash_prepared_fd = XCC_UTIL_TEMP_FAILURE_RETRY(open(<span class="string">"/dev/null"</span>, O_RDWR));</span><br><span class="line">    xc_crash_rethrow = rethrow;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == (xc_crash_emergency = <span class="built_in">calloc</span>(XC_CRASH_EMERGENCY_BUF_LEN, <span class="number">1</span>))) <span class="keyword">return</span> XCC_ERRNO_NOMEM;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == (xc_crash_dumper_pathname = xc_util_strdupcat(xc_common_app_lib_dir, <span class="string">"/"</span>XCC_UTIL_XCRASH_DUMPER_FILENAME))) <span class="keyword">return</span> XCC_ERRNO_NOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//init the local unwinder for fallback mode</span></span><br><span class="line">    <span class="comment">// ① 根据不同的 API 版本，初始化堆栈回溯 so</span></span><br><span class="line">    xcc_unwind_init(xc_common_api_level);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//init for JNI callback</span></span><br><span class="line">    <span class="comment">// ② 设置回调， 回调到 NativeHandler 的 crashCallback 方法</span></span><br><span class="line">    xc_crash_init_callback(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//struct info passed to the dumper process</span></span><br><span class="line">    <span class="comment">// dump 时使用的数据结构</span></span><br><span class="line">    <span class="built_in">memset</span>(...)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//③ for clone and fork</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __i386__</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == (xc_crash_child_stack = <span class="built_in">calloc</span>(XC_CRASH_CHILD_STACK_LEN, <span class="number">1</span>))) <span class="keyword">return</span> XCC_ERRNO_NOMEM;</span><br><span class="line">    xc_crash_child_stack = (<span class="keyword">void</span> *)(((<span class="keyword">uint8_t</span> *)xc_crash_child_stack) + XC_CRASH_CHILD_STACK_LEN);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// pipe2 创建管道</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != pipe2(xc_crash_child_notifier, O_CLOEXEC)) <span class="keyword">return</span> XCC_ERRNO_SYS;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//register signal handler</span></span><br><span class="line">    <span class="comment">// ④ 注册信号捕获 handler</span></span><br><span class="line">    <span class="keyword">return</span> xcc_signal_crash_register(xc_crash_signal_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>xc_crash_init 是核心方法</strong></p><ul><li><p>xc_crash_prepared_fd 是为崩溃时预留存储文件</p></li><li><p>①  xcc_unwind_init， 根据不同的 API 版本，初始化堆栈回溯 so</p><ul><li>16 &gt;= API Level &lt;= 20, 使用 libcorkscrew.so</li><li>21 &gt;= API Level &lt;= 23, 使用 libunwind.so </li><li>APL Level &gt;= 24, 可以使用 _Unwind_Backtrace 直接调用</li></ul></li><li><p>② xc_crash_init_callback， 设置回调， 回调到 NativeHandler 的 crashCallback 方法</p></li><li><p>③ for clone and fork， 对于 arm 架构来说，是使用 pipe2 创建管道，用来通知崩溃的信号</p></li><li><p>④ xcc_signal_crash_register， 注册信号捕获 handler，handler 是 xc_crash_signal_handler</p></li></ul><h2 id="2-3-xcc-signal-crash-register"><a href="#2-3-xcc-signal-crash-register" class="headerlink" title="2.3 xcc_signal_crash_register"></a>2.3 xcc_signal_crash_register</h2><p>xcc_signal.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要监听的信号</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">xcc_signal_crash_info_t</span> xcc_signal_crash_info[] =</span><br><span class="line">&#123;</span><br><span class="line">    &#123;.signum = SIGABRT&#125;,</span><br><span class="line">    &#123;.signum = SIGBUS&#125;,</span><br><span class="line">    &#123;.signum = SIGFPE&#125;,</span><br><span class="line">    &#123;.signum = SIGILL&#125;,</span><br><span class="line">    &#123;.signum = SIGSEGV&#125;,</span><br><span class="line">    &#123;.signum = SIGTRAP&#125;,</span><br><span class="line">    &#123;.signum = SIGSYS&#125;,</span><br><span class="line">    &#123;.signum = SIGSTKFLT&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int xcc_signal_crash_register(void (*handler)(int, siginfo_t *, void *))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ① 设置而外的栈空间</span></span><br><span class="line">    <span class="keyword">stack_t</span> ss;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == (ss.ss_sp = <span class="built_in">calloc</span>(<span class="number">1</span>, XCC_SIGNAL_CRASH_STACK_SIZE))) <span class="keyword">return</span> XCC_ERRNO_NOMEM;</span><br><span class="line">    ss.ss_size  = XCC_SIGNAL_CRASH_STACK_SIZE;</span><br><span class="line">    ss.ss_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != sigaltstack(&amp;ss, <span class="literal">NULL</span>)) <span class="keyword">return</span> XCC_ERRNO_SYS;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line">    sigfillset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_sigaction = handler;</span><br><span class="line">    act.sa_flags = SA_RESTART | SA_SIGINFO | SA_ONSTACK;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(xcc_signal_crash_info) / <span class="keyword">sizeof</span>(xcc_signal_crash_info[<span class="number">0</span>]); i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> != sigaction(xcc_signal_crash_info[i].signum, &amp;act, &amp;(xcc_signal_crash_info[i].oldact)))</span><br><span class="line">            <span class="keyword">return</span> XCC_ERRNO_SYS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>① 设置而外空间</p><ul><li>SIGSEGV 有可能是栈溢出引起的，如果在默认的栈上运行很用可能会破坏程序运行的现场，无法获得正确的上下文。而且当栈满了，系统会在同一个已经满了的栈上调用 SIGSEGV 的信号处理函数，又再一次引起同样的信号。</li><li>开辟一块新的空间作为运行信号处理函数的栈。可以使用 sigaltstack 在任意线程注册一个可选的栈，保留一下载紧急情况下使用的空间。<br>出自 [<a href="https://mp.weixin.qq.com/s/g-WzYF3wWAljok1XjPoo7w?]" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/g-WzYF3wWAljok1XjPoo7w?]</a></li></ul><h2 id="2-4-xc-crash-signal-handler"><a href="#2-4-xc-crash-signal-handler" class="headerlink" title="2.4 xc_crash_signal_handler"></a>2.4 xc_crash_signal_handler</h2><p><strong>xc_crash.c#xc_crash_signal_handler</strong></p><p><img src="/2021/11/20/xcrash-note/xcrash_2.png"><br><img src="/2021/11/20/xcrash-note/xcrash_3.png"></p><h3 id="xc-crash-spot"><a href="#xc-crash-spot" class="headerlink" title="xc_crash_spot"></a>xc_crash_spot</h3><p>① 设置 crash 时的信息、包括崩溃时间、崩溃线程等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set crash spot info</span></span><br><span class="line"><span class="comment">// 设置崩溃的时间</span></span><br><span class="line">xc_crash_spot.crash_time = xc_crash_time;</span><br><span class="line"><span class="comment">// 崩溃的线程 ID</span></span><br><span class="line">xc_crash_spot.crash_tid = xc_crash_tid;</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;(xc_crash_spot.siginfo), si, <span class="keyword">sizeof</span>(<span class="keyword">siginfo_t</span>));</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;(xc_crash_spot.ucontext), uc, <span class="keyword">sizeof</span>(<span class="keyword">ucontext_t</span>));</span><br><span class="line"><span class="comment">// 崩溃log 文件路径长度</span></span><br><span class="line">xc_crash_spot.log_pathname_len = <span class="built_in">strlen</span>(xc_crash_log_pathname);</span><br></pre></td></tr></table></figure><h3 id="xc-crash-fork"><a href="#xc-crash-fork" class="headerlink" title="xc_crash_fork"></a>xc_crash_fork</h3><p>② fork 一个进程都用了 dump 内容 xc_crash_exec_dumper</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static int xc_crash_fork(int (*fn)(void *))</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __i386__</span></span><br><span class="line">    <span class="keyword">return</span> clone(fn, xc_crash_child_stack, CLONE_VFORK | CLONE_FS | CLONE_UNTRACED, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// fork 一个进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> dumper_pid = fork();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="xc-crash-exec-dumper"><a href="#xc-crash-exec-dumper" class="headerlink" title="xc_crash_exec_dumper"></a>xc_crash_exec_dumper</h3><p> xc_crash_exec_dumper 是在子进程中执行了，该方法有两个功能：</p><ul><li>一是, 设置 pipe 管道参数，set args pipe size</li><li>二是，加载 libxcrash_dumper.so 文件 ③</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xc_crash_exec_dumper</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">     <span class="comment">//set args pipe size</span></span><br><span class="line">    <span class="comment">// 设置管道参数</span></span><br><span class="line">    <span class="comment">//range: pagesize (4K) ~ /proc/sys/fs/pipe-max-size (1024K)</span></span><br><span class="line">    <span class="keyword">int</span> write_len = (<span class="keyword">int</span>)(<span class="keyword">sizeof</span>(<span class="keyword">xcc_spot_t</span>) +</span><br><span class="line">                          xc_crash_spot.log_pathname_len +</span><br><span class="line">                          xc_crash_spot.os_version_len +</span><br><span class="line">                          xc_crash_spot.kernel_version_len +</span><br><span class="line">                          xc_crash_spot.abi_list_len +</span><br><span class="line">                          xc_crash_spot.manufacturer_len +</span><br><span class="line">                          xc_crash_spot.brand_len +</span><br><span class="line">                          xc_crash_spot.model_len +</span><br><span class="line">                          xc_crash_spot.build_fingerprint_len +</span><br><span class="line">                          xc_crash_spot.app_id_len +</span><br><span class="line">                          xc_crash_spot.app_version_len +</span><br><span class="line">                          xc_crash_spot.dump_all_threads_whitelist_len);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//escape to the dumper process</span></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 加载 "libxcrash_dumper.so"</span></span><br><span class="line">    <span class="comment">// XCC_UTIL_XCRASH_DUMPER_FILENAME "libxcrash_dumper.so"</span></span><br><span class="line">    execl(xc_crash_dumper_pathname, XCC_UTIL_XCRASH_DUMPER_FILENAME, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span> + errno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="xcd-core-c-main"><a href="#xcd-core-c-main" class="headerlink" title="xcd_core.c#main;"></a>xcd_core.c#main;</h3><p>④ 从 xcd_core.c 的 main方法开始执行<br>当加载 libxcrash_dumper.so, 开始执行的方法是 xcd_core.c#main 方法<br>main 方法里面包含了几个步骤：</p><ul><li>xcc_unwind_init, 初始化堆栈回溯，为了捕获 dump 子进程可能发生的崩溃</li><li>xcc_signal_crash_register, 注册 signal, 为了捕获 dump 子进程可能发生的崩溃</li><li>xcd_process_create，统计崩溃进程的所有线程信息</li><li>xcd_process_suspend_threads, 挂起该进程 的所有线程</li><li>xcd_process_load_info, 获取进程的信息，包含进程、线程和内存映射信息</li><li>xcd_sys_record, 记录系统信息，包含 ABI Version 版本等</li><li>xcd_process_record, 记录进程信息</li><li>xcd_process_resume_threads,恢复所有线程</li></ul><h3 id="xcd-core-c-xcd-process-load-info"><a href="#xcd-core-c-xcd-process-load-info" class="headerlink" title="xcd_core.c#xcd_process_load_info"></a>xcd_core.c#xcd_process_load_info</h3><p>xcd_process_load_info 最终通过 xcd_maps_create 方法获取进程的内存映射信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xcd_maps_create</span><span class="params">(<span class="keyword">xcd_maps_t</span> **self, <span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... </span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"/proc/%d/maps"</span>, pid);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    xcd_maps_parse_line(buf, &amp;mi)))</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="xcd-process-record"><a href="#xcd-process-record" class="headerlink" title="xcd_process_record"></a>xcd_process_record</h3><p>⑥ 记录进程信息<br>这个方面里面是记录进程里面的主要信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xcd_process_record</span><span class="params">(...)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 循环</span></span><br><span class="line"> TAILQ_FOREACH(thd, &amp;(self-&gt;thds), link)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(thd-&gt;t.tid == self-&gt;crash_tid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取进程的 id, 名称 和 线程 id</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> != (r = xcd_thread_record_info(&amp;(thd-&gt;t), log_fd, self-&gt;pname))) <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 获取 signal 信号信息</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> != (r = xcd_process_record_signal_info(self, log_fd))) <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 获取 Abort message</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> != (r = xcd_process_record_abort_message(self, log_fd, api_level))) <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 获取寄存器信息</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> != (r = xcd_thread_record_regs(&amp;(thd-&gt;t), log_fd))) <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 获取线程每帧的信息，里面包含 Elf 的解析</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> == xcd_thread_load_frames(&amp;(thd-&gt;t), self-&gt;maps))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取 backtrace 堆栈信息</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span> != (r = xcd_thread_record_backtrace(&amp;(thd-&gt;t), log_fd))) <span class="keyword">return</span> r;</span><br><span class="line">                <span class="comment">// 获取 so 的 build id， 时间</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span> != (r = xcd_thread_record_buildid(&amp;(thd-&gt;t), log_fd, dump_elf_hash, xcc_util_signal_has_si_addr(self-&gt;si) ? (<span class="keyword">uintptr_t</span>)self-&gt;si-&gt;si_addr : <span class="number">0</span>))) <span class="keyword">return</span> r;</span><br><span class="line">                <span class="comment">// 获取 stack 信息</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span> != (r = xcd_thread_record_stack(&amp;(thd-&gt;t), log_fd))) <span class="keyword">return</span> r;</span><br><span class="line">                <span class="comment">// 获取内存信息</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span> != (r = xcd_thread_record_memory(&amp;(thd-&gt;t), log_fd))) <span class="keyword">return</span> r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 内存 map</span></span><br><span class="line">            <span class="keyword">if</span>(dump_map) <span class="keyword">if</span>(<span class="number">0</span> != (r = xcd_maps_record(self-&gt;maps, log_fd))) <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 系统 logcat 信息</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> != (r = xcc_util_record_logcat(log_fd, self-&gt;pid, api_level, logcat_system_lines, logcat_events_lines, logcat_main_lines))) <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 文件句柄 fd</span></span><br><span class="line">            <span class="keyword">if</span>(dump_fds) <span class="keyword">if</span>(<span class="number">0</span> != (r = xcc_util_record_fds(log_fd, self-&gt;pid))) <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 网络信息</span></span><br><span class="line">            <span class="keyword">if</span>(dump_network_info) <span class="keyword">if</span>(<span class="number">0</span> != (r = xcc_util_record_network_info(log_fd, self-&gt;pid, api_level))) <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 内存信息</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> != (r = xcc_meminfo_record(log_fd, self-&gt;pid))) <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>获取进程的 id, 名称 和 线程 id</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid: 20501, tid: 20501, name: xcrash.sample  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;</span><br></pre></td></tr></table></figure><ul><li><p><strong>获取 signal 信号信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x0</span><br></pre></td></tr></table></figure></li><li><p><strong>获取 Abort message</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Abort message: &apos;Check failed: key_value != nullptr compiler-filter not found in oat header&apos;</span><br></pre></td></tr></table></figure><ul><li><strong>获取寄存器信息</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r0  00000000  r1  00003d49  r2  00000006  r3  a2787e90</span><br><span class="line">r4  a2787ea4  r5  a2787e88  r6  00003d3f  r7  0000016b</span><br><span class="line">r8  a2787ea0  r9  a2787e90  r10 a2787ec0  r11 a2787eb0</span><br><span class="line">ip  00003d49  sp  a2787e60  lr  b29afc33  pc  b29afc46</span><br></pre></td></tr></table></figure><ul><li><strong>获取 backtrace 堆栈信息</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">backtrace:</span><br><span class="line">    #00 pc 0005ec46  /apex/com.android.runtime/lib/bionic/libc.so (abort+165)</span><br><span class="line">    #01 pc 0037ced1  /apex/com.android.runtime/lib/libart.so (_ZN3art7Runtime5AbortEPKc+1600)</span><br><span class="line">    #02 pc 0000857d  /system/lib/libbase.so (_ZN7android4base10LogMessageD2Ev+412)</span><br><span class="line">    #03 pc 00329937  /apex/com.android.runtime/lib/libart.so (_ZNK3art9OatHeader17GetCompilerFilterEv+170)</span><br><span class="line">    #04 pc 0032f241  /apex/com.android.runtime/lib/libart.so (_ZNK3art7OatFile17GetCompilerFilterEv+20)</span><br><span class="line">    #05 pc 003377e1  /apex/com.android.runtime/lib/libart.so (_ZN3art14OatFileManager14DumpForSigQuitERNSt3__113basic_ostreamIcNS1_11char_traitsIcEEEE+248)</span><br><span class="line">    #06 pc 00387035  /apex/com.android.runtime/lib/libart.so (_ZN3art7Runtime14DumpForSigQuitERNSt3__113basic_ostreamIcNS1_11char_traitsIcEEEE+68)</span><br><span class="line">    #07 pc 00396227  /apex/com.android.runtime/lib/libart.so (_ZN3art13SignalCatcher13HandleSigQuitEv+1026)</span><br><span class="line">    #08 pc 0039567f  /apex/com.android.runtime/lib/libart.so (_ZN3art13SignalCatcher3RunEPv+246)</span><br><span class="line">    #09 pc 000a6077  /apex/com.android.runtime/lib/bionic/libc.so (_ZL15__pthread_startPv+20)</span><br><span class="line">    #10 pc 00060131  /apex/com.android.runtime/lib/bionic/libc.so (__start_thread+30)</span><br></pre></td></tr></table></figure><ul><li><strong>获取 so 的 build id、md5 和时间</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">build id:</span><br><span class="line">    /apex/com.android.runtime/lib/bionic/libc.so (BuildId: 00be8c4fc1e3ff439b7de04fef5dc81b. FileSize: 987864. LastModified: 2009-01-01T07:00:00.000+0700. MD5: e8f59e3f6da4b10a0c60dd960c2db4a6)</span><br><span class="line">    /apex/com.android.runtime/lib/libart.so (BuildId: 02ff9b2d73bf74036eb619d1893bf752. FileSize: 6020200. LastModified: 2009-01-01T07:00:00.000+0700. MD5: 50b1a5e915af28db70cd41298ff7b61e)</span><br><span class="line">    /system/lib/libbase.so (BuildId: d61356f7fd581149bcf4b8d8caeb7d8a. FileSize: 63180. LastModified: 2009-01-01T07:00:00.000+0700. MD5: de03c2d4fc8f0659516ae0cbf4686db0)</span><br></pre></td></tr></table></figure><ul><li><p><strong>获取 stack 信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">stack:</span><br><span class="line">         a2787e20  00000002</span><br><span class="line">         a2787e24  b2a07260  [anon:.bss]</span><br><span class="line">         a2787e28  00000000</span><br><span class="line">         a2787e2c  6ee08ad0  [anon:libc_malloc]</span><br><span class="line">         a2787e30  b06e1217  /apex/com.android.runtime/lib/libart.so</span><br><span class="line">         a2787e34  09b33a2f  /system/bin/app_process32 (sigprocmask64+70)</span><br><span class="line">         a2787e38  00000000</span><br><span class="line">         a2787e3c  b2a07260  [anon:.bss]</span><br><span class="line">         a2787e40  b47037a4  [anon:libc_malloc]</span><br><span class="line">         a2787e44  345acf15  [anon:dalvik-main space (region space)]</span><br><span class="line">         a2787e48  a2787f70</span><br><span class="line">         a2787e4c  a2787e88</span><br><span class="line">         a2787e50  a2787f70</span><br><span class="line">         a2787e54  a2787e88</span><br><span class="line">         a2787e58  00003d3f</span><br><span class="line">         a2787e5c  b44b8190  [anon:.bss]</span><br><span class="line">    #00  a2787e60  a2787ed0</span><br><span class="line">         a2787e64  a2787ee0</span><br></pre></td></tr></table></figure></li><li><p><strong>获取内存信息</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">memory near r1:</span><br><span class="line">    00003d28 -------- -------- -------- --------  ................</span><br><span class="line">    00003d38 -------- -------- -------- --------  ................</span><br><span class="line">    00003d48 -------- -------- -------- --------  ................</span><br><span class="line">    00003d58 -------- -------- -------- --------  ................</span><br><span class="line">    00003d68 -------- -------- -------- --------  ................</span><br><span class="line">    00003d78 -------- -------- -------- --------  ................</span><br><span class="line">    00003d88 -------- -------- -------- --------  ................</span><br><span class="line">    00003d98 -------- -------- -------- --------  ................</span><br><span class="line">    00003da8 -------- -------- -------- --------  ................</span><br><span class="line">    00003db8 -------- -------- -------- --------  ................</span><br></pre></td></tr></table></figure><ul><li><strong>内存映射 map</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">memory map:</span><br><span class="line">    00580000-005c0000 rw-        0    40000 [anon:v8]</span><br><span class="line">    005ed000-00dee000 rw-        0   801000 [anon:libc_malloc]</span><br><span class="line">    00dee000-00def000 ---        0     1000 </span><br><span class="line">    00def000-00df0000 ---        0     1000 </span><br><span class="line">    00df0000-00ef6000 rw-        0   106000 </span><br><span class="line">    00ef6000-00ef8000 ---        0     2000 </span><br><span class="line">    00ef8000-00ef9000 ---        0     1000 </span><br><span class="line">    00ef9000-00fff000 rw-        0   106000 </span><br><span class="line">    00fff000-01000000 ---        0     1000 </span><br><span class="line">    01000000-01001000 ---        0     1000 [anon:partition_alloc]</span><br></pre></td></tr></table></figure><ul><li><strong>系统 logcat 信息</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">logcat:</span><br><span class="line">--------- tail end of log main (/system/bin/logcat -b main -d -v threadtime -t 200 --pid 6875 *:D)</span><br><span class="line">10-11 14:52:04.026  6875  6875 I xcrash.sample: Not late-enabling -Xcheck:jni (already on)</span><br><span class="line">10-11 14:52:04.060  6875  6875 E xcrash.sample: Unknown bits set in runtime_flags: 0x8000</span><br><span class="line">10-11 14:52:04.065  6875  6875 W xcrash.sample: Unexpected CPU variant for X86 using defaults: x86_64</span><br><span class="line">10-11 14:52:04.613  6875  6875 D xcrash_sample: xCrash SDK init: start</span><br><span class="line">10-11 14:52:04.622  6875  6875 D xcrash_sample: xCrash SDK init: end</span><br><span class="line">10-11 14:52:04.676  6875  6906 D libEGL  : Emulator has host GPU support, qemu.gles is set to 1.</span><br></pre></td></tr></table></figure><ul><li><strong>文件句柄 fd</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">open files:</span><br><span class="line">    fd 0: /dev/null</span><br><span class="line">    fd 1: /dev/null</span><br><span class="line">    fd 2: /dev/null</span><br><span class="line">    fd 3: socket:[95117]</span><br><span class="line">    fd 4: /sys/kernel/debug/tracing/trace_marker</span><br><span class="line">    fd 5: /dev/null</span><br><span class="line">    fd 6: /dev/null</span><br><span class="line">    fd 7: /dev/null</span><br><span class="line">    fd 8: /dev/binder</span><br><span class="line">    fd 9: /apex/com.android.runtime/javalib/core-oj.jar</span><br><span class="line">    fd 10: /apex/com.android.runtime/javalib/core-libart.jar</span><br></pre></td></tr></table></figure><ul><li><strong>网络信息</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">network info:</span><br><span class="line"> TCP over IPv4 (From: /proc/PID/net/tcp)</span><br><span class="line">  sl  local_address rem_address   st tx_queue rx_queue tr tm-&gt;when retrnsmt   uid  timeout inode</span><br><span class="line">  0: 0100007F:CF99 00000000:0000 0A 00000000:00000000 00:00000000 00000000 10133        0 342943 1 00000000 100 0 0 10 0</span><br><span class="line">  1: F326C70A:8B28 5E0AFB8E:01BB 01 00000000:00000000 00:00000000 00000000 10127        0 385678 1 00000000 27 4 29 10 -1</span><br><span class="line">  2: F326C70A:9F62 9DC87D4A:01BB 01 00000000:00000000 00:00000000 00000000 10127        0 384590 1 00000000 25 4 19 10 -1</span><br><span class="line">  3: F326C70A:9F52 9DC87D4A:01BB 01 00000000:00000000 00:00000000 00000000 10127        0 377105 1 00000000 26 4 24 10 -1</span><br></pre></td></tr></table></figure><ul><li><strong>内存信息</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">memory info:</span><br><span class="line"> System Summary (From: /proc/meminfo)</span><br><span class="line">  MemTotal:        1846008 kB</span><br><span class="line">  MemFree:           39444 kB</span><br><span class="line">  MemAvailable:     468560 kB</span><br><span class="line">  Buffers:           13184 kB</span><br><span class="line">  Cached:           555712 kB</span><br><span class="line">  SwapCached:        46180 kB</span><br><span class="line">  Active:           525916 kB</span><br><span class="line">  Inactive:         534600 kB</span><br><span class="line">  Active(anon):     278644 kB</span><br><span class="line">  Inactive(anon):   283012 kB</span><br><span class="line">  Active(file):     247272 kB</span><br><span class="line">  Inactive(file):   251588 kB</span><br><span class="line">  Unevictable:       62468 kB</span><br><span class="line">  Mlocked:           62468 kB</span><br></pre></td></tr></table></figure><h1 id="3-ANR-的捕获"><a href="#3-ANR-的捕获" class="headerlink" title="3. ANR 的捕获"></a>3. ANR 的捕获</h1><p>ANR 的捕获因为 Android 版本的限制，在低于 21 一下是在 AnrHandler 中，通过监听 /data/anr/ 路径下的文件变化来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AnrHandler.java</span></span><br><span class="line">fileObserver = <span class="keyword">new</span> FileObserver(<span class="string">"/data/anr/"</span>, CLOSE_WRITE) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(<span class="keyword">int</span> event, String path)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (path != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    String filepath = <span class="string">"/data/anr/"</span> + path;</span><br><span class="line">                    <span class="keyword">if</span> (filepath.contains(<span class="string">"trace"</span>)) &#123;</span><br><span class="line">                        handleAnr(filepath);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                XCrash.getLogger().e(Util.TAG, <span class="string">"AnrHandler fileObserver onEvent failed"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileObserver.startWatching();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于大于及 21 版本以上的，则在 xc_trace.c 中</p><p><img src="/2021/11/20/xcrash-note/xcrash_4.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xc_trace_init</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(xc_common_api_level &lt; <span class="number">21</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//init for JNI callback</span></span><br><span class="line">    <span class="comment">// 设置回调</span></span><br><span class="line">    xc_trace_init_callback(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//create event FD</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; (xc_trace_notifier = eventfd(<span class="number">0</span>, EFD_CLOEXEC))) <span class="keyword">return</span> XCC_ERRNO_SYS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//register signal handler</span></span><br><span class="line">    <span class="comment">// 注册监听</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != (r = xcc_signal_trace_register(xc_trace_handler))) <span class="keyword">goto</span> err2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//create thread for dump trace</span></span><br><span class="line">    <span class="comment">// ②创建 dump 线程</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != (r = pthread_create(&amp;thd, <span class="literal">NULL</span>, xc_trace_dumper, <span class="literal">NULL</span>))) <span class="keyword">goto</span> err1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="xcc-signal-trace-register"><a href="#xcc-signal-trace-register" class="headerlink" title="xcc_signal_trace_register"></a>xcc_signal_trace_register</h3><p>xcc_signal_trace_register ① 注册监听 会用 xc_trace_handler 监听</p><p>如果有信号过来，xc_trace_handler 里面会写 xc_trace_notifier 的值，通知 dump 线程开始 dump</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">xc_trace_handler</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">siginfo_t</span> *si, <span class="keyword">void</span> *uc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> data;</span><br><span class="line">    </span><br><span class="line">    (<span class="keyword">void</span>)sig;</span><br><span class="line">    (<span class="keyword">void</span>)si;</span><br><span class="line">    (<span class="keyword">void</span>)uc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xc_trace_notifier &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        data = <span class="number">1</span>;</span><br><span class="line">        XCC_UTIL_TEMP_FAILURE_RETRY(write(xc_trace_notifier, &amp;data, <span class="keyword">sizeof</span>(data)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="xc-trace-dumper"><a href="#xc-trace-dumper" class="headerlink" title="xc_trace_dumper"></a>xc_trace_dumper</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">xc_trace_dumper</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//block here, waiting for sigquit</span></span><br><span class="line">        <span class="comment">// 一直等着 xc_trace_notifier 的 信号</span></span><br><span class="line">        XCC_UTIL_TEMP_FAILURE_RETRY(read(xc_trace_notifier, &amp;data, <span class="keyword">sizeof</span>(data)));</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// dump</span></span><br><span class="line">        xc_trace_libart_runtime_dump(*xc_trace_libart_runtime_instance, xc_trace_libcpp_cerr);</span><br><span class="line">            </span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>xCrash 捕获的崩溃信息可以在第二次启动的时候上报，比较适合自己搭建的崩溃上报系统。市场上现有的 友盟 、Bugly 做的很好，但是有些产品性质的需要，要搭建自己的崩溃上报，xCrash 是个不错的选择.</p><p>另外，xCrash 涉及很多系统调用的函数已经堆栈回溯的技术，这方法知识需要自己后续补上。</p><h1 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h1><ul><li><a href="https://mp.weixin.qq.com/s/g-WzYF3wWAljok1XjPoo7w?" target="_blank" rel="noopener">Android 平台 Native 代码的崩溃捕获机制及实现</a></li><li><a href="https://www.dalvik.work/2021/06/22/xcrash/" target="_blank" rel="noopener">崩溃日志收集库 xCrash 浅析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;XCrash 的崩溃捕获分为, java 崩溃捕获，Native 崩溃捕获 和 Anr 崩溃捕获。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Android" scheme="https://yxhuangch.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin|Kotlin 反射</title>
    <link href="https://yxhuangch.github.io/2021/08/01/kotlin-reflect/"/>
    <id>https://yxhuangch.github.io/2021/08/01/kotlin-reflect/</id>
    <published>2021-08-01T01:34:22.000Z</published>
    <updated>2021-08-16T13:43:06.998Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-Kotlin-反射"><a href="#1-Kotlin-反射" class="headerlink" title="1. Kotlin 反射"></a>1. Kotlin 反射</h1><p>Kotlin  的反射需要集成 <code>org.jetbrains.kotlin:kotlin-reflect</code> 仓库,版本保持与 kotlin 一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &quot;org.jetbrains.kotlin:kotlin-reflect:$kotlin_version&quot;</span><br></pre></td></tr></table></figure><h2 id="1-1-Kotlin-反射类图"><a href="#1-1-Kotlin-反射类图" class="headerlink" title="1.1 Kotlin 反射类图"></a>1.1 Kotlin 反射类图</h2><p><img src="/2021/08/01/kotlin-reflect/kotlin_reflect_tree.png"><br>图片引用<a href="https://book.douban.com/subject/33419618/" target="_blank" rel="noopener">《Kotlin 核心编程》</a></p><p><strong>Java 的反射类图</strong></p><p><img src="/2021/08/01/kotlin-reflect/java_reflect_tree.png"></p><p>通过 kotlin 和 java 的对比，更容易理解 kotlin 的反射</p><ul><li>Kotlin 的反射类都是基于 <code>KAnnotatedElement</code>, 而 Java 的反射类都是基于 <code>AnnotateElement</code>；</li><li>Kotlin 的 KCallable 和 Java 的 AccessiableObject 都是可用元素；</li><li>Kotlin 的 KProperty 和 Java 的 Field 不太相同。 Kotlin 的 KProperty 通常指相应的 Getter　和　Setter  整体作为一个 KProperty(不存在字段的概念),而 Java 的 Field 通常仅仅指字段本身。</li></ul><p><strong>日常使用的 Kotlin 反射</strong><br><img src="/2021/08/01/kotlin-reflect/kotlin_reflect_1.png"></p><ul><li><p>创建实例</p><ul><li>ReflectA::class</li><li>KClass.createInstance</li><li>KClass.primaryConstructor  主构造函数</li></ul></li><li><p>获取实例的函数</p><ul><li>本身及父类的函数 KClass.functions</li><li>本身声明的函数 KClass.declaredFunctions</li><li>拓展的函数 KClass.memberExtensionFunctions</li></ul></li><li><p>获取实例的成员变量</p><ul><li>本身的成员属性  KClass.declaredMemberProperties</li><li>拓展属性 KClass.memberExtensionProperties</li></ul></li><li><p>获取实例的 companion<br>KClass.companionObject</p></li><li><p>获取注解<br>KClass.annotations</p></li><li><p>获取内部类<br>KClass.nestedClasses</p></li></ul><h1 id="2-创建实例"><a href="#2-创建实例" class="headerlink" title="2.创建实例"></a>2.创建实例</h1><h2 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> clazz = ReflectA::<span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="keyword">val</span> inst2 = clazz.createInstance()</span><br></pre></td></tr></table></figure><h2 id="有参构造"><a href="#有参构造" class="headerlink" title="有参构造"></a>有参构造</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> cons1 = clazz.primaryConstructor</span><br><span class="line"><span class="keyword">val</span> inst1 = cons1?.call(参入参数) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">val</span> cons2 = clazz.constructors</span><br><span class="line">cons2.<span class="keyword">get</span>[i].call(参入参数)</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>KClass.createInstance 是调用无参数的构造函数</li><li>KClass.primaryConstructor 是主构造函数，如果有参数，可以调用它的 call 方法传入参数</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>后面的例子都是以 <code>ReflectA</code> 类为例</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义注解</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">Anno</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated(<span class="meta-string">"该类已经不推荐使用"</span>)</span></span><br><span class="line"><span class="meta">@Anno</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReflectA</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        const <span class="keyword">val</span> TAG = <span class="string">"ReflectA"</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="string">"ReflectA_"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">this</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">(str: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">"ReflectA print str <span class="variable">$str</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sayHi</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        println(<span class="string">"ReflectA sayHi"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"sayHi"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓展方法</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> ReflectA.<span class="title">exfun</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"exfun"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓展属性</span></span><br><span class="line"><span class="keyword">val</span> ReflectA.foo: <span class="built_in">Double</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="number">3.14</span></span><br></pre></td></tr></table></figure><p>调用的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"---------- 创建对象 ---------"</span>)</span><br><span class="line">   println(<span class="string">" "</span>)</span><br><span class="line">   println(<span class="string">"createInstance 创建实例"</span>)</span><br><span class="line">   <span class="comment">// createInstance() 方法调用无参数的构造器创建实例</span></span><br><span class="line">   <span class="keyword">val</span> inst2 = clazz.createInstance()</span><br><span class="line">   println(inst2.name)</span><br><span class="line">   println(inst2.age)</span><br><span class="line"></span><br><span class="line">   println(<span class="string">" "</span>)</span><br><span class="line">   <span class="comment">// primaryConstructor 主构造函数</span></span><br><span class="line">   <span class="keyword">val</span> cons1 = clazz.primaryConstructor</span><br><span class="line">   <span class="keyword">val</span> inst1 = cons1?.call(<span class="string">"hello reflect"</span>)  <span class="comment">// 参入参数</span></span><br><span class="line">   println(inst1)</span><br><span class="line">   println(<span class="string">"inst1 "</span> + inst1?.name)</span><br><span class="line"></span><br><span class="line">   println(<span class="string">" "</span>)</span><br><span class="line">   println(<span class="string">"第一个构造函数"</span>)</span><br><span class="line">   <span class="keyword">val</span> cons2 = clazz.constructors.first()</span><br><span class="line">   println(cons2)</span><br><span class="line"></span><br><span class="line">   println(<span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line">   println(<span class="string">"-------调用方法------"</span>)</span><br><span class="line">   <span class="keyword">val</span> funs3 = clazz.declaredFunctions</span><br><span class="line">   <span class="keyword">val</span> inst3 = clazz.createInstance()</span><br><span class="line">   println(<span class="string">"ReflectA 本身声明的全部方法如下："</span>)</span><br><span class="line">   funs3.forEach &#123; println(it) &#125;</span><br><span class="line">   <span class="keyword">for</span> (f <span class="keyword">in</span> funs3) &#123;</span><br><span class="line">       <span class="keyword">if</span> (f.name == <span class="string">"sayHi"</span>) &#123;</span><br><span class="line">           f.call(inst3)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (f.name == <span class="string">"print"</span>) &#123;</span><br><span class="line">           f.call(inst3, <span class="string">"反射打印"</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出</p><blockquote><p>———- 创建对象 ———<br>createInstance 创建实例<br>ReflectA_<br>0<br>com.yxhuang.androiddailydemo.reflect.ReflectA@7b9a4292<br>inst1 hello reflect<br>第一个构造函数<br>fun <init>(): com.yxhuang.androiddailydemo.reflect.ReflectA</init></p></blockquote><p><br></p><h1 id="3-通过反射调用方法-KFunction"><a href="#3-通过反射调用方法-KFunction" class="headerlink" title="3.通过反射调用方法 KFunction"></a>3.通过反射调用方法 KFunction</h1><p>通过 KClass.declaredFunctions 获取，返回是一个 KFunction 列表</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"-------调用方法------"</span>)</span><br><span class="line">  <span class="keyword">val</span> funs3 = clazz.declaredFunctions</span><br><span class="line">  <span class="keyword">val</span> inst3 = clazz.createInstance()</span><br><span class="line">  println(<span class="string">"ReflectA 本身声明的全部方法如下："</span>)</span><br><span class="line">  funs3.forEach &#123; println(it) &#125;</span><br><span class="line">  <span class="keyword">for</span> (f <span class="keyword">in</span> funs3) &#123;</span><br><span class="line">      <span class="keyword">if</span> (f.name == <span class="string">"sayHi"</span>) &#123;</span><br><span class="line">          f.call(inst3) <span class="comment">// 调用无参函数</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (f.name == <span class="string">"print"</span>) &#123;</span><br><span class="line">          f.call(inst3, <span class="string">"反射打印"</span>) <span class="comment">// 传入参数</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>输出</p><blockquote><p>——-调用方法——<br>ReflectA 本身声明的全部方法如下：<br>fun com.yxhuang.androiddailydemo.reflect.ReflectA.print(kotlin.String): kotlin.Unit<br>fun com.yxhuang.androiddailydemo.reflect.ReflectA.sayHi(): kotlin.String<br>ReflectA print str 反射打印<br>ReflectA sayHi</p></blockquote><h1 id="4-通过反射获取属性"><a href="#4-通过反射获取属性" class="headerlink" title="4. 通过反射获取属性"></a>4. 通过反射获取属性</h1><p>通过 KClass.declaredMemberProperties 获取，返回是 KProperty1 列表。</p><p>KProperty 代码属性，它是 KCallable 的子类，<br>主要接口有</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> actual <span class="class"><span class="keyword">interface</span> <span class="title">KProperty</span>&lt;<span class="type">out V</span>&gt; : <span class="type">KCallable</span>&lt;<span class="type">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * `true` if this property is `lateinit`.</span></span><br><span class="line"><span class="comment">     * 是否是 lateinit </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SinceKotlin(<span class="meta-string">"1.1"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isLateinit: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * `true` if this property is `const`.</span></span><br><span class="line"><span class="comment">     *  是否是 const</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SinceKotlin(<span class="meta-string">"1.1"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> isConst: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The getter of this property, used to obtain the value of the property. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> getter: Getter&lt;V&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Represents a property accessor, which is a `get` or `set` method declared alongside the property.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Accessor</span>&lt;<span class="type">out V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The property which this accessor is originated from. */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">val</span> property: KProperty&lt;V&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Getter of the property is a `get` method declared alongside the property.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Getter</span>&lt;<span class="type">out V</span>&gt; : <span class="type">Accessor</span>&lt;<span class="type">V</span>&gt;, <span class="type">KFunction</span>&lt;<span class="type">V</span>&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取例子</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"-------访问属性------"</span>)</span><br><span class="line"><span class="comment">//通过decaredMemberProperties获取全部成员属性</span></span><br><span class="line"><span class="keyword">val</span> memberProperties2 = clazz.declaredMemberProperties</span><br><span class="line"><span class="keyword">val</span> inst4 = clazz.createInstance()</span><br><span class="line">println(<span class="string">"ReflectA 本身声明的成员属性如下："</span>)</span><br><span class="line">memberProperties2.forEach &#123; println(it) &#125;</span><br><span class="line">println(<span class="string">"inst4 name: <span class="subst">$&#123;inst4.name&#125;</span>"</span>)</span><br><span class="line">memberProperties2.forEach &#123;</span><br><span class="line">    <span class="keyword">if</span> (it.name == <span class="string">"age"</span>) &#123;</span><br><span class="line">        it <span class="keyword">as</span> KMutableProperty1&lt;ReflectA, <span class="built_in">Int</span>&gt;</span><br><span class="line">        it.isAccessible = <span class="literal">true</span></span><br><span class="line">        it.<span class="keyword">set</span>(inst4, <span class="number">20</span>)</span><br><span class="line">        println(it.<span class="keyword">get</span>(inst4))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><blockquote><p>——-访问属性——<br>ReflectA 本身声明的成员属性如下：<br>var com.yxhuang.androiddailydemo.reflect.ReflectA.age: kotlin.Int<br>val com.yxhuang.androiddailydemo.reflect.ReflectA.name: kotlin.String<br>inst4 name: ReflectA_<br>20</p></blockquote><h1 id="5-获取实例的-companion"><a href="#5-获取实例的-companion" class="headerlink" title="5.获取实例的 companion"></a>5.获取实例的 companion</h1><p>通过 KClass.companionObject 获取，返回也是一个 KClass 对象</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"---------- companion 对象 ---------"</span>) <span class="comment">//</span></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">companion</span> = clazz.companionObject <span class="comment">// 返回也是一个 KClass</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">companion</span> != <span class="literal">null</span>)&#123;</span><br><span class="line">        println(<span class="string">"companion <span class="variable">$companion</span>"</span>)</span><br><span class="line">        <span class="keyword">companion</span>.declaredMemberProperties.forEach &#123;</span><br><span class="line">            println(<span class="string">"companion declaredMemberProperties:  <span class="variable">$it</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">companion</span>.declaredFunctions.forEach &#123;</span><br><span class="line">            println(<span class="string">"companion declaredFunctions:  <span class="variable">$it</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出</p><blockquote><p>———- companion 对象 ———<br>companion class com.yxhuang.androiddailydemo.reflect.ReflectA$Companion<br>companion declaredMembers:  val com.yxhuang.androiddailydemo.reflect.ReflectA.Companion.TAG: kotlin.String<br>companion declaredFunctions:  fun com.yxhuang.androiddailydemo.reflect.ReflectA.Companion.show(): kotlin.Unit</p></blockquote><h1 id="6-获取注解"><a href="#6-获取注解" class="headerlink" title="6. 获取注解"></a>6. 获取注解</h1><p>通过 KClass.annotations 获取注解，返回是一个Annotation列表 </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过annotations属性获取该KClass对象所对应类的全部注解</span></span><br><span class="line"><span class="keyword">val</span> anns = clazz.annotations</span><br><span class="line">println(<span class="string">"ReflectA 的全部注解如下："</span>)</span><br><span class="line">anns.forEach &#123; println(it) &#125;</span><br><span class="line">println(<span class="string">"该KClass元素上的@Annot注解为：<span class="subst">$&#123;clazz.findAnnotation&lt;Anno&gt;()&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><p>输出</p><blockquote><p>ReflectA 的全部注解如下：<br>@kotlin.Deprecated(level=WARNING, <a href="mailto:replaceWith=@kotlin.ReplaceWith" target="_blank" rel="noopener">replaceWith=@kotlin.ReplaceWith</a>(imports=[], expression=), message=该类已经不推荐使用)<br>@com.yxhuang.androiddailydemo.reflect.Anno()<br>该KClass元素上的@Annot注解为：@com.yxhuang.androiddailydemo.reflect.Anno()</p></blockquote><h1 id="7-获取内部类"><a href="#7-获取内部类" class="headerlink" title="7.获取内部类"></a>7.获取内部类</h1><p>通过 KClass.nestedClasses 获取，返回是一个内部类的 KClass 列表</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过nestedClasses属性获取所对应的全部嵌套类</span></span><br><span class="line"><span class="keyword">val</span> inners = clazz.nestedClasses</span><br><span class="line">println(<span class="string">"ReflectA 的全部内部类如下："</span>)</span><br><span class="line">inners.forEach &#123; println(it) &#125;</span><br></pre></td></tr></table></figure><p>输出</p><blockquote><p>ReflectA 的全部内部类如下：<br>class com.yxhuang.androiddailydemo.reflect.ReflectA\$Companion<br>class com.yxhuang.androiddailydemo.reflect.ReflectA$InnerClass</p></blockquote><h1 id="8-完整的代码"><a href="#8-完整的代码" class="headerlink" title="8.完整的代码"></a>8.完整的代码</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yxhuang.androiddailydemo.reflect</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> kotlin.reflect.KMutableProperty1</span><br><span class="line"><span class="keyword">import</span> kotlin.reflect.full.*</span><br><span class="line"><span class="keyword">import</span> kotlin.reflect.jvm.isAccessible</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yxhuang</span></span><br><span class="line"><span class="comment"> * Date: 2021/7/30</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义注解</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">Anno</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated(<span class="meta-string">"该类已经不推荐使用"</span>)</span></span><br><span class="line"><span class="meta">@Anno</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReflectA</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        const <span class="keyword">val</span> TAG = <span class="string">"ReflectA"</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="string">"ReflectA_"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">this</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">(str: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">"ReflectA print str <span class="variable">$str</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sayHi</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        println(<span class="string">"ReflectA sayHi"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"sayHi"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓展方法</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> ReflectA.<span class="title">exfun</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"exfun"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓展属性</span></span><br><span class="line"><span class="keyword">val</span> ReflectA.foo: <span class="built_in">Double</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"Hello word"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> clazz = ReflectA::<span class="class"><span class="keyword">class</span></span></span><br><span class="line">    println(clazz)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"ReflectA 的全部构造器如下："</span>)</span><br><span class="line">    clazz.constructors.forEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"ReflectA 的主构造器如下："</span>)</span><br><span class="line">    println(clazz.primaryConstructor)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">" "</span>)</span><br><span class="line">    <span class="comment">//通过functions属性获取该KClass对象所对应类的全部方法</span></span><br><span class="line">    <span class="keyword">val</span> funs = clazz.functions</span><br><span class="line">    println(<span class="string">"ReflectA 的全部方法如下："</span>)</span><br><span class="line">    funs.forEach &#123; println(it) &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">" "</span>)</span><br><span class="line">    <span class="comment">//通过 declaredFunctions 属性获取该KClass对象声明的全部方法</span></span><br><span class="line">    <span class="keyword">val</span> funs2 = clazz.declaredFunctions</span><br><span class="line">    println(<span class="string">"ReflectA 本身声明的全部方法如下："</span>)</span><br><span class="line">    funs2.forEach &#123; println(it) &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">" "</span>)</span><br><span class="line">    <span class="comment">//通过 memberExtensionFunctions 属性获取全部扩展方法</span></span><br><span class="line">    <span class="keyword">val</span> exetensionFunctions = clazz.memberExtensionFunctions</span><br><span class="line">    println(<span class="string">"ReflectA 声明的扩展方法如下："</span>)</span><br><span class="line">    exetensionFunctions.forEach &#123; println(it) &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">" "</span>)</span><br><span class="line">    <span class="comment">//通过decaredMemberProperties获取全部成员属性</span></span><br><span class="line">    <span class="keyword">var</span> memberProperties = clazz.declaredMemberProperties</span><br><span class="line">    println(<span class="string">"ReflectA 本身声明的成员属性如下："</span>)</span><br><span class="line">    memberProperties.forEach &#123; println(it) &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">" "</span>)</span><br><span class="line">    <span class="comment">//通过memberExtensionProperties属性获取该KClass对象的全部扩展属性</span></span><br><span class="line">    <span class="keyword">var</span> exProperties = clazz.memberExtensionProperties</span><br><span class="line">    println(<span class="string">"ReflectA 本身声明的扩展属性如下："</span>)</span><br><span class="line">    exProperties.forEach &#123; println(it) &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">" "</span>)</span><br><span class="line">    <span class="comment">//通过annotations属性获取该KClass对象所对应类的全部注解</span></span><br><span class="line">    <span class="keyword">val</span> anns = clazz.annotations</span><br><span class="line">    println(<span class="string">"ReflectA 的全部注解如下："</span>)</span><br><span class="line">    anns.forEach &#123; println(it) &#125;</span><br><span class="line">    println(<span class="string">"该KClass元素上的@Annot注解为：<span class="subst">$&#123;clazz.findAnnotation&lt;Anno&gt;()&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">" "</span>)</span><br><span class="line">    <span class="comment">//通过nestedClasses属性获取所对应的全部嵌套类</span></span><br><span class="line">    <span class="keyword">val</span> inners = clazz.nestedClasses</span><br><span class="line">    println(<span class="string">"ReflectA 的全部内部类如下："</span>)</span><br><span class="line">    inners.forEach &#123; println(it) &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">" "</span>)</span><br><span class="line">    <span class="comment">//通过supertypes属性获取该类的所有父类型</span></span><br><span class="line">    println(<span class="string">"KClassTest的父类型为：<span class="subst">$&#123;clazz.supertypes&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    println(<span class="string">" "</span>)</span><br><span class="line">    println(<span class="string">"---------- companion 对象 ---------"</span>) <span class="comment">//</span></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">companion</span> = clazz.companionObject <span class="comment">// 返回也是一个 KClass</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">companion</span> != <span class="literal">null</span>)&#123;</span><br><span class="line">        println(<span class="string">"companion <span class="variable">$companion</span>"</span>)</span><br><span class="line">        <span class="keyword">companion</span>.declaredMemberProperties.forEach &#123;</span><br><span class="line">            println(<span class="string">"companion declaredMemberProperties:  <span class="variable">$it</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">companion</span>.declaredFunctions.forEach &#123;</span><br><span class="line">            println(<span class="string">"companion declaredFunctions:  <span class="variable">$it</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    println(<span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    println(<span class="string">"---------- 创建对象 ---------"</span>)</span><br><span class="line">    println(<span class="string">" "</span>)</span><br><span class="line">    println(<span class="string">"createInstance 创建实例"</span>)</span><br><span class="line">    <span class="comment">// createInstance() 方法调用无参数的构造器创建实例</span></span><br><span class="line">    <span class="keyword">val</span> inst2 = clazz.createInstance()</span><br><span class="line">    println(inst2.name)</span><br><span class="line">    println(inst2.age)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">" "</span>)</span><br><span class="line">    <span class="comment">// primaryConstructor 主构造函数</span></span><br><span class="line">    <span class="keyword">val</span> cons1 = clazz.primaryConstructor</span><br><span class="line">    <span class="keyword">val</span> inst1 = cons1?.call(<span class="string">"hello reflect"</span>)  <span class="comment">// 参入参数</span></span><br><span class="line">    println(inst1)</span><br><span class="line">    println(<span class="string">"inst1 "</span> + inst1?.name)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">" "</span>)</span><br><span class="line">    println(<span class="string">"第一个构造函数"</span>)</span><br><span class="line">    <span class="keyword">val</span> cons2 = clazz.constructors.first()</span><br><span class="line">    println(cons2)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"-------调用方法------"</span>)</span><br><span class="line">    <span class="keyword">val</span> funs3 = clazz.declaredFunctions</span><br><span class="line">    <span class="keyword">val</span> inst3 = clazz.createInstance()</span><br><span class="line">    println(<span class="string">"ReflectA 本身声明的全部方法如下："</span>)</span><br><span class="line">    funs3.forEach &#123; println(it) &#125;</span><br><span class="line">    <span class="keyword">for</span> (f <span class="keyword">in</span> funs3) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f.name == <span class="string">"sayHi"</span>) &#123;</span><br><span class="line">            f.call(inst3)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (f.name == <span class="string">"print"</span>) &#123;</span><br><span class="line">            f.call(inst3, <span class="string">"反射打印"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"\n"</span>)</span><br><span class="line">    println(<span class="string">"-------访问属性------"</span>)</span><br><span class="line">    <span class="comment">//通过decaredMemberProperties获取全部成员属性</span></span><br><span class="line">    <span class="keyword">val</span> memberProperties2 = clazz.declaredMemberProperties</span><br><span class="line">    <span class="keyword">val</span> inst4 = clazz.createInstance()</span><br><span class="line">    println(<span class="string">"ReflectA 本身声明的成员属性如下："</span>)</span><br><span class="line">    memberProperties2.forEach &#123; println(it) &#125;</span><br><span class="line">    println(<span class="string">"inst4 name: <span class="subst">$&#123;inst4.name&#125;</span>"</span>)</span><br><span class="line">    memberProperties2.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it.name == <span class="string">"age"</span>) &#123;</span><br><span class="line">            it <span class="keyword">as</span> KMutableProperty1&lt;ReflectA, <span class="built_in">Int</span>&gt;</span><br><span class="line">            it.isAccessible = <span class="literal">true</span></span><br><span class="line">            it.<span class="keyword">set</span>(inst4, <span class="number">20</span>)</span><br><span class="line">            println(it.<span class="keyword">get</span>(inst4))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-问题"><a href="#9-问题" class="headerlink" title="9. 问题"></a>9. 问题</h1><h2 id="9-1-打包混淆问题"><a href="#9-1-打包混淆问题" class="headerlink" title="9.1 打包混淆问题"></a>9.1 打包混淆问题</h2><p>在打包混淆之后，如果出现问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: No BuiltInsLoader implementation was found. Please ensure that the META-INF/services/ is not stripped from your application and that the Java virtual machine is not running under a security manager</span><br></pre></td></tr></table></figure><p>这是由于混淆导致的，解决办法是在 proguard-rules.pro 中添加下面的规矩即可 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-keep class kotlin.reflect.jvm.internal.impl.**</span><br><span class="line">-keep class kotlin.Metadata  &#123;*; &#125;</span><br><span class="line">-keepclassmembers class kotlin.Metadata &#123;    public &lt;methods&gt;;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1-Kotlin-反射&quot;&gt;&lt;a href=&quot;#1-Kotlin-反射&quot; class=&quot;headerlink&quot; title=&quot;1. Kotlin 反射&quot;&gt;&lt;/a&gt;1. Kotlin 反射&lt;/h1&gt;&lt;p&gt;Kotlin  的反射需要集成 &lt;co
      
    
    </summary>
    
    
      <category term="kotlin" scheme="https://yxhuangch.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>如何写设计文档</title>
    <link href="https://yxhuangch.github.io/2021/07/11/how-to-write-code-design/"/>
    <id>https://yxhuangch.github.io/2021/07/11/how-to-write-code-design/</id>
    <published>2021-07-11T12:12:12.000Z</published>
    <updated>2021-07-11T12:27:39.235Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>这是极客时间《许式伟的结构课》中的 <a href="https://time.geekbang.org/column/article/185234" target="_blank" rel="noopener">&lt;70|怎样写设计文档&gt;</a> 的笔记</p><p><strong>产品经理和架构师是一体两面，对人的能力要求比较像，但是分工不同，关注的维度不一样<br>产品经理关注的维度，关键词是：用户需求、技术赋能、商业成功<br>架构师的关注维度是，关键词是：用户需求、技术实现、业务迭代</strong></p><p><strong>设计是软件工程中的头等大事，我们应该在这里“多浪费点时间”，这样的 ”浪费“ 是最终会得到十倍甚至百倍以上的回报</strong></p><h2 id="1-文档的大体内容"><a href="#1-文档的大体内容" class="headerlink" title="1. 文档的大体内容"></a>1. 文档的大体内容</h2><p>设计文档包含的内容，大体如下</p><ul><li>现状：我们在哪里，现状是什么样的</li><li>需求：我们的问题或诉求是什么，要如何改进</li><li>需求满足方式：<ul><li>要做成什么样，交付物规格，使用界面（接口）是什么</li><li>怎么做到？交付物的实现原理</li></ul></li></ul><h3 id="1-1-现状"><a href="#1-1-现状" class="headerlink" title="1.1 现状"></a>1.1 现状</h3><p>现状不需要长篇累牍，现状更的多是陈述与我们要做的改变相关的重要事实，侧重于强调这些事实的存在性和重要性。</p><h3 id="1-2-需求"><a href="#1-2-需求" class="headerlink" title="1.2 需求"></a>1.2 需求</h3><p>需求也不需要长篇累牍，陈述对痛点和改进方法即可</p><h3 id="1-3-需求满足方式"><a href="#1-3-需求满足方式" class="headerlink" title="1.3 需求满足方式"></a>1.3 需求满足方式</h3><p>要详细写清楚，把我们的设计方案谈清楚。具体包含交付物规格和实现原理</p><h4 id="1-3-1-交付物规格"><a href="#1-3-1-交付物规格" class="headerlink" title="1.3.1 交付物规格"></a>1.3.1 交付物规格</h4><p>交付物规格或者说使用页面（接口）体现的是别人怎么使用我。<br>如果是产品设计，交付物规格可能是 “产品原型”。<br>架构设计，交付物规格可能是 “网络 API 协议” 或者 “包（package）导出的公开类或函数”</p><h4 id="1-3-2-实现原理"><a href="#1-3-2-实现原理" class="headerlink" title="1.3.2 实现原理"></a>1.3.2 实现原理</h4><p>实现原理，写的是我们是怎样做到的。<br>如果是产品设计，它写的是用户需求对应的 UserStory 设计，也就是业务流具体是怎样完成的。<br>架构设计，它写的是 UserStory 具体如何被我们的程序逻辑所实现的。</p><p><strong>指导思想</strong>是下面的公式</p><blockquote><p> 程序 = 数据结构 + 算法</p></blockquote><p>在写程序实现逻辑时，从数据结构和算法两个维度去描述它。<br>其中数据结构可以是内存数据结构，也可以是外存数据结构，还可以是数据库的表结构。<br>算法是基于数据结构， 它描述的是 UserStory 的具体实现，它可以是 UML 是时序图或者外代码。</p><p>对于模块的详细设计需要做的是</p><ul><li>第一，要交代清楚 “数据结构” 是什么样的</li><li>第二，然后再将一个个 UserStory 的业务流程讲清楚</li></ul><p>在用 UserStory 的时候，画 UML 时序图，在表达上伪代码的设计都是必需的。</p><h4 id="1-3-3-使用界面（接口）"><a href="#1-3-3-使用界面（接口）" class="headerlink" title="1.3.3 使用界面（接口）"></a>1.3.3 使用界面（接口）</h4><p>使用界面，也就是接口，主要关心有两点：</p><ul><li>接口是否足够简单，是否自然体现业务需求</li><li>尽可能避免进行接口变更，接口要向前兼容</li></ul><p>这些接口能够把系统的关键 UserStory 串起来。</p><p>一个方法是对模块的调用接口进行分类，它对外提供的访问接口一般是下面三种：</p><ul><li>常规 DOM API, 即正常的模块功能调用</li><li>事件(Event)的发送与监听</li><li>插件(Plugin)的注册</li></ul><p><strong>如何表达模块间的关系</strong><br>如何表达模块间的关系是非常重要，但是也是件非常复杂的事。<br>一般有以下几种方式表达模块间的关系：</p><ul><li><p>不整体描述模块的关系，而是基于一个个 UserStory 把模块之间的调用关系画出来<br>  这类图并不是表达模块的好选择，因为并没有对模块关系进行抽象。<br>  这类图更多是被用在面向客户介绍 API SDK 的背后实现原理时采用，而不是出现在设计文档。<br>  例如，下图是上传一个文件的业务流程图</p><p>  <img src="/2021/07/11/how-to-write-code-design/architecture_1.png"></p></li><li><p>如果只是对于 UserStory 业务流程的表达，UML 时序图通常是更好的表达方式</p></li><li><p>表达模块关系的视角，可以是从架构分解上看待，可以把系统看着 “一个最小化的核心系统 + 多个彼此正交分解的周边系统” </p><p><img src="/2021/07/11/how-to-write-code-design/architecture_2.png"></p><p><strong>其他常见的几种图</strong></p><ul><li><p>线框图<br><img src="/2021/07/11/how-to-write-code-design/architecture_3.png"></p></li><li><p>流程图<br><img src="/2021/07/11/how-to-write-code-design/architecture_4.png"></p></li><li><p>时序图<br><img src="/2021/07/11/how-to-write-code-design/architecture_5.png"></p></li></ul></li></ul><h3 id="1-4-多个设计方案对比"><a href="#1-4-多个设计方案对比" class="headerlink" title="1.4 多个设计方案对比"></a>1.4 多个设计方案对比</h3><p>有时候一篇设计文档不仅仅只有一个方案，而是有多个可能的需求实现方式，这个时候，在设计文档可以放多个多个方案对比。<br>对比的话，通常需要描述清楚两个设计方案的本质差别，并且从下面的几个维度进行对比：</p><ul><li>方案的易实施性与可维护性</li><li>方案的时间复杂度与空间复杂度</li></ul><p>不同的业务系统倾向性不太一样。<br>对绝大部分业务，我们最关心的是工程效率，所以在方案的易实施性与可维护性为先<br>对于部分成本与性能非常敏感的业务，则通常在保证方案的时间复杂度与空间复杂度达到业务预期的前提下，再考虑工程效率。</p><h2 id="2-参考"><a href="#2-参考" class="headerlink" title="2.参考"></a>2.参考</h2><ul><li><a href="https://time.geekbang.org/column/article/185234" target="_blank" rel="noopener">极客时间《许式伟的架构课  – 70 | 怎么写设计文档？》</a></li><li><a href="https://time.geekbang.org/column/article/88606" target="_blank" rel="noopener">极客时间《软件工程之美 – 16 | 怎样才能写好项目文档？》</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;这是极客时间《许式伟的结构课》中的 &lt;a href=&quot;https://time.geekbang.org/column/article/185234&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&amp;lt;70|怎样写设计文档&amp;gt
      
    
    </summary>
    
    
      <category term="软件工程" scheme="https://yxhuangch.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android GOT/PTL Hook</title>
    <link href="https://yxhuangch.github.io/2021/05/25/android-native-ptl-hook/"/>
    <id>https://yxhuangch.github.io/2021/05/25/android-native-ptl-hook/</id>
    <published>2021-05-25T14:27:12.000Z</published>
    <updated>2021-06-04T14:42:33.548Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>Android Native Hook 分成</p><ul><li>GOT/PLT Hook </li><li>Inline Hook</li></ul><p>本篇讲述 GOT/PLT Hook 的原理、具体实现以及它的优缺点</p><p>如果想在 mac 上使用 readelf, objdump 等命令，需要将 NDK 里面的路径配置到 path<br>在 <code>~./bashrc</code> 文件中添加路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;$PATH:/..(自己的目录)/android/sdk/ndk/21.0.6113669/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/&quot;</span><br></pre></td></tr></table></figure><p>保存，使用命令</p><blockquote><p>source ~/.bashrc</p></blockquote><p>使其生效</p><p><img src="/2021/05/25/android-native-ptl-hook/native_hook_3.png" width="100%" height="100%"></p><h1 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h1><p>Linux 在执行动态链接 ELF 的时候，为了优化性能使用了延迟绑定策略；</p><p>当动态链接的 ELF 程序里调用共享库的函数时，第一次调用时会先去查找 PTL 表中相应的项目， 而 PTL 表中再跳跃到 GOT 表中希望得到该函数的实际地址，但这是 GOT 表中指向的是 PLT 中那条跳跃指令下面的代码，最终会执行 _dl_runtime_resolve() 并执行目标函数。<br>第二次调用时也是 PTL 跳跃到 GOT 表，但是 GOT 中对应项目已经在第一次 _dl_runtime_relove() 中被修改为函数实际地址，因此第二次及以后的调用直接去执行目标函数，不再执行 _dl_runtime_relove() 了。<br>因此，PTL 通过修改 GOT 表，使得在调用该共享库的函数时跳转的是用户自定义的 Hook 功能代码。</p><ul><li><p>外部函数第一次调用流程</p><p><img src="/2021/05/25/android-native-ptl-hook/native_hook_4.png" width="100%" height="100%"></p></li><li><p>外部函数第二次调用流程</p><p><img src="/2021/05/25/android-native-ptl-hook/native_hook_5.png" width="100%" height="100%"></p></li></ul><h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><h2 id="2-1-总体实现方案"><a href="#2-1-总体实现方案" class="headerlink" title="2.1 总体实现方案"></a>2.1 总体实现方案</h2><p>总体的步骤：</p><ul><li>通过读取 /proc/<pid>/maps 文件找到链接库的基地址；</pid></li><li>读取动态库，解析 ELF 文件，找到符号（需要对 ELF 文件格式有了解）</li><li>计算目标函数绝对地址<br>目标进程函数绝对地址 = 动态库基地址 + 函数地址</li></ul><p>具体的步骤：</p><ul><li>1.获取动态库的基地址；</li><li>2.计算 .so 文件中的 program header table 程序头地址；</li><li>3.遍历程序头部表，获取动态段(.dynamic)地址；</li><li>4.找到 GOT 表地址；</li><li>5.修改内存属性为可写；</li><li>6.遍历 got 表，修改要替换的函数；</li><li>7.恢复内存属性为可读可执行。</li></ul><h2 id="2-2-方案的具体实现"><a href="#2-2-方案的具体实现" class="headerlink" title="2.2 方案的具体实现"></a>2.2 方案的具体实现</h2><p>下面具体实现的代码参考文章 <a href="https://blog.csdn.net/byhook/article/details/103500524?spm=1001.2014.3001.5502" target="_blank" rel="noopener">android中基于plt/got的hook实现原理</a> </p><p>我们在 Demo 里使用 CMake 将 Native 代码编译成 native_write.so 文件，放入到 libs 对应的架构目录下，然后通过 hook 住 so 文件中的 fwrite 函数。</p><p>先看我们要 hook 的目标，是在 <code>native_write.c</code> 中的 fwrite 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写入文件</span></span><br><span class="line"><span class="comment"> * @param path</span></span><br><span class="line"><span class="comment"> * @param text</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeText</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *text)</span></span>&#123;</span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>((fp = fopen(path, <span class="string">"w"</span>)) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        LOG_E(<span class="string">"file cannot open"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    fwrite(text, <span class="built_in">strlen</span>(text), <span class="number">1</span>, fp);</span><br><span class="line">    <span class="keyword">if</span>(fclose(fp) != <span class="number">0</span>)&#123;</span><br><span class="line">        LOG_E(<span class="string">"file cannot be closed"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把自己 hook 的 Native 也编译成 native_hook.so 文件，让 Android 把它加载<br>hook 的代码, hook 的代码在 <code>native_hook.c</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> new_fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> count, FILE *fp) &#123;</span><br><span class="line">    <span class="comment">// 插入文本</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *text = <span class="string">"hello native "</span>;</span><br><span class="line">    LOG_D(<span class="string">"new_fwrite hook fwrite success insert text: %s"</span>, text);</span><br><span class="line">    old_fwrite(text, <span class="built_in">strlen</span>(text), <span class="number">1</span>, fp);</span><br><span class="line">    <span class="keyword">return</span> old_fwrite(buf, size, count, fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是的 <code>new_fwrite</code> 函数就是在原来 <code>fwrite</code> 函数之前先写入 ‘hello native’ 的内容</p><ul><li><strong>第一步：获取动态库的基地址</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取目标进程中模块的加载地址</span></span><br><span class="line"><span class="keyword">void</span> *base_addr = get_module_base(getpid(), soPath);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  获取so的加载基址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">get_module_base</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">const</span> <span class="keyword">char</span> *module_name)</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> addr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">32</span>] = <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">1024</span>] = <span class="string">"\n"</span>;</span><br><span class="line">    LOG_D(<span class="string">"get_module_base pid=%d"</span>, pid);</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">"/proc/self/maps"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">"/proc/%d/maps"</span>, pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取指定 pid 进程加载的内存模块信息</span></span><br><span class="line">    fp = fopen(filename, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">while</span> (fgets(line, <span class="keyword">sizeof</span>(line), fp)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != <span class="built_in">strstr</span>(line, module_name) &amp;&amp;</span><br><span class="line">            <span class="built_in">sscanf</span>(line, <span class="string">"%"</span>PRIxPT<span class="string">R"-%*lx %*4s 00000000"</span>, &amp;addr) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *) addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>第二步：计算 .so 文件中的 program head table 程序头地址；</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.计算 header table 的实际地址</span></span><br><span class="line">Elf32_Ehdr *header = (Elf32_Ehdr *) (base_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序头表地址 program header = base_addr + 程序头表在Elf文件中的偏移</span></span><br><span class="line">Elf32_Phdr *phdr_table = (Elf32_Phdr *) (base_addr + header-&gt;e_phoff);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序头表里面 Segment 的数量</span></span><br><span class="line"><span class="keyword">size_t</span> phdr_count = header-&gt;e_phnum;</span><br><span class="line">LOG_D(<span class="string">"hook_fwrite phdr_count : %d"</span>, phdr_count);</span><br><span class="line"><span class="comment">// 遍历程序头表，找到 dynamic 段</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> p_vaddr = <span class="number">0</span>;  <span class="comment">// dynamic 段在虚拟内存的地址</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> p_memsz = <span class="number">0</span>;  <span class="comment">// dynamic 段在虚拟内存的中所占用的长度</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; phdr_count; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (phdr_table[j].p_type == PT_DYNAMIC) &#123;</span><br><span class="line">        <span class="comment">// 打印 .dynamic 段的虚拟内存地址</span></span><br><span class="line">        LOG_D(<span class="string">"hook_fwrite phdr_table[j].p_vaddr : %x"</span>, phdr_table[j].p_vaddr);</span><br><span class="line">        p_vaddr = base_addr + phdr_table[j].p_vaddr;</span><br><span class="line">        p_memsz = phdr_table[j].p_memsz;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>第三步：遍历程序头部表，获取动态段（.dynamic）地址；</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .dynamic　段的结构  /*</span></span><br><span class="line"><span class="comment">//    typedef struct dynamic &#123;</span></span><br><span class="line"><span class="comment">//         Elf32_Sword d_tag;</span></span><br><span class="line"><span class="comment">//         union &#123;</span></span><br><span class="line"><span class="comment">//          Elf32_Sword d_val;</span></span><br><span class="line"><span class="comment">//          Elf32_Addr d_ptr;</span></span><br><span class="line"><span class="comment">//          &#125; d_un;</span></span><br><span class="line"><span class="comment">//   &#125; Elf32_Dyn;</span></span><br><span class="line">Elf32_Dyn *dynamic_table = (Elf32_Dyn *) p_vaddr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> jmpRelOff = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> strTabOff = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ptlRelSz = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> symTabOff = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 3. 多个 .dynamic 段  (理解这段代码)</span></span><br><span class="line"><span class="comment">// 遍历 动态段</span></span><br><span class="line"><span class="keyword">int</span> dynCount = p_memsz / <span class="keyword">sizeof</span>(Elf32_Dyn);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dynCount; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> val = dynamic_table[i].d_un.d_val;</span><br><span class="line">    <span class="keyword">int</span> d_tag = dynamic_table[i].d_tag;</span><br><span class="line">    <span class="keyword">switch</span> (d_tag) &#123;</span><br><span class="line">        <span class="keyword">case</span> DT_JMPREL:  <span class="comment">// Address of relocations associated with PLT PTL 的重定位表地址</span></span><br><span class="line">            jmpRelOff = val;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DT_STRTAB:</span><br><span class="line">            strTabOff = val; <span class="comment">// Address of dynamic string table,动态链接字符串表地址</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DT_PLTRELSZ:  <span class="comment">// Size of relocation entries in PLT, PLT 中的所有重新定位项大小</span></span><br><span class="line">            ptlRelSz = val / <span class="keyword">sizeof</span>(Elf32_Rel);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DT_SYMTAB: <span class="comment">// Address of dynamic symbol table, 动态链接符号表的地址</span></span><br><span class="line">            symTabOff = val;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>第四步：找到 GOT 表地址；</strong> </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重定位表</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * typefef struct&#123;</span></span><br><span class="line"><span class="comment"> *    Elf32_Addr r_offset;</span></span><br><span class="line"><span class="comment"> *    Elf32_Word r_info;</span></span><br><span class="line"><span class="comment"> * &#125; Elf32_Rel;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * typedef struct elf32_sym &#123;</span></span><br><span class="line"><span class="comment"> *     Elf32_Word st_name;</span></span><br><span class="line"><span class="comment"> *     Elf32_Addr st_value;</span></span><br><span class="line"><span class="comment">  *    Elf32_Word st_size;</span></span><br><span class="line"><span class="comment">  *    unsigned char st_info;</span></span><br><span class="line"><span class="comment"> *     unsigned char st_other;</span></span><br><span class="line"><span class="comment">  *    Elf32_Half st_shndx;</span></span><br><span class="line"><span class="comment"> *  &#125; Elf32_Sym;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Elf32_Rel *rel_table = (Elf32_Rel *) (jmpRelOff + base_addr);</span><br></pre></td></tr></table></figure><ul><li><strong>第五步：找到被 hook 函数的</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.遍历 got 表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ptlRelSz; i++) &#123;</span><br><span class="line">    <span class="comment">//ELF32_R_SYM 右移八位，查找改符号（rel_table[i].r_info）在 rel_table 符号表中下标</span></span><br><span class="line">    <span class="keyword">uint16_t</span> ndx = ELF32_R_SYM(rel_table[i].r_info);</span><br><span class="line">    <span class="comment">// 符号表  地址 = 基址 + got 表地址 + 下标 * 符号大小</span></span><br><span class="line">    Elf32_Sym *symTable = (base_addr + symTabOff + ndx * <span class="keyword">sizeof</span>(Elf32_Sym));</span><br><span class="line">    <span class="comment">// 获取符号名 ???</span></span><br><span class="line">    <span class="keyword">char</span> *funcName = (<span class="keyword">char</span> *) (symTable-&gt;st_name + base_addr + strTabOff);</span><br><span class="line">    <span class="comment">// 5. 找到fwrite 函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(funcName, hookFuncName, <span class="built_in">strlen</span>(funcName)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取当前内存分页的大小</span></span><br><span class="line">        <span class="keyword">uint32_t</span> page_size = getpagesize();</span><br><span class="line">        <span class="comment">// 获取内存分页的起始地址（需要内存对齐）</span></span><br><span class="line">        <span class="keyword">uint32_t</span> mem_page_start = base_addr + rel_table[i].r_offset;</span><br><span class="line">        LOG_D(<span class="string">"hook_fwrite old_function=0x%08X new_function=0x%08X"</span>, mem_page_start,</span><br><span class="line">              new_fwrite);</span><br><span class="line">        LOG_D(<span class="string">"hook_fwrite mem_page_start=0x%08X page_size=%d"</span>, mem_page_start, page_size);</span><br><span class="line">        <span class="comment">// 6. 修改内存属性为可写</span></span><br><span class="line">        mprotect((<span class="keyword">uint32_t</span>) PAGE_START(mem_page_start), page_size,</span><br><span class="line">                 PROT_READ | PROT_WRITE | PROT_EXEC);</span><br><span class="line">        <span class="comment">// 7. 替换</span></span><br><span class="line">        *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *) (base_addr + rel_table[i].r_offset) = new_fwrite;</span><br><span class="line">        <span class="comment">// 8. 清除指令缓存</span></span><br><span class="line">        __builtin___clear_cache((<span class="keyword">void</span> *) PAGE_START(mem_page_start),</span><br><span class="line">                                (<span class="keyword">void</span> *) PAGE_END(mem_page_start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>第六步：修改内存属性为可写</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6. 修改内存属性为可写</span></span><br><span class="line">mprotect((<span class="keyword">uint32_t</span>) PAGE_START(mem_page_start), page_size,</span><br></pre></td></tr></table></figure><ul><li><strong>第七步：替换 hook 的函数</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 7. 替换</span></span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">int</span> *) (base_addr + rel_table[i].r_offset) = new_fwrite;</span><br></pre></td></tr></table></figure><ul><li><strong>第八步：恢复存属性为可读可执行(清除指令缓存)</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6. 清除指令缓存</span></span><br><span class="line">__builtin___clear_cache((<span class="keyword">void</span> *) PAGE_START(mem_page_start),</span><br></pre></td></tr></table></figure><p> <img src="/2021/05/25/android-native-ptl-hook/native_hook_7.png" width="100%" height="100%"><br> 导入表Hook流程图, 来源 <a href="https://gslab.qq.com/article-169-1.html" target="_blank" rel="noopener">Android平台导入表Hook方式实现</a></p><p>完整的代码，已放到 <a href="https://github.com/yxhuangCH/AndroidDemo/tree/master/AndroidNativeHook" target="_blank" rel="noopener">github</a></p><h1 id="三、优缺点及应用"><a href="#三、优缺点及应用" class="headerlink" title="三、优缺点及应用"></a>三、优缺点及应用</h1><h2 id="3-1-PTL-GOT-hook-的特点"><a href="#3-1-PTL-GOT-hook-的特点" class="headerlink" title="3.1 PTL/GOT hook 的特点"></a>3.1 PTL/GOT hook 的特点</h2><ul><li><ol><li>由于修改 GOT 表中的数据，因此修改后，所有对该函数进行调用的地方都会被 hook 到。影响范围是该 PLT 和 GOT 所处的整个 so 库；</li></ol></li><li><ol start="2"><li>PTL 与 GOT  表中仅仅包含本 ELF 需要调用的共享库函数，因此不在 PTL 中的函数无法 hook 到。</li></ol></li></ul><h2 id="3-2-使用场景"><a href="#3-2-使用场景" class="headerlink" title="3.2 使用场景"></a>3.2 使用场景</h2><ul><li><ol><li>可以大量 hook 系统 API, 但是难以精准 hook 某次函数调用。因此 PLT/GOT hook 适用开发者自家 APP 性能监控的需求；</li></ol></li><li><ol start="2"><li>一些函数不在 PLT 表和 GOT 表里，因此对这些 so 内部自定义的函数无法 hook 到；</li></ol></li><li><ol start="3"><li>在回调原函数方面， PLT hook 在 hook 目标函数时，如果需要回调原来的函数，那么在hook 之后的功能函数中直接调用目标函数即可</li></ol></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> new_fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> count, FILE *fp) &#123;</span><br><span class="line">    <span class="comment">// 插入文本</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *text = <span class="string">"hello native "</span>;</span><br><span class="line">    LOG_D(<span class="string">"new_fwrite hook fwrite success insert text: %s"</span>, text);</span><br><span class="line">    <span class="comment">// 直接调用原来的目标函数</span></span><br><span class="line">    old_fwrite(text, <span class="built_in">strlen</span>(text), <span class="number">1</span>, fp);</span><br><span class="line">    <span class="keyword">return</span> old_fwrite(buf, size, count, fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h1><h2 id="4-1-使用-xhook"><a href="#4-1-使用-xhook" class="headerlink" title="4.1 使用 xhook"></a>4.1 使用 xhook</h2><p>上面是具体是实现，如果是在正常的日常使用中，可以使用 <a href="https://github.com/iqiyi/xHook" target="_blank" rel="noopener">xhook</a></p><p><strong>使用 xhook 的步骤：</strong></p><ul><li><ol><li><strong>将 xhook 以 lib 形式集成</strong></li></ol></li><li><ol start="2"><li><strong>在主项目中引用这个 lib, 并将 xhook.h 文件放入都自己 cpp 路径中</strong></li></ol></li><li><ol start="3"><li><strong>注册要 hook 的 so 和 so 里面的函数</strong></li></ol></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_yxhuang_nativehook_NativeHook_xhookWrite(JNIEnv *env,jobject thiz, jstring hook_content)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *hookContent = (*env)-&gt;GetStringChars(env, hook_content, <span class="number">0</span>);</span><br><span class="line">    LOG_D(<span class="string">"xhookWrite hook_content=%s"</span>, hookContent);</span><br><span class="line"></span><br><span class="line">    xhook_register(<span class="string">"libnative-write.so"</span>, <span class="string">"writeText"</span>,</span><br><span class="line">            (<span class="keyword">void</span> *)xhook_write, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    xhook_refresh(<span class="number">0</span>);</span><br><span class="line">    xhook_clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ol start="4"><li><strong>提供替换 hook 的函数</strong></li></ol></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 替换的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">xhook_write</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *text)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 插入文本</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *textHook = <span class="string">"hello native "</span>;</span><br><span class="line">    LOG_D(<span class="string">"new_fwrite hook fwrite success insert text: %s"</span>, text);</span><br><span class="line">    writeText(path, textHook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>5.<strong>将生成的 hook 的 so 加载</strong></p><p><img src="/2021/05/25/android-native-ptl-hook/native_hook_6.png" width="100%" height="100%"></p></li></ul><h2 id="4-2-xhook-hook-的简要流程"><a href="#4-2-xhook-hook-的简要流程" class="headerlink" title="4.2 xhook hook 的简要流程"></a>4.2 xhook hook 的简要流程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">xhook_register --&gt; xh_core_register(...) </span><br><span class="line"></span><br><span class="line">xhook_refresh --&gt; xh_core_init_once()</span><br><span class="line">                    xh_core_refresh_impl()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xh_core_init_once --&gt; xh_core_add_sigsegv_handler()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xh_core_refresh_impl --&gt; xh_core_check_elf_header()</span><br><span class="line">                         xh_core_hook()</span><br><span class="line">                         xh_core_hook_impl()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xh_core_hook_impl --&gt; xh_elf_init()</span><br><span class="line">                      xh_elf_hook()</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.csdn.net/byhook/article/details/103500524?spm=1001.2014.3001.5502" target="_blank" rel="noopener">android中基于plt/got的hook实现原理</a></li><li><a href="https://github.com/iqiyi/xHook/blob/master/docs/overview/android_plt_hook_overview.zh-CN.md" target="_blank" rel="noopener">Android PLT hook 概述</a></li><li><a href="https://www.cnblogs.com/goodhacker/p/9296901.html" target="_blank" rel="noopener">Android so注入(inject)和Hook技术学习（一）</a></li><li><a href="https://www.cnblogs.com/goodhacker/p/9306997.html" target="_blank" rel="noopener">Android so注入(inject)和Hook技术学习（二）——Got表hook之导入表hook</a></li><li><a href="https://www.cnblogs.com/goodhacker/p/9313297.html" target="_blank" rel="noopener">Android so注入(inject)和Hook技术学习（三）——Got表hook之导出表hook</a></li><li><a href="https://gslab.qq.com/article-279-1.html" target="_blank" rel="noopener">【Android】ELF格式及动态加载过程</a></li><li><a href="https://gslab.qq.com/portal.php?mod=view&amp;aid=169" target="_blank" rel="noopener">Android平台导入表Hook方式实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;Android Native Hook 分成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GOT/PLT Hook &lt;/li&gt;
&lt;li&gt;Inline Hook&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇讲述 GOT/PLT Hook 的原理、具体实现以及它的优缺点&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Android" scheme="https://yxhuangch.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记|《程序员的自我修养》- 05 动态链接</title>
    <link href="https://yxhuangch.github.io/2021/05/05/linker-read-four/"/>
    <id>https://yxhuangch.github.io/2021/05/05/linker-read-four/</id>
    <published>2021-05-05T15:15:13.000Z</published>
    <updated>2021-05-05T23:36:56.481Z</updated>
    
    <content type="html"><![CDATA[<p>这章主要首先讲述了动态链接是为了解决静态链接浪费内存和磁盘资源的问题，同时更加方便升级程序。</p><p>动态链接需要面临装载地址不确定的问题，为了解决这个问题，引入了装载时重定位和地址无关代码这两个方法。然后讲述这两个方法的优缺点。同时还介绍了延迟绑定 PLT 技术。</p><p>中间讲述了 ELF 文件中的 ”.interp“, “.dyanmic”, 动态符号表、重定位表等结构。</p><p>最后还讲述了显示动态链接的概念，这个概念在 Android Ndk 的开发中需要应用，后续我会用特定的篇章讲述动态链接在 Android NDK 中的应用。</p><h1 id="一-动态链接"><a href="#一-动态链接" class="headerlink" title="一. 动态链接"></a>一. 动态链接</h1><h2 id="1-1-为什么需要动态链接"><a href="#1-1-为什么需要动态链接" class="headerlink" title="1.1 为什么需要动态链接"></a>1.1 为什么需要动态链接</h2><p>为了解决静态链接的空间浪费和更新困难问题，需要动态链接。</p><p>动态链接（Dynamic Linking）就是把不对那些组成程序的目标文件进行链接，而是把链接的过程推迟到运行时再进行。</p><h2 id="1-2-动态链接的基本实现"><a href="#1-2-动态链接的基本实现" class="headerlink" title="1.2 动态链接的基本实现"></a>1.2 动态链接的基本实现</h2><p>动态链接的基本思想是把程序安装模块拆分成各个相对独立部分，在程序运行时才会将它们链接在一起，形成一个完整程序，而不是像静态链接那样把所以的程序模块都链接成一个单独的可执行文件。</p><p>在 Linux 系统中， ELF 动态链接文件被称为<strong>动态共享对象（Dynamic Shared Objects）, 以 .so 为扩展名</strong></p><p>在 Window 中，被称为<strong>动态链接库（Dynamic Linking Library）, 以 .dll 为扩展名</strong></p><p>共享对象的最终装载地址在编译时是不确定的，而是在装载时，装载器根据当前地址空间的空闲情况，动态分配一块足够大小的虚拟地址空间给相应的共享对象。</p><p>例子：</p><p><img src="/2021/05/05/linker-read-four/linker_dy_1.jpg" width="80%" height="80%"></p><p>输出的结果</p><p><img src="/2021/05/05/linker-read-four/linker_dy_2.jpg" width="80%" height="80%"></p><h1 id="二-地址无关代码"><a href="#二-地址无关代码" class="headerlink" title="二. 地址无关代码"></a>二. 地址无关代码</h1><p>共享对象在编译时不能假设自己在进程虚拟地址空间中的位置，在链接时，对所有绝对地址的引用不作重定位，而是把这一步推迟到装载时在完成。</p><p>装载时重定位是解决动态模块中有绝对地址引用的方法之一。这时候会用到地址不关代码技术。</p><p><strong>地址无关代码（PIC, Position-independent Code）</strong>是指，程序模块中的指令部分在装载是不需要因为装载地址的改变而改变，所以实现的基本思想是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分可以保持不变，而数据部分可以在每个进程中拥有一个副本。</p><p>命令生成 pic 的 so</p><blockquote><p>$gcc -fPIC -shared -o Link4.so link4.c</p></blockquote><h2 id="2-1-模块内的调用类型"><a href="#2-1-模块内的调用类型" class="headerlink" title="2.1 模块内的调用类型"></a>2.1 模块内的调用类型</h2><p>安装共享模块中的地址引用按照是否为跨模块分成两类：模块内引用和模块外部引用；<br>按照不同的引用方法分为指令引用和数据访问</p><p>得到下面四种类型的地址引用方式：</p><ul><li>第一种是模块内的函数调用、跳转等。</li><li>第二种是模块内的数据访问，比如模块中定义的全局变量、静态变量等</li><li>第三种是模块外部的函数调用、跳转等</li><li>第四种是模块外部的数据访问，比如其他模块中定义的全局变量</li></ul><p>下图说明四种情况调用</p><p><img src="/2021/05/05/linker-read-four/dylink_img_5.png" width="80%" height="80%"></p><h3 id="2-1-1-类型一-模块内部调用或跳转"><a href="#2-1-1-类型一-模块内部调用或跳转" class="headerlink" title="2.1.1 类型一 模块内部调用或跳转"></a>2.1.1 类型一 模块内部调用或跳转</h3><p>模块内的跳转、函数调用是相对地址调用，或者是基于寄存器的相对调用，所以对于这类指令不需要重定位。</p><h3 id="2-1-2-类型二-模块内部数据访问"><a href="#2-1-2-类型二-模块内部数据访问" class="headerlink" title="2.1.2 类型二 模块内部数据访问"></a>2.1.2 类型二 模块内部数据访问</h3><p>指令中不能包含数据的绝对地址，只能使用相对寻址。</p><p>任何一条指令与它需要访问的模块内部数据之间的相对位置是固定的，只需要相对于当前指令加上固定的偏移量就可以访问数据内部数据。</p><p><img src="/2021/05/05/linker-read-four/dylink_img_6.png" width="80%" height="80%"></p><p>说明：<br>【缺，待补充】</p><h3 id="2-1-3-类型三-模块间数据访问"><a href="#2-1-3-类型三-模块间数据访问" class="headerlink" title="2.1.3 类型三 模块间数据访问"></a>2.1.3 类型三 模块间数据访问</h3><p>模块间的数据访问目标地址是要等到装载时才决定的，因此把跟地址相关的部分放到数据段里面。这些数据是和模块的加载地址是相关的。</p><p>ELF 的做法是建立一个<strong>全局偏移表（Global Offset Table, GOT）</strong>, 指向这些变量。当代码需要引用全局变量时，可以通过 GOT 中相对应的项间接引用。</p><p>GOT 以及后面要讲到的 PLT 在 Android 的 Native Hook 中有具体的应用，后续会用特定的篇章讲述这些应用。</p><p><img src="/2021/05/05/linker-read-four/dylink_img_7_1.png" width="80%" height="80%"></p><p>说明：<br>当指令要访问变量 b 时，程序先找到 GOT 表，然后根据 GOT 中变量所对应的项找到变量的目标地址</p><p>命令查看 GOT 的位置</p><blockquote><p>$objdump -h Link4.so</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">7 .plt          00000030  0000000000000510  0000000000000510  00000510  2**4</span><br><span class="line">                 CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 8 .plt.got      00000008  0000000000000540  0000000000000540  00000540  2**3</span><br><span class="line">                 CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 9 .text         00000113  0000000000000550  0000000000000550  00000550  2**4</span><br><span class="line">                 CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">10 .fini         00000009  0000000000000664  0000000000000664  00000664  2**2</span><br><span class="line">                 CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">11 .eh_frame_hdr 0000002c  0000000000000670  0000000000000670  00000670  2**2</span><br><span class="line">                 CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">12 .eh_frame     0000009c  00000000000006a0  00000000000006a0  000006a0  2**3</span><br><span class="line">                 CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">13 .init_array   00000008  0000000000200e48  0000000000200e48  00000e48  2**3</span><br><span class="line">                 CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">14 .fini_array   00000008  0000000000200e50  0000000000200e50  00000e50  2**3</span><br><span class="line">                 CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">15 .dynamic      00000180  0000000000200e58  0000000000200e58  00000e58  2**3</span><br><span class="line">                 CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">16 .got          00000028  0000000000200fd8  0000000000200fd8  00000fd8  2**3</span><br><span class="line">                 CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">17 .got.plt      00000028  0000000000201000  0000000000201000  00001000  2**3</span><br><span class="line">                 CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">18 .data         00000008  0000000000201028  0000000000201028  00001028  2**3</span><br><span class="line">                 CONTENTS, ALLOC, LOAD, DATA</span><br></pre></td></tr></table></figure><p>其中 got 段的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">16 .got          00000028  0000000000200fd8  0000000000200fd8  00000fd8  2**3</span><br></pre></td></tr></table></figure><p><strong>“.got”用来保存全局变量引用的地址，“.got.plt”用来保存函数引用的地址</strong></p><p>查看 so 文件需要重定位项</p><blockquote><p>$objdump -R Link4.so</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">yxhuang@yxhuang-virtual-machine:~/Desktop/linck/link4$ objdump -h link4.o</span><br><span class="line"></span><br><span class="line">link4.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         00000036  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000000  0000000000000000  0000000000000000  00000076  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000004  0000000000000000  0000000000000000  00000078  2**2</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .comment      0000002a  0000000000000000  0000000000000000  00000078  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000a2  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .eh_frame     00000058  0000000000000000  0000000000000000  000000a8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br></pre></td></tr></table></figure><p>变量 b 的地址需要重定位，它的偏移地址是 0x200fd8</p><p>这些信息存在动态链接的重定位表中，包含 ”rel.dyn“ 和 ”.rel.plt“</p><ul><li>”rel.dyn“ 表示对数据引用的修正，它修正的位置位于 ”.got“以及数据段；</li><li>”rel.plt“ 表示对函数的修正，它所修正的位置位于 ”.got.plt“</li></ul><p>通过命名查看动态链接的文件重定位表</p><blockquote><p>$readelf -r Link4.so</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -r Link4.so</span><br><span class="line"></span><br><span class="line">Relocation section &apos;.rela.dyn&apos; at offset 0x408 contains 8 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000200e48  000000000008 R_X86_64_RELATIVE                    620</span><br><span class="line">000000200e50  000000000008 R_X86_64_RELATIVE                    5e0</span><br><span class="line">000000201028  000000000008 R_X86_64_RELATIVE                    201028</span><br><span class="line">000000200fd8  000200000006 R_X86_64_GLOB_DAT 0000000000000000 b + 0</span><br><span class="line">000000200fe0  000300000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize + 0</span><br><span class="line">000000200fe8  000400000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCloneTa + 0</span><br><span class="line">000000200ff0  000500000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTMClone + 0</span><br><span class="line">000000200ff8  000600000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0</span><br><span class="line"></span><br><span class="line">Relocation section &apos;.rela.plt&apos; at offset 0x4c8 contains 2 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000201018  000100000007 R_X86_64_JUMP_SLO 0000000000000000 ext + 0</span><br><span class="line">000000201020  000a00000007 R_X86_64_JUMP_SLO 000000000000062a bar + 0</span><br></pre></td></tr></table></figure><p>$readelf -S Link4.so</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[16] .dynamic          DYNAMIC          0000000000200e58  00000e58</span><br><span class="line">       0000000000000180  0000000000000010  WA       4     0     8</span><br><span class="line">  [17] .got              PROGBITS         0000000000200fd8  00000fd8</span><br><span class="line">       0000000000000028  0000000000000008  WA       0     0     8</span><br><span class="line">  [18] .got.plt          PROGBITS         0000000000201000  00001000</span><br><span class="line">       0000000000000028  0000000000000008  WA       0     0     8</span><br><span class="line">  [19] .data             PROGBITS         0000000000201028  00001028</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     8</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="2-1-4-类型四-模块间调用和跳转"><a href="#2-1-4-类型四-模块间调用和跳转" class="headerlink" title="2.1.4 类型四 模块间调用和跳转"></a>2.1.4 类型四 模块间调用和跳转</h3><p>对应模块间的跳转、函数调用，可以用类型三的方法解决。<br>不过 GOT 中保存的是目标函数的地址。</p><p>例子：<br>当 foo() 方法里面要调用外部的的 ext() 函数时，先得到当前指令地址 PC, 然后加上一个偏移得到函数地址在 GOT 中的偏移，然后得到一个间接调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">000000000000001b &lt;foo&gt;:</span><br><span class="line">  1b:55                   push   %rbp</span><br><span class="line">  1c:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">  1f:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  24:e8 00 00 00 00       callq  29 &lt;foo+0xe&gt;</span><br><span class="line">  29:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  2e:e8 00 00 00 00       callq  33 &lt;foo+0x18&gt;</span><br><span class="line">  33:90                   nop</span><br><span class="line">  34:5d                   pop    %rbp</span><br><span class="line">  35:c3                   re</span><br></pre></td></tr></table></figure><p>其中 </p><blockquote><p>24:    e8 00 00 00 00           callq  29 &lt;foo+0xe&gt; </p></blockquote><p>是对 ext 的调用</p><p><strong>定义在模块内部的全局变量，也是可以当作定义在其他模块的全局变量，用类型4 解决</strong></p><h3 id="2-5-数据段地址无关性"><a href="#2-5-数据段地址无关性" class="headerlink" title="2.5 数据段地址无关性"></a>2.5 数据段地址无关性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static int a;</span><br><span class="line">static int* p = &amp;a;</span><br></pre></td></tr></table></figure><p>指针 p 的地址是一个绝对地址，指向变量 a 的地址，而变量 a 的地址会随着共享对象的装载地址改变而改变。</p><p>数据段，它在每个进程都有一份独立的副本。</p><p>装载时重定位的方法解决数据段中绝对地址引用问题。如果数据段中有绝对地址引用，编译器和链接器就会产生一个重定位表。</p><h1 id="三-延迟绑定"><a href="#三-延迟绑定" class="headerlink" title="三. 延迟绑定"></a>三. 延迟绑定</h1><p>动态链接比静态链接慢的原因：</p><ul><li><ol><li>动态链接下对全局和静态的数据访问都要进行复杂的 GOT 定位，然后间接寻址；对于模块间的调用也要先定位 GOT， 然后再进行间接跳转</li></ol></li><li><ol start="2"><li>动态链接的链接工作是在运行时完成</li></ol></li></ul><p>为了解决动态链接慢的问题，采取延迟绑定的方式。</p><p>延迟绑定（Lazy Binding) 是当函数第一次用到时才进行并对（符号查找、重定位等），如果没有用到则不进行绑定。</p><p>ELF 使用 <strong>PTL(Procedure Linkage Table)</strong> 的方式来实现。</p><p><strong>PTL 原理：当调用外部模块的函数时，通过 PTL 新增加的一层间接跳转。调用函数并不直接通过 GOT 跳转，而是通过一个叫作 PLT 项的结构来进行跳转。每个外部函数在 PLT 中都有一个相应的项。</strong></p><p>例子说明：<br>调用一个模块外的函数，需要知道这个函数所在的模块 moduleID 和 函数名称</p><p>以调用 bar() 函数说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bar@plt:</span><br><span class="line">jmp *(bar@GOT)</span><br><span class="line">push n</span><br><span class="line">push moduleID</span><br><span class="line">jmp _dl_runtime_resolve</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><strong>jmp *(bar@GOT)</strong> 是一条通过 GOT 跳转的指令。 bar@GOT 表示 GOT 中存有 bar() 函数相应的项。<br>链接器在初始化的时候没有将 bar() 的地址填入该项，而是调用下一条指令 <code>push n</code></li><li><strong>push n</strong> 表示将地址填入 bar@GOT, n 代表 bar 这个符号引用在重定位 “.rel.plt” 中的下标</li><li><strong>push modudeID</strong> 表示将模块 ID 压入到堆栈中</li><li><strong>jmp _dl_runtime_resolve</strong> 表示跳转到 <code>_dl_runtime_resolve</code> ，将 bar() 的真正地址填入到 bar@GOT 中。</li></ul><p>一旦 bar() 这个函数被解析完毕，当我们再次调用 bar@plt 时，第一条 jmp 指令就能够跳转到真正的 bar() 函数中，bar() 函数返回的时候会根据堆栈里面保存的 EIP 直接返回调用者，而不会再继续执行 bar@plt 中后面的代码。</p><p><img src="/2021/05/05/linker-read-four/dylink_img_9.png" width="80%" height="80%"></p><p>“.got.plt”说明</p><ul><li>第一项保存的是 “.dynamic” 段的地址，这个段描述了本模块动态链接相关的信息</li><li>第二项是保存本模块的 ID</li><li>第三项保存的是 “_dl_runtime_resolve()” 的地址</li></ul><p>例子说明<br>第一次加载时</p><p><img src="/2021/05/05/linker-read-four/dylink_plt_1.png" width="80%" height="80%"></p><p>之后的调用</p><p><img src="/2021/05/05/linker-read-four/dylink_plt_2.png" width="80%" height="80%"></p><p>上面两个图来自<a href="https://www.jianshu.com/p/0ac63c3744dd" target="_blank" rel="noopener">GOT表和PLT表</a></p><h1 id="四-动态链接相关结构"><a href="#四-动态链接相关结构" class="headerlink" title="四. 动态链接相关结构"></a>四. 动态链接相关结构</h1><p>操作系统在装载完可执行文件、映射完之后，操作系统会启动一个<strong>动态链接器（Dynamic Linker）</strong>。当所有动态链接工作完成之后，动态链接器会将控制权转交到可执行文件的入口地址，程序正式执行。</p><h2 id="4-1-“-interp”-段"><a href="#4-1-“-interp”-段" class="headerlink" title="4.1 “.interp” 段"></a>4.1 “.interp” 段</h2><p>“.interp” 段只有一个字符串，保存的就是就是动态链接器的路径</p><h2 id="4-2-“-dynamic”-段"><a href="#4-2-“-dynamic”-段" class="headerlink" title="4.2 “.dynamic” 段"></a>4.2 “.dynamic” 段</h2><p>“.dynamic” 段保存了动态链接器所需要的基本信息。</p><p>结构是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    Elf32_Sword d_tag;  </span><br><span class="line">    union&#123;</span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure><table><thead><tr><th>d_tag 类型</th><th>d_un 的类型</th></tr></thead><tbody><tr><td>DT_SYMTAB</td><td>动态链接符号表的地址， d_ptr 表示 “.dynsym” 的地址</td></tr><tr><td>DT_STRTAB</td><td>动态链接字符串表地址，d_ptr 表示 ”.dynstr“ 的地址</td></tr><tr><td>DT_STRSZ</td><td>动态链接字符串表大小，d_val 表示大小</td></tr><tr><td>DT_HASH</td><td>动态链接哈希表地址， d_ptr 表示 “.hash” 的地址</td></tr><tr><td>DT_SONAME</td><td>本共享对象的 ”SO-NAME”</td></tr><tr><td>DT_RPATH</td><td>动态链接共享对象搜索地址</td></tr><tr><td>DT_INIT</td><td>初始化代码地址</td></tr><tr><td>DT_FINIT</td><td>结束代码地址</td></tr><tr><td>DT_NEED</td><td>依赖的共享对象文件，d_ptr 表示所依赖的共享对象文件名</td></tr><tr><td>DT_REL \n DT_RELA</td><td>动态链接重定位表地址</td></tr><tr><td>DT_RELENT \n DT_RELAENT</td><td>动态重读位表入口数量</td></tr></tbody></table><p>查看 so 文件中  ”.dynamic“ 段的内容</p><blockquote><p>$readelf -d Link4.so</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Dynamic section at offset 0xe58 contains 20 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x000000000000000c (INIT)               0x4f8</span><br><span class="line"> 0x000000000000000d (FINI)               0x664</span><br><span class="line"> 0x0000000000000019 (INIT_ARRAY)         0x200e48</span><br><span class="line"> 0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)</span><br><span class="line"> 0x000000000000001a (FINI_ARRAY)         0x200e50</span><br><span class="line"> 0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)</span><br><span class="line"> 0x000000006ffffef5 (GNU_HASH)           0x1f0</span><br><span class="line"> 0x0000000000000005 (STRTAB)             0x380</span><br><span class="line"> 0x0000000000000006 (SYMTAB)             0x230</span><br><span class="line"> 0x000000000000000a (STRSZ)              135 (bytes)</span><br><span class="line"> 0x000000000000000b (SYMENT)             24 (bytes)</span><br><span class="line"> 0x0000000000000003 (PLTGOT)             0x201000</span><br><span class="line"> 0x0000000000000002 (PLTRELSZ)           48 (bytes)</span><br><span class="line"> 0x0000000000000014 (PLTREL)             RELA</span><br><span class="line"> 0x0000000000000017 (JMPREL)             0x4c8</span><br><span class="line"> 0x0000000000000007 (RELA)               0x408</span><br><span class="line"> 0x0000000000000008 (RELASZ)             192 (bytes)</span><br><span class="line"> 0x0000000000000009 (RELAENT)            24 (bytes)</span><br><span class="line"> 0x000000006ffffff9 (RELACOUNT)          3</span><br><span class="line"> 0x0000000000000000 (NULL)               0x0</span><br></pre></td></tr></table></figure><p>查看一个主模块或者一个共享库依赖于哪些共享库</p><blockquote><p>$ldd Program1</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ldd Program1</span><br><span class="line">linux-vdso.so.1 (0x00007ffcc39ee000)</span><br><span class="line">./Lib.so (0x00007f45c4be1000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f45c47f0000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f45c4fe5000)</span><br></pre></td></tr></table></figure><h2 id="4-3-动态符号表"><a href="#4-3-动态符号表" class="headerlink" title="4.3 动态符号表"></a>4.3 动态符号表</h2><p>动态符号表用来保存模块间符号导入导出关系</p><p>“.dynsym” 段保存了与动态链接相关的符号</p><p>”.dynstr“ 动态符号字符串表</p><p>为了加快符号表查找过程，需要辅助的符号哈希表（”.hash”）,查看</p><blockquote><p>$readelf -sD Link4.so</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -sD Link4.so</span><br><span class="line"></span><br><span class="line">Symbol table of `.gnu.hash&apos; for image:</span><br><span class="line">  Num Buc:    Value          Size   Type   Bind Vis      Ndx Name</span><br><span class="line">    7   0: 0000000000000648    27 FUNC    GLOBAL DEFAULT  10 foo</span><br><span class="line">    8   0: 0000000000201030     0 NOTYPE  GLOBAL DEFAULT  19 _edata</span><br><span class="line">    9   0: 0000000000201038     0 NOTYPE  GLOBAL DEFAULT  20 _end</span><br><span class="line">   10   0: 000000000000062a    30 FUNC    GLOBAL DEFAULT  10 bar</span><br><span class="line">   11   1: 00000000000004f8     0 FUNC    GLOBAL DEFAULT   7 _init</span><br><span class="line">   12   1: 0000000000201030     0 NOTYPE  GLOBAL DEFAULT  20 __bss_start</span><br><span class="line">   13   2: 0000000000000664     0 FUNC    GLOBAL DEFAULT  11 _fini</span><br></pre></td></tr></table></figure><h1 id="五-动态链接的步骤和实现"><a href="#五-动态链接的步骤和实现" class="headerlink" title="五. 动态链接的步骤和实现"></a>五. 动态链接的步骤和实现</h1><p>动态链接基本上分为 3 个步骤：</p><ul><li>1.启动动态链接器本身</li><li>2.装载所有需要的共享对象</li><li>4.重定位和初始化</li></ul><h2 id="5-1-启动动态链接器本身"><a href="#5-1-启动动态链接器本身" class="headerlink" title="5.1 启动动态链接器本身"></a>5.1 启动动态链接器本身</h2><p>动态链接器本身是一个共享对象。在加载动态链接器的时候，它是自举的，它不依赖与其他任何共享对象；并且它本身所需要的全局和静态变量的重定位由它本身完成。</p><h2 id="5-2-装载共享对象"><a href="#5-2-装载共享对象" class="headerlink" title="5.2 装载共享对象"></a>5.2 装载共享对象</h2><p>当动态链接器将可执行文件和链接器本身的符号表都合并到<strong>全局符号表（Global Symbol Table）</strong>, 然后链接器开始寻找可执行文件依赖的共享对象。如果这个 ELF 共享对象还依赖于其他共享对象，那么将依赖的共享对象的名字放到装载集合中。如果是多个依赖，则链接器使用深度优先或者广度优先算法顺序遍历所有依赖的共享对象。<br>。<br>在装载的过程中，如果一个符号在加入全局符号表时，有相同的符号名已经存在，则后加入的符号被忽略</p><h2 id="5-3-重定位和初始化"><a href="#5-3-重定位和初始化" class="headerlink" title="5.3 重定位和初始化"></a>5.3 重定位和初始化</h2><p>在完成上面的两个步骤之后，链接器开始重新遍历可执行文件和每个共享对象的重定位表， 将它们的 GOT/PLT 中的每个需要重定位的位置进行修正。<br>重定位之后，如果某个共享对象有 “.init” 段，则动态链接器会执行 “.init” 段中的代码，进行初始化过程。<br>在完成重定位和初始化之后，链接器将进程的控制权教给程序入口并且开始执行。</p><h1 id="六-显示运行时链接"><a href="#六-显示运行时链接" class="headerlink" title="六. 显示运行时链接"></a>六. 显示运行时链接</h1><p>显示运行时链接（Explicit Run-time Linking） 也叫运行时加载，就是让程序自己在运行时控制加载指定的模块，并且可以在不需要垓模块时将其卸载。</p><h2 id="6-1-dlopen"><a href="#6-1-dlopen" class="headerlink" title="6.1 dlopen()"></a>6.1 dlopen()</h2><p>dlopen() 函数用来打开一个动态库，并将其加载到进程的地址空间，完成初始化过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void * dlopen(const char*filename, int flag);</span><br></pre></td></tr></table></figure><p>说明</p><ul><li><strong>filename</strong> 是被加载动态库的路径，如果是绝对路径（以 “/” 开始的路径），则直接加载；如果是相对路径，则按一定顺序加载<ul><li>1).查找有环境变量 LD_LIBRARY_PATH 指定的一系列目录</li><li>2).查找有 /etc/ld.so.cache 里面所指定的共享库路径</li><li>3). /lib, /usr/lib </li></ul></li><li><strong>flag</strong> 表示函数符号的解析方式<ul><li>RTLD_LAZY 表示使用延迟绑定，当函数第一次被用到时才进行绑定，即 PTL 机制</li><li>RTLD_NOW 表示当模块被加载时即完成所有函数的绑定工作，如果有任何未定义的符号引用的绑定工作没法完成， dlopen() 就返回错误</li></ul></li></ul><p>dlopen() 返回是被加载模块的句柄，这个句柄在使用 dlsym 或者 dlclose 时用到</p><p>关于 so 在 Android 中的加载过程参考<a href="https://github.com/yxhuangCH/CSLearn/blob/master/android/AndroidSo%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.md" target="_blank" rel="noopener">Android 动态链接库 So 的加载</a></p><h2 id="6-2-dlsym"><a href="#6-2-dlsym" class="headerlink" title="6.2 dlsym()"></a>6.2 dlsym()</h2><p>dlsym() 函数是找到需要的符号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *dlsym(void * handle, chat *symbol);</span><br></pre></td></tr></table></figure><ul><li><strong>handle</strong>， 就是 dlopen 的返回</li><li><strong>symbol</strong>， 就是要找的符号</li></ul><h2 id="6-3-dlerror"><a href="#6-3-dlerror" class="headerlink" title="6.3 dlerror()"></a>6.3 dlerror()</h2><p>在调用完 dlopen() ， dlsym() 或者 dlclose() 之后，可以用 dlerror() 判断上一次调用是否成功</p><h2 id="6-4-dlclose"><a href="#6-4-dlclose" class="headerlink" title="6.4 dlclose()"></a>6.4 dlclose()</h2><p>dlclose() 是卸载已经被加载的模块</p><h1 id="七-其他"><a href="#七-其他" class="headerlink" title="七.其他"></a>七.其他</h1><h2 id="7-1-示例代码"><a href="#7-1-示例代码" class="headerlink" title="7.1 示例代码"></a>7.1 示例代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> b;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">ext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    bar();</span><br><span class="line">    ext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这章主要首先讲述了动态链接是为了解决静态链接浪费内存和磁盘资源的问题，同时更加方便升级程序。&lt;/p&gt;
&lt;p&gt;动态链接需要面临装载地址不确定的问题，为了解决这个问题，引入了装载时重定位和地址无关代码这两个方法。然后讲述这两个方法的优缺点。同时还介绍了延迟绑定 PLT 技术。&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>读书笔记|《程序员的自我修养》- 04 可执行文件的装载与进程</title>
    <link href="https://yxhuangch.github.io/2021/05/05/linker-read-third/"/>
    <id>https://yxhuangch.github.io/2021/05/05/linker-read-third/</id>
    <published>2021-05-05T15:04:07.000Z</published>
    <updated>2021-05-05T15:12:19.203Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>这一章讲述了操作系统入口将 ELF 文件装载到内存的过程。</p><h1 id="一-装载的方式"><a href="#一-装载的方式" class="headerlink" title="一.装载的方式"></a>一.装载的方式</h1><p>程序在运行时有局部性原理，可以将程序最常用的部分驻留在内存中，将不常用的数据存放在磁盘里。</p><p>加载的时候采用<strong>页映射</strong>的方式，也映射就是把部分程序的数据和指令按“页（page）” 为单位划分成若干个页，以后所有的装载和操作的单位就是页。</p><h1 id="二-装载的过程"><a href="#二-装载的过程" class="headerlink" title="二.装载的过程"></a>二.装载的过程</h1><p>操作系统加载目标文件的过程主要分为三步：</p><ul><li>创建一个独立的虚拟地址空间</li><li>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系</li><li>将 CPU 的指令寄存器设置成可执行文件的入口地址，启动运行</li></ul><h2 id="2-1-创建一个独立的虚拟地址空间"><a href="#2-1-创建一个独立的虚拟地址空间" class="headerlink" title="2.1 创建一个独立的虚拟地址空间"></a>2.1 创建一个独立的虚拟地址空间</h2><p> 创建进程，就是创建一个独立的虚拟地址空间，虚拟空间由一组页映射函数将虚拟空间的各个页映射至相应的物理空间。</p><h2 id="2-2-读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系"><a href="#2-2-读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系" class="headerlink" title="2.2 读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系"></a>2.2 读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系</h2><p><strong>这一步主要做的是，建立虚拟空间与可执行文件的映射关系,这种映射关系只是保存在操作系统内部的一个数据结构。</strong></p><p>建立映射时，是将权限相同的 section 合并到一个 Segment, 再进行映射。这样可以节约内存。</p><p>ELF 中一般是一下的三种组合：</p><ul><li>以代码段为代表的权限为可读可执行的段</li><li>以数据段和 BSS 段为代表的权限为可读可写的段</li><li>以只读数据段为代表的权限为只读的段</li></ul><p><img src="/2021/05/05/linker-read-third/ELF_Segment-1.png" width="80%" height="80%"></p><p>上图就是例子，左边是没有合并 Segment 进行映射，右边是合并 Segment 进行映射的。.init 和 .text 段都是权限相同、可读可执行的段，将它们合并成通过 Segment 进行映射，节约了内存空间</p><p>通过命名可以查看 ELF 文件中哪些段合并了 Segment </p><blockquote><p>$readelf -l Link5.elf</p></blockquote><p><img src="/2021/05/05/linker-read-third/dylink_load_1.png" width="80%" height="80%"></p><h2 id="2-3-将-CPU-的指令寄存器设置成可执行文件的入口地址，启动运行"><a href="#2-3-将-CPU-的指令寄存器设置成可执行文件的入口地址，启动运行" class="headerlink" title="2.3 将 CPU 的指令寄存器设置成可执行文件的入口地址，启动运行"></a>2.3 将 CPU 的指令寄存器设置成可执行文件的入口地址，启动运行</h2><p>操作系统通过设置 CPU 的指令寄存器将控制权转交给进程,程序由此开始运行。这个地址是在 ELF 头文件中保存的</p><p>程序运行时会产生一个<strong>“页错误（Page Fault）”</strong>,这是因为在 2.2 步，操作系统仅仅只是通过可执行文件的头文件信息建立可执行文件和进程虚拟空间的映射关系而已，并没有加载可执行文件的真正指令和数据到内存。</p><p>操作系统处理页错误后，把指令和数据加载进内存，计算出相应的页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页与分配的物理页建立映射关系，控制权交回给进程，程序重新开始运行。</p><h1 id="三-堆和栈"><a href="#三-堆和栈" class="headerlink" title="三.堆和栈"></a>三.堆和栈</h1><p>操作系统通过给进程空间划分一个个 VMA（虚拟内存空间） 来管理进程的虚拟空间；基本原则是将相同属性的、有相同映像文件的映射成一个 VMA.</p><p>一个进程基本上划分为以下结果 VMA 区域：</p><ul><li>代码 VMA , 权限只读、可执行；有映像文件；</li><li>数据 VMA, 权限可读写、可执行；有映像文件；</li><li>堆 VMA, 权限可读写、可执行；无映像文件，匿名，可向上扩展；</li><li>栈 VMA, 权限可读写、不可以执行；无映像文件，匿名，可向下扩展。</li></ul><p><img src="/2021/05/05/linker-read-third/dylink_load_2.png" width="80%" height="80%"></p><h1 id="四-Linux-内核装载-ELF-过程"><a href="#四-Linux-内核装载-ELF-过程" class="headerlink" title="四. Linux 内核装载 ELF 过程"></a>四. Linux 内核装载 ELF 过程</h1><ul><li><ol><li>检测 ELF 可执行文件的有效性，例如魔数，程序头表中 Segment 的数量；</li></ol></li><li><ol start="2"><li>寻找动态链接的 “.interp” 段，设置动态链接器路径</li></ol></li><li><ol start="3"><li>根据 ELF 可执行文件的程序头表的描述，对 ELF 文件进行映射，例如代码、数据、只读数据</li></ol></li><li><ol start="4"><li>初始化 ELF 进程环境，例如进程启动时 EDX 寄存器的地址应该是 DT_FINI 的地址</li></ol></li><li><ol start="5"><li>将系统调用的返回地址修改成 ELF 可执行文件的入口点，这个入口点取决于程序的链接方式，对于静态链接的 ELF 可执行文件，这个程序入口是 ELF 文件头中 e_entry 所指的地址；对于动态链接的 ELF 可执行文件，程序入口点是动态链接器。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;这一章讲述了操作系统入口将 ELF 文件装载到内存的过程。&lt;/p&gt;
&lt;h1 id=&quot;一-装载的方式&quot;&gt;&lt;a href=&quot;#一-装载的方式&quot; class=&quot;headerlink&quot; title=&quot;一.装载的方式&quot;&gt;&lt;/a&gt;一.装载的方式&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="程序员的自我修养" scheme="https://yxhuangch.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记|《程序员的自我修养》- 03 静态链接</title>
    <link href="https://yxhuangch.github.io/2021/05/05/linker-read-two/"/>
    <id>https://yxhuangch.github.io/2021/05/05/linker-read-two/</id>
    <published>2021-05-05T14:00:38.000Z</published>
    <updated>2021-05-05T14:59:36.115Z</updated>
    
    <content type="html"><![CDATA[<p>这是《程序员自我修养–链接、装载与库》读书笔记的第三篇，静态链接。</p><p><strong>简单来说静态链接将多个目标文件性质相同部分，合并写入到输出目标文件中，然后将符号解析并且对外部引用符号重新定位。</strong></p><p><strong>目标文件的链接分为静态链接和动态链接</strong>。</p><p><strong>静态链接</strong>是以多个重定位目标文件和命令参数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件的过程。</p><p>这个过程由链接器完成，<strong>链接器主要的任务就是符号解析（sysbol resolution） 和重定位（relocation）</strong></p><p><strong>动态链接（Dynamic Linking)</strong> 为了解决静态链接中存在的空间浪费和更新困难的问题，把程序的模块相互分割开来，形成独立文件，不是将它们静态链接到一起。把链接过程推迟到运行时进行，这就是动态链接。</p><h2 id="一、空间与地址分配"><a href="#一、空间与地址分配" class="headerlink" title="一、空间与地址分配"></a>一、空间与地址分配</h2><p>链接器是将多个目标文件相同性质的段合并到一起，并为目标文件分配地址和空间。<br>这里的地址和空间一是指在输出的可执行文件中的空间，二是指在转载后的虚拟地址中的虚拟地址空间。</p><p>链接器分两步链接：</p><ul><li><strong>1.空间与地址分配</strong></li></ul><p>扫描所有的输入目标文件，获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有符号定义和符号引用收集起来，统一放到一个全局符号表。</p><ul><li><strong>2.符号解析和重定位</strong></li></ul><p>使用第一步收集到的信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。</p><p><img src="/2021/05/05/linker-read-two/linker_static_1.png" width="80%" height="80%"></p><p>例子：</p><h3 id="1-1-符号地址的确定"><a href="#1-1-符号地址的确定" class="headerlink" title="1.1 符号地址的确定"></a>1.1 符号地址的确定</h3><p>Linux 下， ElF 可执行文件默认地址从 0x08048000 开始分配。</p><p>在扫描和空间分配阶段，链接器对空间进行分配，这个时候各个段在链接后的虚拟地址已经确定。各个符号在段内的相对位置是固定的，它们在合并后的位置等于段位置虚拟地址加上偏移地址</p><p><strong>合并后目标文件中的符号地址 = 段虚拟地址 + 偏移地址</strong></p><p><img src="/2021/05/05/linker-read-two/linker_static_2.png" width="80%" height="80%"></p><h2 id="二、符号解析与重定位"><a href="#二、符号解析与重定位" class="headerlink" title="二、符号解析与重定位"></a>二、符号解析与重定位</h2><h3 id="2-1-重定位"><a href="#2-1-重定位" class="headerlink" title="2.1 重定位"></a>2.1 重定位</h3><p>当源文件有外部符号，编译的时候，会把外部符号的地址用 0 替代，所以，把原始目标文件需要重定位。</p><p>链接器根据重定位表（Relocation Table） 获取重定位的信息.</p><p>重定位表在目标文件的 ”.rel.text“ 段</p><p><strong>重新定位入口的结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Efl32_Addr r_offset;</span><br><span class="line">    Elf32_Word r_info;</span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>r_offset， 重定位入口的偏移</li><li>r_info， 重定位入口的类型和符号</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a.o:     file format mach-o-x86-64</span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">000000000000001b BRANCH32          _swap</span><br><span class="line">000000000000000b GOT_LOAD          _shared</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [__LD.__compact_unwind]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000000000 64                .text</span><br></pre></td></tr></table></figure><h3 id="2-2-符号解析"><a href="#2-2-符号解析" class="headerlink" title="2.2 符号解析"></a>2.2 符号解析</h3><p>目标文件中外部符号时，需要在重定位的时候对这个符号进行解析。</p><p>在重定位时，链接器查找所有输入目标文件的符号组成的全局符号表，找到相应的符号后进行重定位。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ld a.o</span><br><span class="line"></span><br><span class="line">Undefined symbols for architecture x86_64:</span><br><span class="line">  &quot;_shared&quot;, referenced from:</span><br><span class="line">      _main in a.o</span><br><span class="line">  &quot;_swap&quot;, referenced from:</span><br><span class="line">      _main in a.o</span><br><span class="line">ld: symbol(s) not found for architecture x86_64</span><br></pre></td></tr></table></figure><p>在 a.c 文件中， <code>shared</code> 和  <code>swap</code> 是 b.c 文件中定义的，直接有 ld 链接 a.o 会发现这两个符号未定义</p><h3 id="2-3-指令修正"><a href="#2-3-指令修正" class="headerlink" title="2.3 指令修正"></a>2.3 指令修正</h3><p>不同的处理器指令对于地址的格式和方式是不一样的，因此一些指令需要修正。</p><p>重定位入口 r_info 成员低 8 位表示重定位入口类型</p><table><thead><tr><th>宏定义</th><th>值</th><th>重定位修正方法</th></tr></thead><tbody><tr><td>R_368_32</td><td>1</td><td>绝对寻址修正 S + A</td></tr><tr><td>R_386_PC32</td><td>2</td><td>相对寻址修正 S + A - P</td></tr></tbody></table><p>A = 保存在被修正位置的值<br>P = 被修正的位置（相对于段开始的偏移量或者虚拟地址），注意，该值可通过 r_offset 计算得到<br>S = 符号的实际地址，即由 r_info</p><p><strong>绝对寻址修正</strong></p><p>绝对修正是 R_368_32 类型<br>修正后的地址是 S +  A;</p><p><strong>相对寻址修正</strong></p><p>相对修正是 R_386_PC32 类型<br>修正后的地址是 S + A - P</p><h2 id="三、弱符号解析"><a href="#三、弱符号解析" class="headerlink" title="三、弱符号解析"></a>三、弱符号解析</h2><p>由于弱符号机制允许同一个符号的定义存在于多个文件中，会导致问题：如果一个弱符号定义在多个目标文件中，它们的类型有不同，就会面临多个符号定义不一致的情况。</p><p>主要分三种情况：</p><ul><li>两个或两个以上强符号类型不一致；</li><li>有一个强符号，其他都是弱符号，出现类型不一致；</li><li>两个或两个以上弱符号类型不一致</li></ul><p>弱符号链接的规则在 .common 段中。</p><p>对第一种情况，链接器会报符号多重定义错误，不需要处理；</p><p>对第二种情况，输出结果中的符号所占空间以强符号的为准；</p><p>对第三种情况，输出结果以输入文件中最大的那个为准；</p><h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h2><p>编译遇到问题：</p><ul><li>undefined reference to `__stack_chk_fail</li></ul><p><img src="/2021/05/05/linker-read-two/linker_static_3.png" width="80%" height="80%"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是《程序员自我修养–链接、装载与库》读书笔记的第三篇，静态链接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单来说静态链接将多个目标文件性质相同部分，合并写入到输出目标文件中，然后将符号解析并且对外部引用符号重新定位。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目标文件的链接
      
    
    </summary>
    
    
      <category term="程序员的自我修养" scheme="https://yxhuangch.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记|《程序员的自我修养》- 02 目标文件</title>
    <link href="https://yxhuangch.github.io/2021/03/28/linker-read-one/"/>
    <id>https://yxhuangch.github.io/2021/03/28/linker-read-one/</id>
    <published>2021-03-28T14:41:30.000Z</published>
    <updated>2021-05-05T14:59:33.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、目标文件的格式"><a href="#一、目标文件的格式" class="headerlink" title="一、目标文件的格式"></a>一、目标文件的格式</h1><p>目标文件是源代码编译后但为进行链接的那些中间文件（Window 的 .obj 和 Linux 下的 .o）</p><p>动态链接库（DLL, Dynamic Linking Library）, Window 是 .dll， Linux 是 .so<br>静态链接库（Static Linking Library）, Window 是 .lib 和 Linux 是 .a</p><p>可执行文件格式是 ELF</p><h1 id="二、目标文件的文件类型"><a href="#二、目标文件的文件类型" class="headerlink" title="二、目标文件的文件类型"></a>二、目标文件的文件类型</h1><p><img src="/2021/03/28/linker-read-one/type.png" width="80%" height="80%"></p><p>命令 file 查看文件的类型格式<br>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; file libdycloudmedia.so </span><br><span class="line">libdycloudmedia.so: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, BuildID[sha1]=2bcf3eae561f0f6ca25b0f2abd0728eef68f9ea3, stripped</span><br></pre></td></tr></table></figure><h1 id="三、目标文件的内容"><a href="#三、目标文件的内容" class="headerlink" title="三、目标文件的内容"></a>三、目标文件的内容</h1><p><img src="/2021/03/28/linker-read-one/obj_type.png" width="80%" height="80%"></p><h2 id="3-1-可执行文件的内容"><a href="#3-1-可执行文件的内容" class="headerlink" title="3.1 可执行文件的内容"></a>3.1 可执行文件的内容</h2><p>程序源代码编译后的机器指令经常被放在<strong>代码段（Code Section）</strong>, 代码段常见的字有 “.code” 或 ”.text”</p><p>全局变量和局部变量数据经常放在<strong>数据段（Data Section）</strong></p><p>总体来说，源程序代码被编译以后主要分成两种段，程序指令和程序数据。代码段属于程序指令，而数据段和.bss 属于程序数据</p><p>将数据和指令分段的好处：</p><ul><li>程序被装载后，数据和指令分别被映射到两个虚拟区域。数据区对于进程是可读写，指令区对于进程是只读，这两个两个区域的权限分别设置为可读写和只读。这样防止程序指令被破坏</li><li>充分利用 CPU 的缓存，提供命中率</li><li>当系统中存在该程序的副本时，可以共享指令，节约内存。</li></ul><p><strong>查看 ELF 各段的基本信息</strong></p><blockquote><p>objdump -h SimpleSection.o<br>-h 将 ELF 文件的各个段的基本信息打印出来</p></blockquote><p><img src="/2021/03/28/linker-read-one/16163130180870.png" width="80%" height="80%"></p><p><strong>查看ELF文件的代码段、数据段、和 BSS 段的长度</strong></p><blockquote><p>size SimpleSection.o</p></blockquote><p><img src="/2021/03/28/linker-read-one/16163131604327.png" width="80%" height="80%"></p><h2 id="3-2-文件头-HEADER"><a href="#3-2-文件头-HEADER" class="headerlink" title="3.2 文件头 HEADER"></a>3.2 文件头 HEADER</h2><p>ELF 目标文件最前面的是 ELF 文件头，它包含描述整个文件的基本属性，例如 ELF 文件版本、目标机器型号、程序入口等</p><p>查看</p><blockquote><p>$readelf -h SimpleSection.o  // linex 用 </p></blockquote><blockquote><p>$otool -h SimpleSection.o  // mac 使用</p></blockquote><p><img src="/2021/03/28/linker-read-one/16163150711009.png" width="80%" height="80%"></p><h2 id="3-3-代码段-text"><a href="#3-3-代码段-text" class="headerlink" title="3.3 代码段 .text"></a>3.3 代码段 .text</h2><p>使用命令下面命令查看</p><blockquote><p>objdump -s -d SimpleSection.o<br>-s 参数表示将所有段的内容以十六进制的方式打印出来<br>-d 参数将所有包含指令的段反汇编</p></blockquote><p><img src="/2021/03/28/linker-read-one/16163111896910.png" width="80%" height="80%"></p><h2 id="3-3-数据段和只读数据段-data"><a href="#3-3-数据段和只读数据段-data" class="headerlink" title="3.3 数据段和只读数据段 .data"></a>3.3 数据段和只读数据段 .data</h2><p>.data 段保存已经初始化了的全局静态变量和局部静态变量</p><p>.rodata 段存放只读数据,(mac 里面是 cstring )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Contents of section __data:</span><br><span class="line"> 0068 54000000 55000000                    T...U...</span><br><span class="line">Contents of section __cstring:</span><br><span class="line"> 0070 25640a00                             %d..</span><br></pre></td></tr></table></figure><h2 id="3-4-BSS-段"><a href="#3-4-BSS-段" class="headerlink" title="3.4 BSS 段"></a>3.4 BSS 段</h2><p>.bss 段存放未初始化的全局变量和局部静态变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Contents of section __bss:</span><br><span class="line">&lt;skipping contents of bss section at [0120, 0124)&gt;</span><br></pre></td></tr></table></figure><h1 id="四、ELF-文件结构描述"><a href="#四、ELF-文件结构描述" class="headerlink" title="四、ELF 文件结构描述"></a>四、ELF 文件结构描述</h1><p><strong>链接过程的本质就是要把多个不同的目标文件之间相互”粘“到一起，或者说像玩具积木一样，可以拼成一个整体</strong></p><p>符号是链接过程的粘合剂</p><h2 id="4-1-重新定位表-rel-text"><a href="#4-1-重新定位表-rel-text" class="headerlink" title="4.1  重新定位表 .rel.text"></a>4.1  重新定位表 .rel.text</h2><p>链接器在处理目标文件时，必须要对目标文件中某些部位进行重定位</p><h2 id="4-2-符号"><a href="#4-2-符号" class="headerlink" title="4.2  符号"></a>4.2  符号</h2><p>链接过程的本质就是把不同的目标文件相互“粘”到一起，拼成一个整体。符号就是链接中的粘合剂，整个链接过程正是基于符号才能正确完成的。</p><p>查看符号表</p><blockquote><p>$ nm SimpleSection.o</p></blockquote><p><img src="/2021/03/28/linker-read-one/16163116226334.png" width="80%" height="80%"></p><p><strong>ELF 符号表结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word st_name;     <span class="comment">// 符号名</span></span><br><span class="line">    Efl32_Addr st_value;    <span class="comment">// 对应的值</span></span><br><span class="line">    Elf32_Word st_size;     <span class="comment">// 符号大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;  <span class="comment">// 符号类型和绑定信息</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other; <span class="comment">// 0, 暂时没有用途</span></span><br><span class="line">    Elf32_Half st_shndx;    <span class="comment">// 符号所在的段</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/28/linker-read-one/sysmbol.png" width="80%" height="80%"></p><h1 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h1><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* fromt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_init_var = <span class="number">84</span>;</span><br><span class="line"><span class="keyword">int</span> global_uninit_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_var = <span class="number">85</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_var2;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    func1(static_var + static_var2 + a + b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mac-使用-readelf"><a href="#Mac-使用-readelf" class="headerlink" title="Mac 使用 readelf"></a>Mac 使用 readelf</h2><p>Mac 上没有 ‘readelf 命令’ 可以使用 ’greadelf‘ 和 ’gobjdump‘<br>安装步骤：</p><ol><li>使用命令<blockquote><p>brew update &amp;&amp; brew install binutils</p></blockquote></li></ol><p>2.路径添加到 ’~/.bash_profile‘ 文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># binutils</span><br><span class="line">export PATH=&quot;/usr/local/opt/binutils/bin:$PATH&quot;</span><br><span class="line">export LDFLAGS=&quot;-L/usr/local/opt/binutils/lib&quot;</span><br><span class="line">export CPPFLAGS=&quot;-I/usr/local/opt/binutils/include&quot;</span><br></pre></td></tr></table></figure><h2 id="Mac-otool替代readelf命令"><a href="#Mac-otool替代readelf命令" class="headerlink" title="Mac otool替代readelf命令"></a>Mac otool替代readelf命令</h2><p>$otool -h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">rg] [--version] &lt;object file&gt; ...</span><br><span class="line">-f print the fat headers</span><br><span class="line">-a print the archive header</span><br><span class="line">-h print the mach header</span><br><span class="line">-l print the load commands</span><br><span class="line">-L print shared libraries used</span><br><span class="line">-D print shared library id name</span><br><span class="line">-t print the text section (disassemble with -v)</span><br><span class="line">-x print all text sections (disassemble with -v)</span><br><span class="line">-p &lt;routine name&gt;  start dissassemble from routine name</span><br><span class="line">-s &lt;segname&gt; &lt;sectname&gt; print contents of section</span><br><span class="line">-d print the data section</span><br><span class="line">-o print the Objective-C segment</span><br><span class="line">-r print the relocation entries</span><br><span class="line">-S print the table of contents of a library (obsolete)</span><br><span class="line">-T print the table of contents of a dynamic shared library (obsolete)</span><br><span class="line">-M print the module table of a dynamic shared library (obsolete)</span><br><span class="line">-R print the reference table of a dynamic shared library (obsolete)</span><br><span class="line">-I print the indirect symbol table</span><br><span class="line">-H print the two-level hints table (obsolete)</span><br><span class="line">-G print the data in code table</span><br><span class="line">-v print verbosely (symbolically) when possible</span><br><span class="line">-V print disassembled operands symbolically</span><br><span class="line">-c print argument strings of a core file</span><br><span class="line">-X print no leading addresses or headers</span><br><span class="line">-m don&apos;t use archive(member) syntax</span><br><span class="line">-B force Thumb disassembly (ARM objects only)</span><br><span class="line">-q use llvm&apos;s disassembler (the default)</span><br><span class="line">-Q use otool(1)&apos;s disassembler</span><br><span class="line">-mcpu=arg use `arg&apos; as the cpu for disassembly</span><br><span class="line">-j print opcode bytes</span><br><span class="line">-P print the info plist section as strings</span><br><span class="line">-C print linker optimization hints</span><br><span class="line">--version print the version of /Users/yxhuang/software/xcode/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、目标文件的格式&quot;&gt;&lt;a href=&quot;#一、目标文件的格式&quot; class=&quot;headerlink&quot; title=&quot;一、目标文件的格式&quot;&gt;&lt;/a&gt;一、目标文件的格式&lt;/h1&gt;&lt;p&gt;目标文件是源代码编译后但为进行链接的那些中间文件（Window 的 .obj 和 L
      
    
    </summary>
    
    
      <category term="程序员的自我修养" scheme="https://yxhuangch.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记|《程序员的自我修养》- 01 前言</title>
    <link href="https://yxhuangch.github.io/2021/03/28/linker-read-pre/"/>
    <id>https://yxhuangch.github.io/2021/03/28/linker-read-pre/</id>
    <published>2021-03-28T14:37:52.000Z</published>
    <updated>2021-03-30T11:46:19.891Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2021/03/28/linker-read-pre/linker-read-pre.png" width="80%" height="80%"></p><p>图片来自极客时间<a href="https://time.geekbang.org/column/article/94470" target="_blank" rel="noopener">深入浅出计算机原理</a></p><h1 id="学习链接知识的意义"><a href="#学习链接知识的意义" class="headerlink" title="学习链接知识的意义"></a>学习链接知识的意义</h1><ul><li><p><strong>理解链接将帮助你构建大型程序</strong><br>构建大型程序的程序员经常会遇到由于缺少模块、缺少库或者不兼容的库版本引起的连接器错误。除非你理解连接器是如何解析引用、什么是库以及链接器是如何使用库来解析引用的，否则这类错误将令你感到迷惑或挫折。</p></li><li><p><strong>理解链接器将帮助你避免一些危险的编译错误</strong></p></li><li><p><strong>理解链接将帮助你理解语言的作用域是如何实现的</strong><br>例如，全局和局部变量之间的区别是什么？当你定义一个具有 static 属性的变量或者函数时，到底意味着什么</p></li><li><p><strong>理解链接将帮助你理解其他重要的系统概念</strong><br>链接器产生的可执行文件在重要的系统中扮演着关键角色，例如加载和运行程序、虚拟内存、分页和内存映射</p></li><li><p><strong>理解链接将使你能够利用共享库</strong><br>这个在 Android 的动态加载 so 文件以及 Native hook 中会用，我会在后续提供这方面的应用</p></li></ul><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>链接器是把程序的各个部分合并成一个文件，处理器可以将这个文件加载到存储器，并且执行它。</p><p>链接可以在编译的时候有静态编译器来完成，也可以在加载时和运行时有动态链接器完成。</p><p>静态链接器（static linker）以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。</p><p>被编译为位置无关代码的共享库可以加载到任何地方，也可以在运行时被多个进程共享。为了加载、链接和访问共享的函数和数据，应用程序还可以在运行时使用动态链接器。</p><h1 id="链接器的任务"><a href="#链接器的任务" class="headerlink" title="链接器的任务"></a>链接器的任务</h1><p>链接器的主要两个任务是</p><ul><li><strong>符号解析（symbol resolution）</strong></li><li><strong>重定位(relocation)</strong></li></ul><p><strong>符号解析</strong><br>目标文件定义和引用符号，符号解析是将目标文件中的每个全局符号都绑定到一个唯一定义。</p><p><strong>重定位</strong><br>编译器和汇编器生成从地址 0 开始的代码和数据节。<br>链接器通过把每个符号定义与一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指向这个存储器位置，从而重定位这些节</p><h1 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h1><p>目标文件是源代码编译后但为进行链接的那些中间文件（Window 的 .obj 和 Linux 下的 .o）</p><p>目标文件存粹是字节块的集合。</p><p><strong>目标文件的型式</strong></p><ul><li><strong>可重定位目标文件</strong></li><li><strong>可执行目标文件</strong></li><li><strong>共享目标文件</strong></li></ul><h2 id="可重定位的目标文件"><a href="#可重定位的目标文件" class="headerlink" title="可重定位的目标文件"></a>可重定位的目标文件</h2><p>可重定位的目标文件是静态连接器合并成一个可执行的目标文件，它可以加载到存储器中并执行</p><p>可重定位的目标文件包含二进制代码和数据，它是有在编译时与其他可重定位目标文件合并起来，形成一个可执行目标文件</p><h2 id="共享目标文件"><a href="#共享目标文件" class="headerlink" title="共享目标文件"></a>共享目标文件</h2><p>共享目标文件（共享库）是在运行时有动态链接器和加载的，在调用程序被加载和开始执行时，或者需要在程序调用 dlopen 库的函数。</p><p>目标共享文件是一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态加载到存储器并链接。</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>加载器将可以执行文件的内容映射到存储器，并运行这个程序。链接器还可能生出部分链接的可执行文件，这样的文件中有对定义在共享库中的程序和数据的未解析的引用。在加载时，加载器将部分链接的可执行文件映射到存储器，然后调用动态链接器，它通过加载共享库和重定位程序中的引用来完成链接任务。</p><h1 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gcc -c SimpleSection.c  // 生成目标文件</span><br><span class="line">readelf -s link_example.o //查看符号表</span><br><span class="line">objdump -r link_example.o //查看重定位表</span><br><span class="line"></span><br><span class="line">&gt; $readelf -h SimpleSection.o  // linex 用 </span><br><span class="line"></span><br><span class="line">&gt; $otool -h SimpleSection.o  // mac 使用</span><br></pre></td></tr></table></figure><h2 id="Mac-使用-readelf"><a href="#Mac-使用-readelf" class="headerlink" title="Mac 使用 readelf"></a>Mac 使用 readelf</h2><p>Mac 上没有 ‘readelf 命令’ 可以使用 ’greadelf‘ 和 ’gobjdump‘<br>安装步骤：</p><ol><li>使用命令<blockquote><p>brew update &amp;&amp; brew install binutils</p></blockquote></li></ol><p>2.路径添加到 ’~/.bash_profile‘ 文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># binutils</span><br><span class="line">export PATH=&quot;/usr/local/opt/binutils/bin:$PATH&quot;</span><br><span class="line">export LDFLAGS=&quot;-L/usr/local/opt/binutils/lib&quot;</span><br><span class="line">export CPPFLAGS=&quot;-I/usr/local/opt/binutils/include&quot;</span><br></pre></td></tr></table></figure><h2 id="查看-so-的文件格式"><a href="#查看-so-的文件格式" class="headerlink" title="查看 so 的文件格式"></a>查看 so 的文件格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; file libdycloudmedia.so</span><br><span class="line">libdycloudmedia.so: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, BuildID[sha1]=2bcf3eae561f0f6ca25b0f2abd0728eef68f9ea3, stripped</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://fengmuzi2003.gitbook.io/csapp3e/di-er-zhang-zhong-dian-jie-du" target="_blank" rel="noopener">https://fengmuzi2003.gitbook.io/csapp3e/di-er-zhang-zhong-dian-jie-du</a><br><a href="https://www.bilibili.com/video/BV1a54y1k7YE?p=13" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1a54y1k7YE?p=13</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2021/03/28/linker-read-pre/linker-read-pre.png&quot; width=&quot;80%&quot; height=&quot;80%&quot;&gt;&lt;/p&gt;
&lt;p&gt;图片来自极客时间&lt;a href=&quot;https://time.geekbang.org/co
      
    
    </summary>
    
    
      <category term="程序员的自我修养" scheme="https://yxhuangch.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记《修改软件的艺术》</title>
    <link href="https://yxhuangch.github.io/2021/03/13/read-changle-code/"/>
    <id>https://yxhuangch.github.io/2021/03/13/read-changle-code/</id>
    <published>2021-03-13T08:57:02.000Z</published>
    <updated>2021-03-13T14:37:14.246Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2021/03/13/read-changle-code/change_code_1.png" width="80%" height="80%"></p><p>来源 <a href="https://book.douban.com/subject/27151925/" target="_blank" rel="noopener">《修改软件的艺术》</a></p><p>[TOC]</p><p><strong>重点摘要</strong></p><ul><li>优秀的开发者首要考虑的是代码的可维护性</li><li>软件开发者之所以会过度开发，是因为我们害怕某个功能会以我们没有预料的方式使用</li><li>不同层次的抽象可以帮助我们对组件的关系建立起大局观，也可以让我们可以只在需要的时候关注细节</li><li>意外耦合是缺乏优质代码特质的一种体现</li><li>封装就是：让做什么，隐藏如何做</li><li>封装良好的软件是由外而内而不是由内而外设计的</li><li>一部分代码对另一部分 “知道” 得越多，则依赖越重，无论显示的还是隐式的</li><li>软件被阅读的次数比编写次数多</li><li>在写公用的应用程序接口、方法，或者暴露给外部的其他服务，不要在那个方法中放入任何实现。而是将其位委托其他方法</li></ul><h3 id="1-如何做之前先问做什么、为什么做、给谁做"><a href="#1-如何做之前先问做什么、为什么做、给谁做" class="headerlink" title="1. 如何做之前先问做什么、为什么做、给谁做"></a>1. 如何做之前先问做什么、为什么做、给谁做</h3><p>软件开发者需要领域建模，这就是需要我们去学习领域设计的知识；</p><p>开发者需要在善于提出没人想过的问题。这就要要去需要在需求评审的时候提出，多问产品为什么需要这样？出发点是什么？</p><h3 id="2-编写整洁的代码"><a href="#2-编写整洁的代码" class="headerlink" title="2.编写整洁的代码"></a>2.编写整洁的代码</h3><p><img src="/2021/03/13/read-changle-code/clean_code_1.png" width="80%" height="80%"></p><h4 id="内聚"><a href="#内聚" class="headerlink" title="内聚"></a>内聚</h4><p>内聚就是每个片段都只关注一件事，一个类应该只有一个目的；</p><p>不同层次的抽象可以帮助我们对组件的关系建立起大局观，也可以让我们可以只在需要的时候关注细节。</p><blockquote><p>代码的层次从高往下应该是从抽象 -&gt; 实体</p></blockquote><p>内聚的代码更容易理解和查找 bug, 因为每个实体都只处理自身的事物</p><h4 id="松散耦合"><a href="#松散耦合" class="headerlink" title="松散耦合"></a>松散耦合</h4><p>松散耦合的代码不直接依赖它所使用的代码，而是通过一个中间层来调用；</p><p>意外耦合是缺乏优质代码特质的一种体现</p><p>松散耦合的代码让实体之间的副作用更少，而且更容易测试、复用、扩展</p><h4 id="封装良好"><a href="#封装良好" class="headerlink" title="封装良好"></a>封装良好</h4><p>高质量的代码是封装良好的，它隐藏了实现细节</p><p>封装就是：让做什么，隐藏如何做</p><p>封装良好的软件是由外而内而不是由内而外设计的。</p><p>在用对象来实现系统的时候，让每个对象自身和所处的环境复制，系统中的每个对象都有自己的用途</p><p>默认封装，必要时再暴露</p><p>面向接口编程，而不是面向实现编程</p><p>封装良好的代码有助于我们管理复杂度，让调用者不必关系被调用者的实现细节，所以更容易修改</p><h4 id="代码自主"><a href="#代码自主" class="headerlink" title="代码自主"></a>代码自主</h4><p>代码自主，是指让它自己管理自己的职责，不应该互相干预。</p><p>自主的原则是:</p><ul><li>对象应该控制自身的状态</li><li>对象之间不应该相互干预</li></ul><blockquote><p>数据和控制逻辑要分开</p></blockquote><p>自主的代码让我们知道行为应该和它所依赖的数据放到一起</p><h4 id="没有冗余"><a href="#没有冗余" class="headerlink" title="没有冗余"></a>没有冗余</h4><p>软件不应该自我复制，要没有冗余</p><p>没有冗余的代码以为这我们可以只在一个地方修复 bug 和进行更改</p><h3 id="3-最后实现设计"><a href="#3-最后实现设计" class="headerlink" title="3.最后实现设计"></a>3.最后实现设计</h3><h4 id="3-1-阻碍了可修改代码的产生"><a href="#3-1-阻碍了可修改代码的产生" class="headerlink" title="3.1 阻碍了可修改代码的产生"></a>3.1 阻碍了可修改代码的产生</h4><p>在实现设计之前，需用明确是什么阻碍了可修改代码的产生</p><h5 id="缺乏封装"><a href="#缺乏封装" class="headerlink" title="缺乏封装"></a>缺乏封装</h5><p>一部分代码对另一部分 “知道” 得越多，则依赖越重，无论显示的还是隐式的</p><h5 id="滥用继承"><a href="#滥用继承" class="headerlink" title="滥用继承"></a>滥用继承</h5><p>少用继承，多用组合</p><h5 id="僵化的实现"><a href="#僵化的实现" class="headerlink" title="僵化的实现"></a>僵化的实现</h5><p>当缺乏抽象的时候，两个或多个行为之间会有太多的共同性，导致冗余和非必要的复杂性，让代码难以使用。僵化的实现难以修改，难以在日后添加新的差异性</p><h5 id="内联代码"><a href="#内联代码" class="headerlink" title="内联代码"></a>内联代码</h5><h5 id="没有正常阻隔一拉"><a href="#没有正常阻隔一拉" class="headerlink" title="没有正常阻隔一拉"></a>没有正常阻隔一拉</h5><h4 id="3-2-编写可持续性代码的注意事项"><a href="#3-2-编写可持续性代码的注意事项" class="headerlink" title="3.2 编写可持续性代码的注意事项"></a>3.2 编写可持续性代码的注意事项</h4><ul><li>删除死代码</li><li><p>保持名称更新<br>重命名方法和类，以保持“见名知意”的良好名称。随着开发的进行，对事物理解的加深，代码功能也会随之变化。如果代码变化了，随之亦要重新命名来反应代码更新后的行为</p></li><li><p><strong>集中决策</strong><br>将分散大代码集中一处。让决策集中。如果决策需要改变，只会影响一处。<br>如果类和方法都非常内聚，业务规则就分散到系统的各个部分，让其难以理解和修改。将各种流程的规则集中化。将业务规则集中到一起。这样就消除了很多冗余，让代码更容易理解和维护</p><blockquote><p>这个规则是在平时写代码的时候容易被忽略的，需要重视</p></blockquote></li><li><p>对所有外部依赖建立并使用抽象</p></li><li>在建领域模型的时候，需要确保建模完整，对这些类组织，让它们有合理的行为和属性</li></ul><h4 id="3-3-意图导向编程"><a href="#3-3-意图导向编程" class="headerlink" title="3.3 意图导向编程"></a>3.3 意图导向编程</h4><p>意图导向编程是指，将所有公用接口的代码都委托到不同的方法中，就可以消除这些重复工作。这样代码读起来就像一段脚本或一个菜单，因为它保持同样抽象层次。</p><p>在写公用的应用程序接口、方法，或者暴露给外部的其他服务，不要在那个方法中放入任何实现。而是将其委托给其他方法。</p><h4 id="3-4-降低复杂度"><a href="#3-4-降低复杂度" class="headerlink" title="3.4 降低复杂度"></a>3.4 降低复杂度</h4><p>一个条件（if）语句的复杂度是 2， 两个 if 语句就是的复杂度是4， 这种复杂度是指数型增长的。复杂度越高，越容易出现 bug 所以要降低复杂度</p><p>降低复杂度的手段一般有多态，将条件语句的创建放在对象的创建阶段而不是使用阶段</p><p>以下内容来自极客时间的专栏 《左耳听风》，第 38| 编程范式游记（9）编程的本质</p><p><strong>任何算法都会有两个部分，一个是 Logic 部分，这是用来解决实际问题的。另一个是 Control 部分，这是用来决定用什么策略来解决问题。Logic 部分是真正意义上解决问题的算法，而 Control 部分只是影响解决这个这个问题的效率。程序运行的效率问题和程序的逻辑其实是没有关系的。我们认为，如果将 Logic 和 Control 部分有效地分开，那么代码就会变得更容易改进和维护</strong></p><p><strong>有效分离 Logic 、Control 和 Data 是写出好程序的关键所在</strong></p><p><img src="/2021/03/13/read-changle-code/logic_control.png" width="80%" height="80%"></p><p>Logic 是程序复杂度的下限，然后，我们未来控制程序，需要再搞出很多控制代码，于是 Logic + Control 的相互交织成为了最终程序的复杂度</p><ul><li>业务逻辑的复杂度决定了代码的复杂度；</li><li>控制逻辑的复杂度 + 业务逻辑的复杂度 ==&gt; 程序代码的混乱不堪</li><li>绝大多数程序复杂混乱的根本原因：<strong>业务逻辑与控制逻辑的耦合</strong></li></ul><p>分离 logic 和 control</p><ul><li><p><strong>State Machine 状态机</strong> </p><ul><li>状态定义</li><li>状态变迁条件</li><li>状态的 action</li></ul></li><li><p><strong>DSL</strong></p><ul><li>HTML, SQL, Unix Shell Script, AWK, 正则表达式</li></ul></li><li><strong>编程范式</strong><ul><li>面向对象：委托、策略、桥接、修饰、 IoC/DIP、MVC…</li><li>函数式编程：修饰、管道、拼装</li><li>逻辑推导式编程： Prolog</li></ul></li></ul><p><strong>编程的本质：</strong></p><ul><li><strong>Logic 部分是真正有意义的 （What）</strong></li><li><strong>Control 部分只影响 Logic 部分的效率 （How）</strong></li></ul><h3 id="5-重构遗留代码"><a href="#5-重构遗留代码" class="headerlink" title="5.重构遗留代码"></a>5.重构遗留代码</h3><p>重构是指在不改变外部行为的前提下对代码的内部结构进行重组和重新包装</p><p>怎样重构</p><blockquote><p>1.只要代码运行没有问题，就不要去修改它，能正常运行，就不用重构<br>2.只有在那些要修改、添加新功能的代码，才进行重构<br>3.重构的时候要遵循渐进式、小步修改的原则</p></blockquote><p><strong>何时进行重构</strong></p><ul><li><p>当关键代码维护不善的时候<br>别去碰遗留代码是明智的，但是关键代码难以理解变成累赘时，就需要进行清理</p></li><li><p>当唯一理解代码的人没空的时候</p></li><li><p>当有信息可以揭示更好的设计的时候</p></li><li><p>当修复bug 的时候</p></li><li><p>当需要添加新功能的时候</p></li><li><p>当需要为遗留代码写文档的时候</p></li><li><p>当重构比重写容易的时候</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2021/03/13/read-changle-code/change_code_1.png&quot; width=&quot;80%&quot; height=&quot;80%&quot;&gt;&lt;/p&gt;
&lt;p&gt;来源 &lt;a href=&quot;https://book.douban.com/subject/2
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://yxhuangch.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>对 Firebase 上 NDK 无符号解决的记录</title>
    <link href="https://yxhuangch.github.io/2020/12/19/firebase-no-ndk-symbol/"/>
    <id>https://yxhuangch.github.io/2020/12/19/firebase-no-ndk-symbol/</id>
    <published>2020-12-19T08:57:02.000Z</published>
    <updated>2021-08-21T02:30:31.843Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>记 Firebase 上无 NDK 符号表解决的过程</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在 项目上线之后，Firebase 的后台收到音视频上报的崩溃。在项目中音视频以 so 文件的形式集成近项目。在后台上报页面，看不到符号表的匹配。</p><p><img src="/2020/12/19/firebase-no-ndk-symbol/img_1.png" width="100%" height="100%"></p><p>而这个 bug 占据了我们 bug 的 Top 1 位置。</p><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><h3 id="第一步-重新检查集成-Firebase-的过程"><a href="#第一步-重新检查集成-Firebase-的过程" class="headerlink" title="第一步 重新检查集成 Firebase 的过程"></a><strong>第一步 重新检查集成 Firebase 的过程</strong></h3><p>出现问题的时候，我们第一步是去<a href="https://firebase.google.com/docs/crashlytics/get-started?platform=android" target="_blank" rel="noopener">官网</a>重新看集成 Firebase 的过程<br>检查了发现没有问题。</p><h3 id="第二步-重新查看官网文档"><a href="#第二步-重新查看官网文档" class="headerlink" title="第二步 重新查看官网文档"></a><strong>第二步 重新查看官网文档</strong></h3><p>经过第一步的检查，集成的步骤是没有问题的, 我们再次看看官网文档，有没有新的发现。<br>在官网的 <a href="https://firebase.google.com/docs/crashlytics/ndk-reports" target="_blank" rel="noopener">Get Android NDK crash reports</a> 的这个章节发现了新的线索。</p><p>我们的音视频 so 是自己开发的，用 gradle 的方式集成到工程里面。这个相当于外部独立的依赖，所以，需要用 Firebase 提供的 unstrippedNativeLibsDir 的属性上传未剥离符号表的 so.<br>在第三步 <a href="https://firebase.google.com/docs/crashlytics/ndk-reports#upload-external-dependencies" target="_blank" rel="noopener">Step 3(optinal): Upload symbols for external dependencies</a> 中</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// …</span></span><br><span class="line">android &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            firebaseCrashlytics &#123;</span><br><span class="line">                nativeSymbolUploadEnabled <span class="keyword">true</span></span><br><span class="line">                unstrippedNativeLibsDir ‘path<span class="regexp">/to/u</span>nstripped<span class="regexp">/parent/</span>dir’</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且需要对应的 so 架构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unstrippedNativeLibsDir/</span><br><span class="line"> +- x86/</span><br><span class="line">      |</span><br><span class="line">      +- libfoo.so</span><br><span class="line">      +- libbar.so</span><br><span class="line"> +- arm64/</span><br><span class="line">      |</span><br><span class="line">      +- libfoo.so</span><br><span class="line">      +- libbar.so</span><br></pre></td></tr></table></figure><p>加了之后用命令执行 task 上传符号表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew app:assembleDebug app:uploadCrashlyticsSymbolFileDebug -debug | grep &quot;\[com.google.firebase.crashlytics\]&quot;</span><br></pre></td></tr></table></figure><p>上面的命令跑了，之后发现我们上传符号表失败了，是因为网络的原因</p><h3 id="第三步-Android-Studio-配置科学上网"><a href="#第三步-Android-Studio-配置科学上网" class="headerlink" title="第三步 Android Studio 配置科学上网"></a><strong>第三步 Android Studio 配置科学上网</strong></h3><p>我们在国内需要对 Android Studio 的 gradle 设置代理</p><p>设置 Android Studio 的代理<br>查看 SS 的端口<br><img src="/2020/12/19/firebase-no-ndk-symbol/img_2.png" width="100%" height="100%"></p><p>设置代理<br><img src="/2020/12/19/firebase-no-ndk-symbol/img_3.png" width="100%" height="100%"></p><ul><li>1.找到 HTTP Proxy 设置选项</li><li>2.选择 Manual proxy configuration</li><li>3.填写 ss 的 ip 和端口</li><li>4.检测是否设置成功 check connection<br>输入 google 的网址，检测是否设置成功，如果成功了，会弹窗连接成功的弹窗</li></ul><h3 id="第四步-去-Firebas-的github-上看-issues"><a href="#第四步-去-Firebas-的github-上看-issues" class="headerlink" title="第四步 去 Firebas 的github 上看 issues"></a><strong>第四步 去 Firebas 的github 上看 issues</strong></h3><p>经过上面三步还是不行，我们就去 <a href="https://github.com/firebase/firebase-android-sdk" target="_blank" rel="noopener">Firebase 的 github</a> 上看看其他人有没有遇到同样的问题。<br>这里顺便说一句，如果是开源的项目，遇到问题，查看它的 issues 也是解决问题的切入点，你遇到的问题，别人也会遇到，看看 issues 或许能找到解决办法或者提示。</p><p>在 Firebase 的 issues 中搜索 ndk symbol，可以找到相关 ndk 符号表的内容。然后在一条中找到相关的内容 <a href="https://github.com/firebase/firebase-android-sdk/issues/1978" target="_blank" rel="noopener">Native crash reports missing symbol information (file name, line number, function name) #1978</a>，有人也遇到相应的问题，就是在 Firebase 上没有看到相应的符号表。<br>他的解决办法，就是把已剥离和未剥离符号表的 so 都放到对于的目录下，用于上传符号表</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">debug &#123;</span><br><span class="line">    minifyEnabled <span class="keyword">false</span></span><br><span class="line">    signingConfig signingConfigs.debugsign</span><br><span class="line"></span><br><span class="line">    firebaseCrashlytics &#123;</span><br><span class="line">        nativeSymbolUploadEnabled <span class="keyword">true</span></span><br><span class="line">        strippedNativeLibsDir <span class="string">'nativelibs/stripped'</span>  <span class="comment">// 剥离符号表的 so</span></span><br><span class="line">        unstrippedNativeLibsDir <span class="string">'nativelibs/unstripped'</span> <span class="comment">// 未剥离符号表的 so</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew app:assembleDebug app:uploadCrashlyticsSymbolFileDebug -debug | grep &quot;\[com.google.firebase.crashlytics\]&quot;</span><br></pre></td></tr></table></figure><p>这次命令执行的结果显示,上传符号表成功了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Crashlytics symbol file uploaded successfully</span><br></pre></td></tr></table></figure><p>经过测试 native 的崩溃后，发现符号表打印是上传成功了，但是还是没有显示出来。</p><p>到这来，我们已经没有办法。为什么明明符号表已经上传成功了，但是还是解析不到呢。</p><h3 id="第五步-配对-So-和项目-NDK-版本"><a href="#第五步-配对-So-和项目-NDK-版本" class="headerlink" title="第五步 配对 So 和项目 NDK 版本"></a><strong>第五步 配对 So 和项目 NDK 版本</strong></h3><p>至此，唯一的可能性是我们上传的符号表和 native 的崩溃对不上，导致 Firebase 无法解析。</p><p>通过一番查找，发现我们构建 SO 用的 NDK 版本是 19， 构建项目是的 NDK 是 21 版本。<br>我们将项目的 NDK 版本也改成 19。</p><p>最后发现可以了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上传非工程直接编译 so 的符号表</p><h3 id="第一步-按照官方文档集成-Firebase"><a href="#第一步-按照官方文档集成-Firebase" class="headerlink" title="第一步 按照官方文档集成 Firebase"></a><strong>第一步 按照官方文档集成 Firebase</strong></h3><p>在项目级别的 build.gradle 中,添加 firebase</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    classpath &apos;com.google.firebase:firebase-crashlytics-gradle:2.1.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 app 的 build.gradle 中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.google.firebase.crashlytics&apos;</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">buildTypes &#123;</span><br><span class="line"></span><br><span class="line">    release &#123;</span><br><span class="line">        ...</span><br><span class="line">        firebaseCrashlytics &#123;</span><br><span class="line"></span><br><span class="line">            nativeSymbolUploadEnabled true</span><br><span class="line">            strippedNativeLibsDir &apos;nativelibs/stripped&apos;</span><br><span class="line">            unstrippedNativeLibsDir &apos;nativelibs/unstripped&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    debug &#123;</span><br><span class="line">         ...</span><br><span class="line">        firebaseCrashlytics &#123;</span><br><span class="line">            nativeSymbolUploadEnabled true</span><br><span class="line">            strippedNativeLibsDir &apos;nativelibs/stripped&apos;</span><br><span class="line">            unstrippedNativeLibsDir &apos;nativelibs/unstripped&apos;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>strippedNativeLibsDir 是放已经剥离符号表的 so, unstrippedNativeLibsDir 是放未剥离符号表的 so</p><p><img src="/2020/12/19/firebase-no-ndk-symbol/img_4.png" width="100%" height="100%"></p><p>在 module 的 build.gradle 中添加依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// google 崩溃上报</span></span><br><span class="line">    implementation <span class="string">'com.google.firebase:firebase-analytics-ktx:17.4.4'</span></span><br><span class="line">    <span class="comment">// Add the Firebase Crashlytics SDK.</span></span><br><span class="line">    implementation <span class="string">'com.google.firebase:firebase-crashlytics:17.1.1'</span></span><br><span class="line">    implementation <span class="string">'com.google.firebase:firebase-crashlytics-ndk:17.1.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二步-确保网络没有问题"><a href="#第二步-确保网络没有问题" class="headerlink" title="第二步 确保网络没有问题"></a><strong>第二步 确保网络没有问题</strong></h3><p>如果是在国内，要设置Android studio 代理</p><h3 id="第三步-确保编译-so-的-NDK-和项目的-NDK-版本一致"><a href="#第三步-确保编译-so-的-NDK-和项目的-NDK-版本一致" class="headerlink" title="第三步 确保编译 so 的 NDK 和项目的 NDK 版本一致"></a><strong>第三步 确保编译 so 的 NDK 和项目的 NDK 版本一致</strong></h3><h3 id="第三步-用命令行上传符号表"><a href="#第三步-用命令行上传符号表" class="headerlink" title="第三步 用命令行上传符号表"></a><strong>第三步 用命令行上传符号表</strong></h3><p>用命令行上传符号表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew app:assembleDebug app:uploadCrashlyticsSymbolFileDebug -debug | grep &quot;\[com.google.firebase.crashlytics\]&quot;</span><br></pre></td></tr></table></figure><p>跑命令的时候观察打印，如果打印出</p><blockquote><p>Crashlytics symbol file uploaded successfully</p></blockquote><p>则说明已经上传成功</p><h3 id="第四步-测试-bug"><a href="#第四步-测试-bug" class="headerlink" title="第四步 测试 bug"></a><strong>第四步 测试 bug</strong></h3><p>打开 firebase 的 log 打印</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb shell setprop log.tag.FirebaseCrashlytics DEBUG</span><br><span class="line"></span><br><span class="line">adb logcat -s FirebaseCrashlytics</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;记 Firebase 上无 NDK 符号表解决的过程&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在 项目上线之后，Firebase 的后台收到
      
    
    </summary>
    
    
      <category term="firebase" scheme="https://yxhuangch.github.io/tags/firebase/"/>
    
  </entry>
  
  <entry>
    <title>Java 虚拟机（五）- 链接模式</title>
    <link href="https://yxhuangch.github.io/2020/08/16/jvm-link-model/"/>
    <id>https://yxhuangch.github.io/2020/08/16/jvm-link-model/</id>
    <published>2020-08-16T09:00:56.000Z</published>
    <updated>2020-08-16T11:58:57.623Z</updated>
    
    <content type="html"><![CDATA[<p>这是我们 Java 虚拟机系列文件的第五篇，连接模型</p><p>从程序员的角度来看，理解 Java 虚拟机体系结构最重要的方面之一就是连接模型</p><h3 id="1-解析和动态扩展"><a href="#1-解析和动态扩展" class="headerlink" title="1.解析和动态扩展"></a>1.解析和动态扩展</h3><p>编译一个 Java 程序之后，会得到程序中每个类和接口的独立 class 文件。它们是通过接口符号（harbor）相互联系的，或者用 Java API 的 class 文件相联</p><p>class 文件把它所有的引用符号都保存在常量池中。在程序运行时，如果某个特定的接口符号将要被使用，它通过解析，根据符号引用查到实体，再把符号引用替换成一个直接引用的过程。<br>因为所有的符号引用都保存在常量池中，这个过程也被称为<strong>常量池解析。</strong></p><p>解析分成早解析和迟解析</p><ul><li>早解析：程序在它的 main() 方法尚未被调用时就已经完全连接了</li><li>迟解析：JVM 在执行程序的第一次用到这个符号引用的最后一刻才去解析</li></ul><p><strong>连接包括把符号引用替换成直接引用，还包括检查正确性和权限。</strong></p><p>检查内容包含：</p><ul><li>那个类是否存在</li><li>该类是返回有权访问那个类</li><li>那个类中是否存在名称相符的字段</li><li>那个字段的类型和期望的类型是否相符</li><li>本类是否有权访问那个字段</li><li>那个字段的确是一个类变量，而不是一个实例变量。</li></ul><p><strong>Java 虚拟机为每一个装载的类和接口都保存一份独立的常量池。</strong></p><h3 id="2-类加载器和双亲委托机制"><a href="#2-类加载器和双亲委托机制" class="headerlink" title="2.类加载器和双亲委托机制"></a>2.类加载器和双亲委托机制</h3><p>看前面的文章</p><h3 id="3-常量池的解析"><a href="#3-常量池的解析" class="headerlink" title="3.常量池的解析"></a>3.常量池的解析</h3><p> 被初始化为编译时常量的静态 final 变量的引用，在编译时被解析为常量值的一个本地拷贝</p><h3 id="4-其他类型的解析"><a href="#4-其他类型的解析" class="headerlink" title="4.其他类型的解析"></a>4.其他类型的解析</h3><h4 id="4-1-解析-CONSTANT-Class-info-入口"><a href="#4-1-解析-CONSTANT-Class-info-入口" class="headerlink" title="4.1 解析 CONSTANT_Class_info 入口"></a>4.1 解析 CONSTANT_Class_info 入口</h4><p><img src="/2020/08/16/jvm-link-model/jvm_link_1.png" width="50%" height="20%"></p><ul><li><ol><li>装载类或任何超类<br>在第一步，虚拟机确定被引用的已经被装载进当前命名空间，并为该类标记为初设装载器。<br>如果当前类加载器是启动类加载器，虚拟机根据不同的实现，使用不同的方式加载。<br>如果是自定义类加载器，则通过 loadClass() 方法完成加载请求，把需要加载的类的全限定名作为参数传递进去。</li></ol></li></ul><p>被引用的类型被加载了，虚拟机检测它的二进制数据。如果类型是一个类，并且不是 java.lang.Object， 虚拟机根据类的数据得到它的直接超类的全限定名。如果超类没有被加载进当前命名空间。如果没有，先加载超类。一旦超类被加载了，虚拟在此检查超类的二进制数据来找到它的超类。一直重复到超类是 Object 为止。</p><p>一旦一个类型被加载进当前命名空间，而且通过递归，所有该类型的超类和超接口都会被加载成功。</p><ul><li><p>2.检查访问权限<br>如果没有访问权限，会抛出 <strong>IllegalAccessError 异常</strong>，符号引用解析失败。</p></li><li><p>3.检验类型<br>校验过程要去虚拟机加载的类型符合 Java 语言的语义</p></li><li><p>4.准备阶段<br>准备阶段虚拟机为类变量以及实现不同有差别的数据结构分配内存</p></li><li><p>5.解析类型<br>解析类型的阶段是可以选择的，根据参数选择解析或不解析</p></li><li><p>6.初始化类型<br>超类必须在子类之前被初始化，必须确保它的所有超类都被初始化，从 Object 开始沿着继承的结构向下处理，直达被引用的类。<br>如果一个类型没有被连接，在初始化之前必须被连接。<br>超类必须被初始化，超接口是不必的</p></li></ul><p>如果虚拟机因为内存不足，在初始化的时候会抛出 <strong>OutOfMemoryError 异常</strong></p><h4 id="4-2-解析-CONSTANT-Fieldref-info-入口"><a href="#4-2-解析-CONSTANT-Fieldref-info-入口" class="headerlink" title="4.2 解析 CONSTANT_Fieldref_info 入口"></a>4.2 解析 CONSTANT_Fieldref_info 入口</h4><p>要解析 CONSTANT_Fieldref_info 入口，必须要先解析 CONSTANT_Class_info 入口。</p><p><img src="/2020/08/16/jvm-link-model/jvm_link_2.png" width="70%" height="70%"></p><p>搜索 Field 字段过程</p><ul><li>1.虚拟机在被引用的类型中查找具有指定的名称和类型的字段。如果找到，则成功。</li><li>2.否则虚拟机检测类型的直接实现或拓展的接口，以及递归地检查它们的超接口。如果找到，则成功</li><li>3.否则检测直接超类，并且递归地检查类型的所有超类。如果找到，则成功</li><li>4.最后都找不到，则字段搜索失败</li></ul><p>如果没有在被引用的类或者它的任何超类中找到名字和类型都符合的字段，虚拟机就会抛出 <strong>NoSuchFieldError 异常</strong><br>如果字段搜索成功，但是当前类没有权限访问该字段，虚拟机就会抛出 <strong>IllegalAccessError 异常</strong></p><p>成功了之后，虚拟机就会把这个入口标记为已解析，并在这个常量池入口的数据中放上指向这个字段的直接引用。</p><h4 id="4-3-解析-CONSTANT-Methodref-info-入口"><a href="#4-3-解析-CONSTANT-Methodref-info-入口" class="headerlink" title="4.3 解析 CONSTANT_Methodref_info 入口"></a>4.3 解析 CONSTANT_Methodref_info 入口</h4><p>要解析 CONSTANT_Methodref_info 入口，必须要先解析 CONSTANT_Class_info 入口。</p><p>解析 methodref 的过程</p><ul><li>1.如果被解析的类型是一个接口，而非类，虚拟机就会抛出 <strong>IncompatibleClassChangeError 异常</strong></li><li>2.如果解析的类型是一个类。虚拟机检查被引用的类是否有一个符合指定名字以及描述符。如果找到，则成功</li><li>3.否则虚拟机检查是否这个类直接实现了任何接口，并递归地检查由类型直接实现的接口的超接口，查看是否有方法符合指定的名称和描述符。如果找到，则成功</li><li>4.最后都找不到，则方法搜索失败</li></ul><p>如果没有在被引用的类和它的任何超类中找到名称、返回类型、参数数量和类型都符合的方法，虚拟机就会抛出 <strong>NoSuchMethodError 异常</strong></p><p>成功了之后，虚拟机就会把这个入口标记为已解析，并在这个常量池入口的数据中放上指向这个字段的直接引用。</p><h4 id="4-4-解析-CONSTANT-InterfaceMethodref-info-入口"><a href="#4-4-解析-CONSTANT-InterfaceMethodref-info-入口" class="headerlink" title="4.4 解析 CONSTANT_InterfaceMethodref_info 入口"></a>4.4 解析 CONSTANT_InterfaceMethodref_info 入口</h4><p>要解析 CONSTANT_InterfaceMethodref_info 入口，必须要先解析 CONSTANT_Class_info 入口。</p><p>解析 InterfaceMethodref 的过程</p><ul><li>1.如果被解析的类型是一个类，而非接口，虚拟机就会抛出 <strong>IncompatibleClassChangeError 异常</strong></li><li>2.如果解析的类型是一个接口。虚拟机检查被引用的接口是否有符合指定名称和描述符。如果找到，则成功</li><li>3.否则虚拟机检查接口的直接超接口，并且递归地检查接口的所有超接口，以及 java.lang.Object 类来查找符合指定名称和描述符的方法。如果找到，则成功</li><li>4.最后都找不到，则接口方法搜索失败</li></ul><p>如果在被引用的接口和它的任何超类型中都招标名称、返回类型、参数数量和类型都符合的方法，虚拟机就会抛出 <strong>NoSuchMethodError 异常</strong></p><p>成功了之后，虚拟机就会把这个入口标记为已解析，并在这个常量池入口的数据中放上指向这个字段的直接引用。</p><h4 id="4-5-解析-CONSTANT-String-info-入口"><a href="#4-5-解析-CONSTANT-String-info-入口" class="headerlink" title="4.5 解析 CONSTANT_String_info 入口"></a>4.5 解析 CONSTANT_String_info 入口</h4><p>要解析 CONSTANT_String_info 入口，虚拟机必须把一个指定内部字符串对象的引用放置到被解析的常量池入口数据中。该字符串对象必须按照 sting_index 项在 CONSTANT_String_info 中指明 CONTANT_Utf8_info 入口所指定的字符顺序组织。</p><p>要完成 CONSTANT_String_info 入口的解析过程，虚拟机应把指向被拘留的字符串对象的引用放置到被解析的常量表入口数据中。</p><h3 id="5-直接引用"><a href="#5-直接引用" class="headerlink" title="5.直接引用"></a>5.直接引用</h3><p><strong>常量池解析的最终目标是把符号引用替换为直接引用</strong></p><p><strong>直接存储的格式是用指针</strong></p><p>指向类、类变量和类方法的直接引用是指向方法区的本地指针<br>指向实例变量和实例方法的直接引用都是偏移变量。实例变量的直接引用是从对象的映像开始算起到这个实例位置的偏移量。实例方法的直接引用是方发表的偏移量。</p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://book.douban.com/subject/1138768/" target="_blank" rel="noopener">《深入 Java 虚拟机》</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是我们 Java 虚拟机系列文件的第五篇，连接模型&lt;/p&gt;
&lt;p&gt;从程序员的角度来看，理解 Java 虚拟机体系结构最重要的方面之一就是连接模型&lt;/p&gt;
&lt;h3 id=&quot;1-解析和动态扩展&quot;&gt;&lt;a href=&quot;#1-解析和动态扩展&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JVM(三)  类的生命周期</title>
    <link href="https://yxhuangch.github.io/2020/08/05/jvm-class-lifetime/"/>
    <id>https://yxhuangch.github.io/2020/08/05/jvm-class-lifetime/</id>
    <published>2020-08-05T00:15:49.000Z</published>
    <updated>2020-08-10T23:33:39.163Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><strong>Java 虚拟机通过装载、连接和初始化一个 Java 类型</strong></p><p>类的完整生命周期包括：加载、验证、准备、解析、初始化、使用、卸载</p><p><img src="/2020/08/05/jvm-class-lifetime/jvm_lift_1.png" width="50%" height="50%"></p><p>图 1-1 类的完整生命周期</p><p>重要的阶段</p><ul><li><strong>装载</strong>：把二进制型式的 Java 类型读入 Java 虚拟机中</li><li><strong>连接</strong>：把已经读入虚拟机中的二进制型式的类型数据合并到虚拟机的运行时状态中去<br>连接分三个子步奏：验证、准备和解析</li><li><strong>初始化</strong>：给类变量赋予适当的初始值</li></ul><p><img src="/2020/08/05/jvm-class-lifetime/jvm_lift_2.png" width="50%" height="50%"></p><h2 id="1-装载"><a href="#1-装载" class="headerlink" title="1 装载"></a>1 装载</h2><p><strong>装载</strong>：就是把二进制型式的 Java 类型读入 Java 虚拟机中</p><p>装载有三个基本动作组成</p><ul><li>通过该类型的完全限定名，产生一个代表该类型的二进制数据流；</li><li>解析这个二进制数据流为方法区内的数据结构</li><li>创建一个表示该类型的 java.lang.Class 类的实例</li></ul><p>类型二进制数据流产生的方式有多种<br>例如：</p><ul><li>从本地文件系统装载一个 Java Class 文件</li><li>通过网络下载一个 Java Class 文件</li><li>动态为某个类型计算其 Class 文件格式</li></ul><p>创建类型就是把一个类型的二进制数据解析为方法区中的内部数据结构，并在堆上建立一个 Class 对象的过程。</p><h2 id="2-连接"><a href="#2-连接" class="headerlink" title="2 连接"></a>2 连接</h2><p><strong>连接</strong>：就是把已经读入虚拟机中的二进制型式的类型数据合并到虚拟机的运行时状态中去<br>连接分三个子步奏：验证、准备和解析</p><h3 id="2-1-验证"><a href="#2-1-验证" class="headerlink" title="2.1 验证"></a>2.1 验证</h3><p>验证的目的就是确认类型符合 Java 语言的语义，并且它不会危及虚拟机的完整性。<br>在验证阶段，虚拟机规范会说明在每种情况下应该抛出哪种异常，例如找不到相应的类，就会抛出 NoClassDefFoundError 异常。</p><p>在验证阶段，会使用 class 文件检验器保证装载的 class 文件内容是正确的结构。这里的 class 文件内容见 <a href="https://www.jianshu.com/p/ea05cea9c1be" target="_blank" rel="noopener">Java 虚拟机（二）：Class 文件结构</a></p><p>class 文件检验器会进行四趟扫描检测；</p><p><strong>验证扫描检测</strong></p><h4 id="第一趟扫描：class-文件的结构检查"><a href="#第一趟扫描：class-文件的结构检查" class="headerlink" title="第一趟扫描：class 文件的结构检查"></a>第一趟扫描：class 文件的结构检查</h4><ul><li>时间：第一趟扫描是在类被装载是进行的</li><li>目的：它的主要目的是保证字节序列正确地定义一个类型，并且必须遵循 Java 的 class 文件的固定格式，这样它才能被编译成在方法区中的内部数据结构</li><li>检验的内容：<ul><li>是否是魔数 OxCAFEBABE 开头</li><li>class 文件的主版本号和次版本号是否在虚拟机的支持范围之内</li><li>。。。</li></ul></li></ul><h4 id="第二趟扫描-语义检查"><a href="#第二趟扫描-语义检查" class="headerlink" title="第二趟扫描: 语义检查"></a>第二趟扫描: 语义检查</h4><ul><li>时间：在连接过程时进行</li><li>目的：确保类型数据遵从 Java 编程语言的语义</li><li>检验的内容：<ul><li>检查 class 文件每个组成部分，确保它们是否是其所属类型的实例，结构是否正确；</li><li>检查 final 的类不能拥有子类；</li><li>检查 final 的方法不能被覆盖；</li><li>确保在类型和超类型直接没有不兼容的方法声明（比如两个方法拥有同样的名字，参数在数量、类型、类型上都相同，但是返回类型不同）</li><li>检查这个类是否有父类（除了 Object 类以外的所有类，都必须有一个超类）</li></ul></li></ul><h4 id="第三趟扫描：-字节码验证"><a href="#第三趟扫描：-字节码验证" class="headerlink" title="第三趟扫描： 字节码验证"></a>第三趟扫描： 字节码验证</h4><ul><li>时间：在连接过程时进行</li><li>目的：确保程序语义是合法的、符合逻辑的</li><li>检验内容：对数据流和控制流分析</li></ul><h4 id="第四趟扫描：-符号引用的验证"><a href="#第四趟扫描：-符号引用的验证" class="headerlink" title="第四趟扫描： 符号引用的验证"></a>第四趟扫描： 符号引用的验证</h4><ul><li>时间：在<strong>动态连接阶段</strong>进行的</li><li>目的：确保被引用的类、字段及其方法确实存在</li><li>检查内容：<ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li><li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段</li><li>符合引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问</li></ul></li></ul><p>符号引用验证的目的是确保解析动作能正常执行，如果没有通过验证、就会抛出 java.lang.InCompatibleClassChangeErro 的子类，例如 java.lang.ILLegalAccessError, java.lang.NoSuchFieldError, java.lang.NoSuchMethodError 等。</p><h3 id="2-2-准备"><a href="#2-2-准备" class="headerlink" title="2.2 准备"></a>2.2 准备</h3><p>在准备阶段，Java 虚拟机会为 <strong>类变量</strong>分配内存，设置默认值。</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value 是 A 的类变量，类型是 int, 在准备阶段，变量 value 赋值为默认值 0;至于将值 123 赋值给 value 是在初始化阶段。</p><p>基本类型的默认值</p><p><img src="/2020/08/05/jvm-class-lifetime/jvm_lift_3.png" width="50%" height="50%"></p><h3 id="2-3-解析（可选）"><a href="#2-3-解析（可选）" class="headerlink" title="2.3 解析（可选）"></a>2.3 解析（可选）</h3><p><strong>解析过程就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用的过程</strong></p><p>常量池解析的最终目标是把符号引用替换为直接应用。</p><p>直接应用的数据格式：</p><ul><li>指向类型、类变量和类方法的直接引用是 指向方法区的本地指针</li><li>指向实例变量和实例方法的直接引用是 偏移量</li></ul><p>实例变量的直接引用可能是从对象的映像开始算起到这个实例变量位置的偏移量；<br>实例方法的直接应用是到方法表的偏移量。</p><h2 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3 初始化"></a>3 初始化</h2><p>在初始化阶段是为类变量赋予正确的值。<br>这里的”正确“初始值指的是程序员希望这个类变量所具备的起始值。</p><p>在 Java 代码中，一个正确的初始值是通过类变量初始化语句或者静态初始化给出的。<br>那上面的例子为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value 在准备阶段已经赋予默认值 0， 在初始化阶段，就会设值为 123</p><h3 id="3-1-初始化步骤"><a href="#3-1-初始化步骤" class="headerlink" title="3.1 初始化步骤"></a>3.1 初始化步骤</h3><p>初始化一个类包含两个步骤：</p><ul><li>如果类存在直接超类，且直接超类没有被初始化，就先初始化直接超类；</li><li>如果类存在一个类初始化方法，就执行此方法</li></ul><h3 id="3-2-主动使用和被动使用"><a href="#3-2-主动使用和被动使用" class="headerlink" title="3.2 主动使用和被动使用"></a>3.2 主动使用和被动使用</h3><p>这里的主动使用和被动使用，指的是虚拟机初始化 class 类时机时的使用方式，所有的 java 虚拟机实现必须在每个类或接口首次主动使用时初始化。</p><p>下面六种情形符合主动使用的要求：</p><ul><li>当创建某个类的新实例时（或者通过字节码中执行 new 指令；或者通过不明确的创建、反射或者反序列化）</li><li>当调用某个类或接口的静态字段，或者对该字段赋值（在字节码中，执行 getstatic 或 putstatic 指令时），用 final 修饰的静态字段除外，它被初始化编译时的常量表达式</li><li>当调用 Java API 的某个反射方法时，比如类 Class 中的方法或者 java.lang.reflect 包中类方法</li><li>当初始化某个类的子类时（某个类初始化时，要求它的超类已经被初始化了）</li><li>当虚拟机启动时某个被标明为启动的类（即含有 main() 方法的那个类</li></ul><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestParent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sleep = (<span class="keyword">int</span>)(Math.random() * <span class="number">3.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span>  <span class="keyword">int</span> touch = (<span class="keyword">int</span>)(Math.random() * <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"TestParent was initialized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestChild</span> <span class="keyword">extends</span> <span class="title">TestParent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> crying = <span class="number">1</span> + (<span class="keyword">int</span>)(Math.random() * <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"TestChild was initialized."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"TestClient was initialized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hours = TestChild.sleep;</span><br><span class="line">        System.out.println(<span class="string">"TestClient hours: "</span> + hours);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TestClient was initialized</span><br><span class="line">TestParent was initialized</span><br><span class="line">TestClient hours: 1</span><br></pre></td></tr></table></figure><p>从上面的例子可以看出， TestChild 没有被初始化，TestParent 被初始化了。</p><h3 id="3-3-接口的初始化"><a href="#3-3-接口的初始化" class="headerlink" title="3.3 接口的初始化"></a>3.3 接口的初始化</h3><p><strong>当 Java 虚拟机初始化一个类时，要求它所有父类都已经被初始化，但是这条规则不适用于接口</strong></p><ul><li>在初始化一个类时，并不会初始化它所实现的接口</li><li>在初始化一个接口时，并不会先初始化它的父接口</li></ul><p>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java 虚拟机通过装载、连接和初始化一个 Java 类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类的完整生命周期包括：加载、验证、准备、解析、初始化、使用、卸载&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/08/05/jvm-clas
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JVM(四)类加载器</title>
    <link href="https://yxhuangch.github.io/2020/07/07/java-class-loader/"/>
    <id>https://yxhuangch.github.io/2020/07/07/java-class-loader/</id>
    <published>2020-07-07T00:25:25.000Z</published>
    <updated>2020-08-12T15:37:18.260Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-类加载器"><a href="#1-类加载器" class="headerlink" title="1.类加载器"></a>1.类加载器</h2><p><img src="/2020/07/07/java-class-loader/jvm_1.png" width="50%" height="50%"></p><p>Java 虚拟机的主要任务是装载 class 文件并且执行其中的字节码。类加载器的作用是加载程序或 Java API 的 class 文件，并将字节码加载到执行引擎。</p><p>在加载 class 文件时， 为了防止加载进来恶意的代码，需要在类的加载器体系中去实现一些规则，保证在 Java 沙箱的安全模型。</p><p>类加载其在 Java 沙箱中主要是三方面</p><ul><li>守护了被信任的类库的边界 - 通过双亲委托机制实现</li><li>防止恶意代码去干涉善意代码 - 通过不同的命名空间去实现</li><li>将代码归入某类（称为保护域,该类确定了代码可以进行哪些操作。</li></ul><p>这三方面我们后续会一个一个说</p><p>首先我们先看看在 Java 虚拟机中的整个类加载器体系</p><h2 id="2-双亲委托机制"><a href="#2-双亲委托机制" class="headerlink" title="2. 双亲委托机制"></a>2. 双亲委托机制</h2><p>类加载器体系守护了被信任的类库的边界，这是通过分别使用不同的类加载器加载可靠包和不可靠包来实现的。</p><p>这些不同的类加载器之间的依赖关系，构成了 Java 虚拟机中的双亲委托机制。<strong>所谓的双亲委托机制，是指类加载器请求另一个类加载器来加载类的过程。</strong></p><p><img src="/2020/07/07/java-class-loader/jvm_2.png" width="50%" height="50%"></p><p>上图是类加载器双亲委托模型，我们可以看到，除了启动类加载器以外的每一个类加载器，都有一个 ”双亲“ 类加载器，在某个特定的类加载器试图以常用的方式加载类以前，它会默认将这个任务 ”委托“ 给它的双亲 – 请求它的双亲来加载这个类。这个双亲再依次请求它自己的双亲来加载这个类。这个委托的过程一直向上继续，直到达到启动类加载器。如果一个类加载器的双亲类加器有能力来加载这个类，则这个类加载器返回这个类。否则，这个类加载器试图自己来加载这个类。</p><p>它们有着不同的启动路径</p><table><thead><tr><th>类加载器</th><th>路径</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader 启动类加载器</td><td>Load JRE\lib\rt.jar 或者 -Xbootclasspath 选项指定的 Jar 包</td></tr><tr><td>Extension ClassLoader 扩展类加载器</td><td>Load JRE\lib\ext*.jar 或 -Djava.ext.dirs 指定目录下的 Jar 包</td></tr><tr><td>Application ClassLoader 应用程序类加载器</td><td>Load CLASSPATH 或 -Djava.class.path 所指定的目录下的类和 Jar 包</td></tr><tr><td>User ClassLoader 自定义类加载器</td><td>通过 Java.lang.ClassLoader 的子类自定义加载 class</td></tr></tbody></table><p> ClassLoader 的 loadClass 方法和 findClass 方法，如果是我们自定义 ClassLoader 的话，只需要重写 findClass 方法即可</p><p>下面我们用一个例子来说明来加载器的双亲委托机制。我们自定义一个 ClassLoader 并复写它的 findClass() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Class <span class="title">findClass</span><span class="params">(String className)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"findClass className: "</span> + className);</span><br><span class="line">      <span class="keyword">byte</span>[] classData;</span><br><span class="line"></span><br><span class="line">      classData = getTypeFromBasePath(className);</span><br><span class="line">      <span class="keyword">if</span> (classData == <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Parse it</span></span><br><span class="line">      <span class="keyword">return</span> defineClass(className, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] getTypeFromBasePath(String typeName)&#123;</span><br><span class="line">      FileInputStream fis;</span><br><span class="line">      String fileName = path  + typeName.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">      System.out.println(<span class="string">"getTypeFromBasePath fileName :"</span> + fileName);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          fis = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          <span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">      ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">int</span> c = bis.read();</span><br><span class="line">          <span class="keyword">while</span> ( c != -<span class="number">1</span>)&#123;</span><br><span class="line">              out.write(c);</span><br><span class="line">              c = bis.read();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后在我们通过 IDEA 编译，将编译出来的 Class 文件版本放到桌面，并且指定路径进行加载。</p><p><img src="/2020/07/07/java-class-loader/jvm_3.png" width="50%" height="50%"></p><p>然后在 main 方法中运行，将路径设置为 我们在上面的桌面 视图加载 Test1 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//  loadClass</span></span><br><span class="line">        MyClassLoader loader1 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader1"</span>);</span><br><span class="line"></span><br><span class="line">        loader1.setPath(<span class="string">"/Users/yxhuang/Desktop/"</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = loader1.loadClass(<span class="string">"com.yxhuang.jvm.bytecode.Test1"</span>);</span><br><span class="line">        System.out.println(<span class="string">"class name: "</span> + clazz.getSimpleName() + <span class="string">" \nclass hashcode: "</span> + clazz.hashCode() + <span class="string">" \nloader: "</span> + clazz.getClassLoader().getClass().getSimpleName());</span><br><span class="line">        Object object1 = clazz.newInstance();</span><br><span class="line">        System.out.println(object1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子，我们将 <code>MyClassLoader</code> 命名为 <code>loader1</code>, 设置路径为我们的电脑桌面。这时候运行，看看输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class name: Test1 </span><br><span class="line">class hashcode: 1265094477 </span><br><span class="line">loader: AppClassLoader</span><br><span class="line">com.yxhuang.jvm.bytecode.Test1@7ea987ac</span><br></pre></td></tr></table></figure><p>上面输出，我们看看 Test1 类文件已经加载进了 类加载器，但是打印出来，我们看到 ClassLoader 是 AppClassLoader 而不是我们自定义的 MyClassLoader。 为什么会这样呢，这就涉及到类的双亲委托机制了。</p><p>当我们用 loader1 视图去加载 <code>com.yxhuang.jvm.bytecode.Test1</code> 这个类的时候，根据双亲委托机制，自定义的类加载器  MyClassLoader 会委托它的父加载器 AppClassLoader 去加载， AppClassLoader 应用类加载器又会委托它的父类加载器 Bootstrap ClassLoader 启动类去加载。而 Bootstrap ClassLoader 找不到这个类，然后让 AppClassLoader 去加载，还记得上面提到 AppClassLoader 加载的路径是项目的 ClassPath, 这时候找到了 Test1 类并加载了它，并没有让 MyClassLoader 去加载</p><p><img src="/2020/07/07/java-class-loader/jvm_4.png" width="50%" height="50%"></p><p>现在，我们把 out/production/class 路径里面的 Test1 删掉，再次运行查看结果<br>这时候的输出是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">findClass className: com.yxhuang.jvm.bytecode.Test1</span><br><span class="line">getTypeFromBasePath fileName :/Users/yxhuang/Desktop/com/yxhuang/jvm/bytecode/Test1.class</span><br><span class="line">class name: Test1 </span><br><span class="line">class hashcode: 1554874502 </span><br><span class="line">loader: MyClassLoader</span><br><span class="line">com.yxhuang.jvm.bytecode.Test1@6e0be858</span><br></pre></td></tr></table></figure><p>看到上面的输出，我们看到我们自定义的 MyClassLoader 被调用了，加载 Test1 的路径是  <code>/Users/yxhuang/Desktop/com/</code> , 类加载器也是我们自定义的 MyClassLoader</p><p><img src="/2020/07/07/java-class-loader/jvm_5.png" width="50%" height="50%"></p><p>MyClassLoader 会委托给它的父类，最后到 启动类加载器，然后 MyClassLoader 之上的类加载器没有一个能加载到，最后只能是 MyClassLoader 来加载。</p><p>双亲委托机制可以保证父类先加载 Class 文件，特别是 jdk 里面的类，保证 jdk 类的类优先被启动类加载器加载，防止恶意代码伪装成 jdk 的类去破坏 jvm 的运行。</p><p><strong>双亲委托机制还有下面的一些特点：</strong></p><ul><li><strong>1.如果没有显示地传递一个双亲类装载器给用户自定义的类装载器的构造方法，系统装载器就默认被指定为双亲。</strong></li><li><strong>2. 如果传递到构造方法的是一个已有的用户自定义类型装载器的引用，该用户自定义装载器就被作为双亲。</strong></li><li><strong>3.如果传递的方法是一个 null, 启动类装载器就是双亲。</strong></li><li><strong>4.在类装载器之间具有了委派关系，首先发起装载要求的类装载器不必是定义该类的类装载器。</strong></li></ul><p>当时双亲委托机制，也有它不足的地方，在不需要双亲委托机制的地方，需要上下文类加载器。关于上下文类加载器，后面我们会讲到，这里先跳过。</p><p>下面我们先看看命名空间</p><h2 id="3-类加器的命名空间"><a href="#3-类加器的命名空间" class="headerlink" title="3. 类加器的命名空间"></a>3. 类加器的命名空间</h2><p>下面我们通过实例代码，说明命名空间</p><p>先定义一个 Person 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPerson</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setPerson "</span> + object.getClass().getSimpleName());</span><br><span class="line">        <span class="keyword">this</span>.person = (Person) object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 IDEA 编译成 class 文件，将编译出来的 Class 文件版本放到桌面，并且指定路径进行加载。然后将 Persion 的 class 文件 删除，同时注释 Person。</p><p>下面是命名空间的测试类, 设置加载路径，用两个不同的类加载器去加载 <code>com.yxhuang.jvm.classloader.Person</code> 类，然后通过反射，调用 class1 的 <code>setPerson</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameSpaceLoaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader classLoader1 = <span class="keyword">new</span> MyClassLoader(<span class="string">"classloader1"</span>);</span><br><span class="line">        MyClassLoader classLoader2 = <span class="keyword">new</span> MyClassLoader(<span class="string">"classloader2"</span>);</span><br><span class="line"></span><br><span class="line">        classLoader1.setPath(<span class="string">"/Users/yxhuang/Desktop/"</span>);</span><br><span class="line">        classLoader2.setPath(<span class="string">"/Users/yxhuang/Desktop/"</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; class1 = classLoader1.loadClass(<span class="string">"com.yxhuang.jvm.classloader.Person"</span>);</span><br><span class="line">        Class&lt;?&gt; class2 = classLoader2.loadClass(<span class="string">"com.yxhuang.jvm.classloader.Person"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"class1 : "</span> + class1.getSimpleName() + <span class="string">" "</span> +  class1.getClassLoader().toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"class2 : "</span> + class2.getSimpleName() + <span class="string">" "</span> +  class2.getClassLoader().toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(class1 == class2);</span><br><span class="line"></span><br><span class="line">        Object object1 = class1.newInstance();</span><br><span class="line">        Object object2 = class2.newInstance();</span><br><span class="line"></span><br><span class="line">        Method method = class1.getMethod(<span class="string">"setPerson"</span>, Object.class);</span><br><span class="line">        method.invoke(object1, object2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们看看输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">findClass className: com.yxhuang.jvm.classloader.Person</span><br><span class="line">getTypeFromBasePath fileName :/Users/yxhuang/Desktop/com/yxhuang/jvm/classloader/Person.class</span><br><span class="line"></span><br><span class="line">findClass className: com.yxhuang.jvm.classloader.Person</span><br><span class="line">getTypeFromBasePath fileName :/Users/yxhuang/Desktop/com/yxhuang/jvm/classloader/Person.class</span><br><span class="line"></span><br><span class="line">class1 : Person com.yxhuang.jvm.classloader.MyClassLoader@42a57993</span><br><span class="line"></span><br><span class="line">class2 : Person com.yxhuang.jvm.classloader.MyClassLoader@6bc7c054</span><br><span class="line"></span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">// 还会抛出异常</span><br><span class="line">Caused by: java.lang.ClassCastException: com.yxhuang.jvm.classloader.Person cannot be cast to com.yxhuang.jvm.classloader.Person</span><br></pre></td></tr></table></figure><p>根据上面的打印，我们可以知道， class1 和 class2 都是 Person 类，但是 <code>class1 == class2</code> 是 false 的，说明他们不是同一个类。</p><p>将 class1 和 class2 通过 newInstance() 方法生成对应的 object1 和 object2 对象，这也都是 Person 类的对象。<br>在调用反射将 object1 的 setPerson 方法会抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPerson</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setPerson "</span> + object.getClass().getSimpleName());</span><br><span class="line">        <span class="keyword">this</span>.person = (Person) object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抛出的异常是说 Person 对象不能强转成 Person 对象。这个异常就很奇怪了，那为什么会出现这个异常，那就要说到 java 虚拟机里面的命名空间了。<br>因为这两个对象加载的虚拟机不一样，导致命名空间不一样导致的。</p><p>命名空间是表示当前类的加载器的命名空间，是由当前类转加载器是自己的初始类加载器的类型名称组成的。</p><p>命名空间的作用是通过不同的命名空间，防止恶意代码去干涉其他代码。在 Java 虚拟机中，在同一个命名空间内的类可以之间进行交互，而不同的命名空间中的类察觉不到彼此的存在。</p><p>每个类装载器都有自己的命名空间，其中维护者由它装载的类型。所以一个 Java 程序可以多次装载具有一个全限定名的多个类型。这样一个类的全限定名就不足以确定在一个 Java 虚拟机中的唯一性。因此，当多个类装载器都装载了同名的类型时，为了唯一地标识该类型，还要在类型名称前加上装载器该类（指出了它所位于的命名空间）的类装载器的标识。</p><p>上面 Person 的这个例子就说明，一个类的全限定名 <code>com.yxhuang.jvm.classloader.Person</code> 不能确定它的唯一性，我们可以用另外一个类加载器去再次加载这个类。</p><p>综上所述，如果想要确定一个类是否是唯一的或者说判断两个类是否相等，就需要他们的类加载器为同一个累加器，并且命名空间是一致的。</p><p>关于命名空间的一些论述</p><ul><li><ol><li>每个类装载器都有自己的命名空间，命名空间由该装载器及其父装载器所装载的类组成；</li></ol></li><li><ol start="2"><li>在同一个命名空间中，不会出现类的完整姓名（包括类的包名）相同的两个类；</li></ol></li><li><ol start="3"><li>在不同的命名空间中，有可能会出现类的完整名字（包含类的包名）相同的两个类。</li></ol></li></ul><p>类装载器和这个类本身一起共同确立在 Java 虚拟机中的唯一性，每一个类装载器，都有一个独立的命名空间。<br>也就是说，比较两个类是否”相等“，只有这两个类是由同一个类装载器的前提下，否则，即使这两个类来源于同一个 Class 文件，被同一个 Java 虚拟机加载，只要加载它们的类装载器不同，那这两个类就必定不相等。</p><p>不同的加载器实例加载的类被认为是不同的类</p><p>在 JVM 的实现中有一条隐含的规则，默认情况下，如果一个类由类加载器 A 加载，那么这个类的依赖类也是由相同的类加载器加载</p><p>上面的几条论述在例子中也有体现。</p><h2 id="4-自定义类加载器"><a href="#4-自定义类加载器" class="headerlink" title="4 自定义类加载器"></a>4 自定义类加载器</h2><h3 id="4-1-自定义类加载器"><a href="#4-1-自定义类加载器" class="headerlink" title="4.1 自定义类加载器"></a>4.1 自定义类加载器</h3><p>如果想要自定义类加载器，只需要继承 ClassLoader 并且重写它的 findClass() 方法。</p><p>在 findClass() 方法里面根据路径去加载相应的 Class 文件流，然后将数据传递给 ClassLoader 自带的 defineClass() 方法，defineClass() 会将Class 流文件转成 Class 类的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected Class findClass(String className) throws ClassNotFoundException &#123;</span><br><span class="line">    System.out.println(&quot;findClass className: &quot; + className);</span><br><span class="line">    byte[] classData;</span><br><span class="line">    </span><br><span class="line">    // 指定路径加载 Class 流文件</span><br><span class="line">    classData = getTypeFromBasePath(className);</span><br><span class="line">    if (classData == null)&#123;</span><br><span class="line">        throw new ClassNotFoundException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Parse it 将流文件转成一个 Class 类实例</span><br><span class="line">    return defineClass(className, classData, 0, classData.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，必须要了解 ClassLoader 里面的 loadClass() 方法</p><h3 id="4-2-loadClass-方法"><a href="#4-2-loadClass-方法" class="headerlink" title="4.2 loadClass() 方法"></a>4.2 loadClass() 方法</h3><p>在我们自定义了 ClassLoader 之后，会调用  loadClass() 方法去加载想要加载的类。</p><ul><li><p>loadClass() 的基本工作方式：<br>给定需要查找的类型的全限定名， loadClass()方法会用某种方式找到或生成字节数组到，里面的数据采用 Java Class 文件格式（用该格式定义类型）。如果 loadClass() 无法找到或生成这些字节，就会抛出 ClassNotFoundException 异常。否则，loadClass() 会传递这个自己数组到 ClassLoader 声明的某一个 defineClass() 方法。通过把这些字节数组传递给<br>defineClass(),loadClass() 会要求虚拟机把传入的字节数组导入这个用户自定义的类装载器的命名中间中去。</p></li><li><p>loadClass 的步骤：</p><ul><li>1.查看是否请求的类型已经被这个类装载器装载进命名空间（提供 findLoadedClass()）方法的工作方式</li><li>2.否则，委派到这个类装载器的双亲装载器。如果双亲返回了一个 Class 实例，就把这个 Class 实例返回。</li><li><ol start="3"><li>否则，调用 findClass(), findClass() 会试图寻找或者生成一个字节数组，内容采用 Java Class 文件格式（它定义了所需要的类型）。如果成功，findClass() 把这个字节传递给 defineClass() ，后者试图导入这个类型，返回一个 Class 实例。 如果 findClass() 返回一个 Class 实例，loadClass() 就会把这个实例返回。</li></ol></li><li><ol start="4"><li>否则， findClass() 抛出某些异常来中止处理，而且 loadClass() 也会抛出异常中止。</li></ol></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个类加载器都有个父加载器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//查找一下这个类是不是已经加载过了</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果没有加载过</span></span><br><span class="line">        <span class="keyword">if</span>( c == <span class="keyword">null</span> )&#123;</span><br><span class="line">          <span class="comment">//先委托给父加载器去加载，注意这是个递归调用</span></span><br><span class="line">          <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">              c = parent.loadClass(name);</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果父加载器为空，查找Bootstrap加载器是不是加载过了</span></span><br><span class="line">              c = findBootstrapClassOrNull(name);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果父加载器没加载成功，调用自己的findClass去加载</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> c；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name)&#123;</span><br><span class="line">       <span class="comment">//1. 根据传入的类名name，到在特定目录下去寻找类文件，把.class文件读入内存</span></span><br><span class="line">          ...</span><br><span class="line">          </span><br><span class="line">       <span class="comment">//2. 调用defineClass将字节数组转成Class对象</span></span><br><span class="line">       <span class="keyword">return</span> defineClass(buf, off, len)；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将字节码数组解析成一个Class对象，用native方法实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-线程上下文类加载器"><a href="#5-线程上下文类加载器" class="headerlink" title="5 线程上下文类加载器"></a>5 线程上下文类加载器</h2><p>双亲委托机制不适用的场景下，需要使用到 上下文类加载器(Thread Context ClassLoader)</p><p>场景是有基础类要调用用户代码(Service Provider Interface, SPI)</p><p>线程上下文加载器通过  Thread 类的 setContextClassLoader() 方法进行设置，如果创建线程还未设置，就会从父线程中继承一个，如果在应用程序的全局范围都没有设置过的话，那这个类装载器默认是应用类加载器。</p><h2 id="6-获取-ClassLoader-的途径"><a href="#6-获取-ClassLoader-的途径" class="headerlink" title="6.获取 ClassLoader 的途径"></a>6.获取 ClassLoader 的途径</h2><p>获取当前类的 ClassLoader: clazz.getClassLoader()</p><p>获取当前线程上下文的 ClassLoader: Thread.currentThread().getContextClassLoader()</p><p>获取系统的 ClassLoader : ClassLoader.getSystemClassLoader()</p><p>获取调用者的 ClassLoader: DriverManager.getCallerClassLoader()</p><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7.参考"></a>7.参考</h2><ul><li><a href="https://book.douban.com/subject/1138768/" target="_blank" rel="noopener">《深入 Java 虚拟机》</a></li><li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解 Java 虚拟机》</a></li><li><a href="http://www.iprogramming.cn/" target="_blank" rel="noopener">圣思园张龙</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-类加载器&quot;&gt;&lt;a href=&quot;#1-类加载器&quot; class=&quot;headerlink&quot; title=&quot;1.类加载器&quot;&gt;&lt;/a&gt;1.类加载器&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2020/07/07/java-class-loader/j
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 虚拟机（二）：Class 文件结构</title>
    <link href="https://yxhuangch.github.io/2020/04/12/jvm-class-file/"/>
    <id>https://yxhuangch.github.io/2020/04/12/jvm-class-file/</id>
    <published>2020-04-12T13:14:25.000Z</published>
    <updated>2020-04-14T00:10:14.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Class-文件结构"><a href="#Class-文件结构" class="headerlink" title="Class 文件结构"></a>Class 文件结构</h1><p><strong>Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件中，中间没有添加任何分隔符。</strong></p><h2 id="1-ClassFile-结构"><a href="#1-ClassFile-结构" class="headerlink" title="1  ClassFile 结构"></a>1  ClassFile 结构</h2><p>（从上往下顺序）</p><table><thead><tr><th>数据类型</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td>u4</td><td>magic</td><td>魔数，固定是 0xCAFEBABE</td></tr><tr><td>u2</td><td>minor_version</td><td>副版本号</td></tr><tr><td>u2</td><td>major_version</td><td>主版本号</td></tr><tr><td>u2</td><td>constanct_pool_count</td><td>常量池计数器</td></tr><tr><td>cp_info</td><td>constanct_pool[constanct_pool_count - 1]</td><td>常量池</td></tr><tr><td>u2</td><td>access_flags</td><td>访问标志</td></tr><tr><td>u2</td><td>this_class</td><td>类索引</td></tr><tr><td>u2</td><td>super_class</td><td>父类索引</td></tr><tr><td>u2</td><td>interfaces_count</td><td>接口计数器</td></tr><tr><td>u2</td><td>interfaces[interfaces_count]</td><td>接口表</td></tr><tr><td>u2</td><td>fields_count</td><td>字段计算器</td></tr><tr><td>field_info</td><td>fields[fields_count]</td><td>字段表</td></tr><tr><td>u2</td><td>methods_count</td><td>方法计数器</td></tr><tr><td>method_info</td><td>methods[methods_count]</td><td>类和接口中定义的所有方法</td></tr><tr><td>u2</td><td>attributes_count</td><td>属性计数器</td></tr><tr><td>attribute_info</td><td>attributs[attributes_count]</td><td>属性表</td></tr></tbody></table><p>说明：</p><ul><li>u1 代表1个字节</li><li>u2 代表2个字节</li><li>u4 代表4个字节</li><li>u8 代表8个字节</li></ul><h3 id="1-1-特殊方法"><a href="#1-1-特殊方法" class="headerlink" title="1.1 特殊方法"></a>1.1 特殊方法</h3><ul><li><init> 这个方法名称由编译器生成的，它代表着类的实例化，也就是说构造函数的调用</init></li><li><clinit> 这个方法名称也是由编译器生成的，它代表着静态类的调用</clinit></li></ul><h3 id="1-2-描述符标识字符含义"><a href="#1-2-描述符标识字符含义" class="headerlink" title="1.2 描述符标识字符含义"></a>1.2 描述符标识字符含义</h3><table><thead><tr><th>标识符字符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>byte</td></tr><tr><td>C</td><td>char</td></tr><tr><td>D</td><td>double</td></tr><tr><td>F</td><td>float</td></tr><tr><td>I</td><td>int</td></tr><tr><td>J</td><td>long</td></tr><tr><td>S</td><td>short</td></tr><tr><td>Z</td><td>boolean</td></tr><tr><td>V</td><td>特殊类型 void</td></tr><tr><td>L</td><td>对象类型，例如 Ljava/lang/Object</td></tr></tbody></table><p>数组类型，每一维将使用一个前置的 “[“ 字符来描述，<br>例如 String[][] -&gt; [[Ljava/lang/String, int[] -&gt; [i</p><p>用描述符描述方法时，按参数先，后返回值的顺序描述<br>例如</p><blockquote><p>int  indexOf(Sting a, int i) 对应是 (Ljava/lang/StringI)I<br>void inc()  对应 ()V</p></blockquote><h2 id="2-Magic-魔数-与版本"><a href="#2-Magic-魔数-与版本" class="headerlink" title="2 Magic 魔数 与版本"></a>2 Magic 魔数 与版本</h2><p><img src="/2020/04/12/jvm-class-file/jvm_class_1.png" width="100%" height="100%"></p><p>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yxhuang.jvm.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-Magic-Number-魔数-u4"><a href="#2-1-Magic-Number-魔数-u4" class="headerlink" title="2.1 Magic Number 魔数 u4"></a>2.1 Magic Number 魔数 u4</h3><p>位于 Class 文件的头四个字节成为魔数(Magic Number)<br>作用是确定这个文件能否被虚拟机接受的 Class 文件</p><p>上图中 <code>CA FE BA BE</code> 四个字节就是 Magice Number 固定不变</p><h3 id="2-2-版本"><a href="#2-2-版本" class="headerlink" title="2.2 版本"></a>2.2 版本</h3><ul><li>minor_version 副版本号 u2</li><li>major_version 主版本号 u2</li></ul><p><strong>高版本好的虚拟机可以支持低版本号的 Class 文件，反之则不行</strong></p><p>例如52.1<br>52 是主版本号， 0.1 是副版本号</p><p>常用的 Class 文件版本号</p><table><thead><tr><th>编译器器版本</th><th>十六进制版本号</th><th>十进制版本号</th></tr></thead><tbody><tr><td>JDK 1.7.0</td><td>00 00 00 32</td><td>50</td></tr><tr><td>JDK 1.8.0</td><td>00 00 00 34</td><td>52</td></tr></tbody></table><p>上图中 <code>00 00 00 34</code> 代表版本号，副版本号是 <code>00 00</code>, 主版本号是 <code>00 34</code> 则说明是 JDK 1.8 编译的</p><h2 id="3-常量池-constant-pool"><a href="#3-常量池-constant-pool" class="headerlink" title="3 常量池 constant_pool"></a>3 常量池 constant_pool</h2><h3 id="3-1-说明"><a href="#3-1-说明" class="headerlink" title="3.1 说明"></a>3.1 说明</h3><p><strong>Class 文件结构中，只有常量池的计数是从 1 开始的，其他集合类型都是从 0 开始</strong></p><p>图一中的 contant_pool_count 是 <code>00 18</code> 变成 10 进制是 24，但是常量个数 = 24 -1 = 23 个</p><p><img src="/2020/04/12/jvm-class-file/jvm_class_2.png" width="50%" height="50%"></p><p><img src="/2020/04/12/jvm-class-file/jvm_class_3.png" width="80%" height="50%"></p><h3 id="3-2-例子"><a href="#3-2-例子" class="headerlink" title="3.2 例子"></a>3.2 例子</h3><p>看第一个常量 <code>0x0A</code> 是 10，对应上表是 CONSTANT_Methodref_info </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Methodref_info&#123;</span><br><span class="line">    u1 tag                   0A</span><br><span class="line">    u2 class_index           00 04  </span><br><span class="line">    u2 name_and_type_index   00 14</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>0A</strong> 对应是 CONSTANT_Methodref_info 类型</li><li><strong>00 04</strong> class_index， 指向常量池表中索引 #4 的 CONSTANT_Class_info 结构。<br>CONSTANT_Class_info 表示一个类或接口，当前字段或方法就是这个类或接口的成员</li><li><strong>00 14</strong> name_and_type_index，指向常量池索引为 #20 的 CONSTANT_NameAndType_info结构。 CONSTANT_NameAndType_info 结构表示当前字段或方法的描述符</li></ul><p>对着下图，我们看到</p><blockquote><p> #1 对应 Methodref, 指向   #4.#20， 和我们上面分析的一致</p><p> #4 Class 指向 #23 java/lang/Object 说明当前这个方法是 java.lang.Object</p><p> #20 NameAndType 指向了 #7和#8  <init>()V 说明这个方法是 <init>；方法描述符是 ()V</init></init></p></blockquote><p><img src="/2020/04/12/jvm-class-file/jvm_class_4.png" width="80%" height="50%"><br>常量池例子图一</p><p><img src="/2020/04/12/jvm-class-file/jvm_class_5.png" width="80%" height="50%"><br>常量池例子图二</p><p>常量池例子图二 中选中的字节就是常量池的内容<br>其他的方法可以用类似例子的方法对照常量项的结构总表一个个去分析</p><p>常量池中的 14 种常量项的结构总表<br><img src="/2020/04/12/jvm-class-file/jvm_class_6.png" width="80%" height="50%"><br><img src="/2020/04/12/jvm-class-file/jvm_class_7.png" width="80%" height="50%"></p><h3 id="3-3-访问标志-access-flags-u2"><a href="#3-3-访问标志-access-flags-u2" class="headerlink" title="3.3  访问标志 access_flags u2"></a>3.3  访问标志 access_flags u2</h3><p>访问标志在常量池之后的后两位 u2, 用于标志类或接口层次的访问信息；<br>包括</p><ul><li>这个 Class 是类还是接口</li><li>是否定义为 public 类型</li><li>是否定义为 abstract 类型</li><li>如果是类的话，是否被定义为 final</li></ul><p>一般是两个位的组合</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>是否为 pulic 类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>是否声明为 final,只有类可设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>是否允许使用 invokespecial 字节码的新语意</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标志这是个接口</td></tr><tr><td>ACC_ABSTEACT</td><td>0x0400</td><td>是否为 sbstract 类型，对于接口或抽象类说，此标志值为真，其他类值为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标识这个类并非由用户代码产生的</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标识这个是注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标识这个是枚举</td></tr></tbody></table><p>如果是一个普通类，不是接口、枚举或者注解，被 public 关键字修饰但没有被声明为 final 和 abstract.是用组合值</p><p>0x0021 = 0x0001|0x0020</p><p>说明这个类是 PUBLIC, SUPTER</p><p><img src="/2020/04/12/jvm-class-file/jvm_class_8.png" width="80%" height="50%"></p><h2 id="4-类索引、父索引与接口索引集合"><a href="#4-类索引、父索引与接口索引集合" class="headerlink" title="4 类索引、父索引与接口索引集合"></a>4 类索引、父索引与接口索引集合</h2><p><strong>Class 文件由类索引、父索引和接口索引这三项数据来确定这个类的继承关系。</strong></p><h3 id="4-1-类索引-this-class"><a href="#4-1-类索引-this-class" class="headerlink" title="4.1 类索引 this_class"></a>4.1 类索引 this_class</h3><p>类索引用于确定这个类的全限定名<br>u2 类型的索引值，指向类型 CONSTANT_Class_info 的类描述符</p><h3 id="4-2-父索引-super-class"><a href="#4-2-父索引-super-class" class="headerlink" title="4.2 父索引 super_class"></a>4.2 父索引 super_class</h3><p>父索引用于确定这个类的父类全限定名<br>u2 类型的索引值，指向类型 CONSTANT_Class_info 的类描述符<br>除了 java.lang.Object 外，所有的 Java 类的父类索引都不为 0</p><h3 id="4-3-接口索引-interfaces"><a href="#4-3-接口索引-interfaces" class="headerlink" title="4.3 接口索引 interfaces"></a>4.3 接口索引 interfaces</h3><p>接口索引，入口是 u2 类型的的接口计数器（interfaces_count）表示索引表的容量。<br>如果及计数器值为 0 ，表示这个类没有任何接口，后面接口的索引表不占任何字节。</p><p>例子<br><img src="/2020/04/12/jvm-class-file/jvm_class_9.png" width="80%" height="50%"></p><p>上图中在常量池结束之后，就是类索引，查看 常量池例子图一<br><code>00 03</code>  指向 #3 的 CONSTANT_Class_info 索引， #3再指向 #20， 是</p><blockquote><p> #22 = Utf8               com/yxhuang/jvm/bytecode/Test1<br>说明这个类 <code>com.yxhuang.jvm.bytecode.Test1</code></p></blockquote><p>父类索引是 <code>00 04</code>， 指向 #4 的 CONSTANT_Class_info 索引，#4 再指向#23</p><blockquote><p> #23 = Utf8  java/lang/Object</p></blockquote><p>说明这个类的父类是 java.lang.Object。在 java 中如果一个类没有继承其他类，它的父类默认是 Object, 与我们现在看到的内容是对得上的</p><p>接口索引计数器 <code>00 00</code> 说明接口数量为 0， 则没有后面的接口索引表</p><h2 id="5-字段表-field-info"><a href="#5-字段表-field-info" class="headerlink" title="5 字段表 field_info"></a>5 字段表 field_info</h2><p><strong>字段表用于描述接口或类中声明的变量。<br>字段（field）包括类级变量（static field）以及实例变量,但不包括在方法内部声明的局部变量。</strong></p><p>字段表中不会列出从超类或者父类接口中继承而来的字段。</p><h3 id="5-1-字段表结构"><a href="#5-1-字段表结构" class="headerlink" title="5.1 字段表结构"></a>5.1 字段表结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">    u2              access_flags</span><br><span class="line">    u2              name_index</span><br><span class="line">    u2              descriptor_index;</span><br><span class="line">    u2              attributes_count;</span><br><span class="line">    attribute_info   attributes[attributes_count]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>access_flags 用于定义字段的访问权限和基本属性的掩码标识</li><li>name_index 对应常量池中的一个有效索引，指向 CONSTANT_Utf8_info 结构，标识一个有效的字段的非全限定名</li><li>descriptor_index 对应常量池中的一个字段描述符索引</li><li>attributes_count 表示当前字段的附加属性数量</li><li>attribute_info 附加属性<br>一般有：<ul><li>ConstantValue</li><li>Synthetic</li><li>Signature</li><li>Dprecated</li><li>RuntimeVisibleAnnotations</li><li>RuntimeInvisibleAnnoation</li></ul></li></ul><p>表5.1 字段 acces_flags 标志列表</p><table><thead><tr><th>标志名</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>声明为 public, 可以从包外访问</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>声明为 private, 只能自身访问</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>声明为 protected, 子类可以访问</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>声明为 static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>声明为 final, 定义后无法修改</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>声明为 valatile, 被标识的字段无法储存</td></tr><tr><td>ACC_TRANSIENT</td><td>0x0080</td><td>声明为 transient, 被标识的字段不会序列化</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>声明为被表示的字段的编译器产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>声明为 enum, 枚举类型</td></tr></tbody></table><p>descriptor_index 是 1.2 节中的描述符</p><p>attributes 属性包含 见后面的 属性 章节</p><p><code>00 01</code> 是 fields_count，字段个数，说明只有 1 个字段<br><code>00 02</code> 是 access_flags，表示是该字段是 private<br><code>00 05</code> 是 name_index， 指向 #05 是 a<br><code>00 06</code> 是 descriptor_index， 指向 #06 是 I, 根据 1.2 描述符表说明这个类是 int<br><code>00 00</code> 是附加属性个数，0 说明这字段没有附加属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#5 = Utf8               a</span><br><span class="line">#6 = Utf8               I</span><br></pre></td></tr></table></figure><p><img src="/2020/04/12/jvm-class-file/jvm_class_10.png" width="80%" height="50%"></p><h2 id="6-方法-method"><a href="#6-方法-method" class="headerlink" title="6 方法 method"></a>6 方法 method</h2><p>所有方法，包括实例初始化话方法以及类或接口初始化方法在内，都是由 methode_info 结构定义的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method_info &#123;</span><br><span class="line">    u2               access_flags</span><br><span class="line">    u2               name_index</span><br><span class="line">    u2               descriptor_index</span><br><span class="line">    u2               attributes_count</span><br><span class="line">    attribute_info   attributes[attributes_count]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>access_flags 用于定义当前方法的访问权限和基本属性的掩码标识</li><li>name_index 对应常量池中的一个有效索引，指向 CONSTANT_Utf8_info 结构，标识一个有效的字段的非全限定名</li><li>descriptor_index 对应常量池中的一个字段描述符索引</li><li>attributes_count 表示当前方法的附加属性数量</li><li>attribute_info 附加属性<br>  包含：<pre><code>- Code- Exceptions- Synthetic- Signature- Dprecated- RuntimeVisibleAnnotations- RuntimeInvisibleAnnotations- RuntimeVisibleParameterAnnotations- RuntimeInvisibleParameterAnnotations- AnnotationDefault</code></pre></li></ul><p>  <img src="/2020/04/12/jvm-class-file/jvm_class_10_1.png" width="80%" height="50%"></p><p> <code>00 03</code> 是 method_count ,说明方法的入口说明有三个方法，对照我们的源码，我们定义了 <code>getA</code> <code>setA</code> 两个方法，另外就是编译器自动为当前类生成的无参构造函数方法</p><p> <code>00 01</code> 是 access_flags， 对照方法访问标志表，说明该方法是 public<br> <code>00 07</code> 是 name_index， 指向常量池 #7 ，是<init><br> <code>00 08</code> 是 descriptor_index， 指向常量池的 #8, 是 ()V<br> <code>00 01</code> 是 attributes_count， 附加属性个数是 1<br> <code>00 09</code> 是 attribute_info， 附加属性的指向索引 #9，是 Code, 关于 Code 可以看 第七节属性 </init></p><p><img src="/2020/04/12/jvm-class-file/jvm_class_11.png" width="80%" height="50%"></p><h2 id="7-Code-属性"><a href="#7-Code-属性" class="headerlink" title="7 Code 属性"></a>7 Code 属性</h2><p>Code 属性是变长属性，位于 method_info 结构的 <code>attribute_info</code> 中。<br>一个 Code 属性只为唯一一个方法、实例初始化方法、类或接口初始化方法保存 Java　虚拟机指令及其相关辅助信息。</p><h3 id="7-1-格式"><a href="#7-1-格式" class="headerlink" title="7.1 格式"></a>7.1 格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">    u2      attribute_name_index;   // 一般是 &apos;Code&apos;</span><br><span class="line">    u4      attribute_length;</span><br><span class="line">    u2      max_stack;</span><br><span class="line">    u2      max_locals;</span><br><span class="line">    u4      code_length;</span><br><span class="line">    u1      code[code_length];</span><br><span class="line">    u2      exception_table_length;</span><br><span class="line">    &#123;</span><br><span class="line">        u2  start_pc;</span><br><span class="line">        u2  end_pc;</span><br><span class="line">        u2  handler_pc;</span><br><span class="line">        u2  catch_type;</span><br><span class="line">    &#125; exception_table[exception_table_length];</span><br><span class="line">    u2      attributes_count;</span><br><span class="line">    attribute_info  attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>attribute_name_index 是 属性名称的的常量索引 ，值一般是 Code</li><li>attribute_length 属性的的长度</li><li>max_stack 代表了操作数栈（Operand Stacks）深度的最大值。在方法执行的任意时刻，操作栈都不会超过这深度。</li><li>max_locals 代表了局部变量表所需的存储空间。存储单位是 Slot</li><li>code_length 代表编译之后的字节码指令长度， u4 类型，说明一个方法的最大长度是  <code>2^32 - 1</code>,也就是 65535</li><li>code[] 当前方法的 java 虚拟机的实际字节码， code 用于存储字节码指令的一系列字节流。 每个指令是 u1 类型， 根据对应的值去查虚拟机指令表</li><li>exception_table_length 异常表的成员个数</li><li>exception_table[] 异常表<ul><li>start_pc 和 end_pc 表示异常处理的索引范围，既 start_pc ≤ x &lt; end_pc</li><li>handle_pc 异常处理器的起点</li><li>catch_type 异常类型，指向常量池中的索引</li></ul></li><li>attributes_count 表示 Code 中的附加属性个数</li><li>attribute_info 附加属性</li></ul><h3 id="7-2-具体的例子"><a href="#7-2-具体的例子" class="headerlink" title="7.2 具体的例子"></a>7.2 具体的例子</h3><p><img src="/2020/04/12/jvm-class-file/jvm_class_7.2.png" width="80%" height="50%"></p><p><code>00 09</code> 在上面的 第 6 节已经说明了，是 #9, 值是 Code<br><code>00 00 00 38</code>  是 attribute_length 是 Code 属性长度，变成10进制是 56 个字节<br><code>00 02</code> 是 max_stack，说明操作栈是的最大深度是 2<br><code>00 01</code> 是 max_locals，说明存储空间是 1<br><code>00 00 00 0A</code> 是 code_length 说明 code 的长度是10个字节</p><h4 id="7-2-1-Code-的指令"><a href="#7-2-1-Code-的指令" class="headerlink" title="7.2.1 Code 的指令"></a>7.2.1 Code 的指令</h4><p>下面的内容是具体的 Code, 10 个字节， 每个字节可以根据虚拟机字节码指令表查找到,关于指令的具体行为，查看另外的资料 </p><p><img src="/2020/04/12/jvm-class-file/jvm_class_7.2.1.png" width="80%" height="50%"></p><blockquote><p>2A B7 00 01 2A 04 B5 00 02 B1</p></blockquote><ul><li><code>2A</code> 是 aload_0 指令</li><li><code>B7</code> 是 invokespecial指令， 调用父类的构造方法，  格式是  <code>invokespecial indexByte1 indexByte2</code>  </li><li><code>00 01</code> 指向常量池的 #1，是 <code>java/lang/Object.&quot;&lt;init&gt;&quot;:()V</code></li><li><code>2A</code> 是 aload_0 指令</li><li><code>04</code> 是 iconst_1 指令，将 int 型 1 推送至栈顶</li><li><code>B5</code> 是 putfield 是为指定的的类的实例赋值， 格式是 <code>putfield indexbyte1 indexbyte2</code> </li><li><p><code>00 02</code> 指向常量池的 #2 是 </p><blockquote><p>Fieldref       #3.#21         // com/yxhuang/jvm/bytecode/Test1.a:I</p></blockquote></li><li><p><code>B1</code> 是 return 指令</p></li></ul><p>通过 javap -verbose 看到的， 是一样的</p><p><img src="/2020/04/12/jvm-class-file/jvm_class_12.png" width="80%" height="50%"></p><h4 id="7-2-2-Code-异常表"><a href="#7-2-2-Code-异常表" class="headerlink" title="7.2.2 Code 异常表"></a>7.2.2 Code 异常表</h4><p><img src="/2020/04/12/jvm-class-file/jvm_class_7.2.2.png" width="80%" height="50%"></p><p>根据 Code 结构，在 Code 中跟在指令后面的是异常表</p><p><code>00 00</code> 是 exception_table_length 异常表的长度，这里是 0, 说明这个方法没有异常</p><h4 id="7-2-3-Code-的附近属性-attribute-info"><a href="#7-2-3-Code-的附近属性-attribute-info" class="headerlink" title="7.2.3 Code 的附近属性 attribute_info"></a>7.2.3 Code 的附近属性 attribute_info</h4><p>根据 Code 结构，在 Code 中跟在异常表后面的是附近属性</p><p><code>00 02</code> 是 attributes_count 代表这个方法的附近属性，这里是两个</p><p><strong>第一个附加属性</strong><br><code>00 0A</code> 是指向常量池的 #10, 是 LineNumberTable，说明这个属性是 LineNumberTable, 关于 LineNumberTable 属性，可以看后面的第 8 节<br><code>00 00 00 0A</code> 是 attribute_length， 表示附近附加属性的字节长度，只是是 10 个字节， 即后面的 <code>00 02 00 00 00 03 00 04 00 05</code></p><p><code>00 02</code> 是 line_number_table_length，表示  line_number 数组的个数，2 个</p><p><em>第一个数组</em><br><code>00 00</code> 是 start_pc，表示字节码行号， 这里是 0<br><code>00 03</code> 是 line_number， 表示 Java 源代码行数，这里是 3</p><p><em>第二个数组</em></p><p><code>00 04</code> 表示字节码行数是 4<br><code>00 05</code> 表示 Java 源代码行数是 5</p><p>对照下图，是和我们分析的一样</p><p><img src="/2020/04/12/jvm-class-file/jvm_class_13.png" width="80%" height="50%"></p><p>第一个属性已经结束了，来看看第二个属性</p><p><strong>第二个属性</strong><br><code>00 0B</code> 指向常量池的 #11 是 LocalVariableTable，是局部变量表，具体信息看看第 9 节<br><code>00 00 00 0C</code> 表示这个附加属性的长度是 14 个字节,即 <code>00 01 00 00 00 0A 00 0C 00 0D 00 00</code></p><p><code>00 01</code> 是 local_variable_table_length, 表示局部变量表的个数是 1<br><code>00 00</code> 是 start_pc 字节码行数 0<br><code>00 0A</code> 是 length，表示当前属性的长度，是 10<br><code>00 0C</code> 是 name_index，表示局部变量的名称，指向常量池的索引 #12，是 this<br><code>00 0D</code> 是 descriptor_index,表示局部变量的描述符，指向常量池的索引 #13，是 Lcom/yxhuang/jvm/bytecode/Test1;<br><code>00 00</code> 是 index，表示这个局部变量在栈帧局部变量表中 Slot 的位置，是 0</p><p>从上面的分支，和下图的结果可以看到是一样的</p><p><img src="/2020/04/12/jvm-class-file/jvm_class_14.png" width="80%" height="50%"></p><p>其他剩下的两个方法都可以按照这样去分析</p><h2 id="8-LineNumberTable-属性"><a href="#8-LineNumberTable-属性" class="headerlink" title="8  LineNumberTable 属性"></a>8  LineNumberTable 属性</h2><p>是可选、变长属性，位于 Code 结构中。<br>是用来确定源文件中的行号</p><h3 id="8-1-结构"><a href="#8-1-结构" class="headerlink" title="8.1 结构"></a>8.1 结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LineNumberTable_attribute &#123;</span><br><span class="line">    u2      attribute_name_index;  // 一般是 `LineNumberTable`</span><br><span class="line">    u4      attribute_length;</span><br><span class="line">    u2      line_number_table_length;</span><br><span class="line">    &#123;</span><br><span class="line">        u2  start_pc;</span><br><span class="line">        u2  line_number;</span><br><span class="line">    &#125;line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>attribute_name_index 指向常量池中的索引，是 “LineNumberTable”</li><li>attribute_length 表示当前属性的长度</li><li>line_number_table_length 表示数组的成员的个数</li><li>start_pc 表示改字符在源文件中的字节码行数</li><li>line_number 表示这个值在源文件的行数</li></ul><h2 id="9-LocalVaribleTable-属性"><a href="#9-LocalVaribleTable-属性" class="headerlink" title="9  LocalVaribleTable 属性"></a>9  LocalVaribleTable 属性</h2><p>是可选、变长属性，位于 Code 结构中<br>确定在执行过程中给定局部变量的信息</p><p>结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LocalVaribleTable_attribute &#123;</span><br><span class="line">    u2    attribute_name_index;    // 一般是`LocalVaribleTable`</span><br><span class="line">    u4    attribute_length; </span><br><span class="line">    u2    local_variable_table_length;</span><br><span class="line">    &#123;</span><br><span class="line">        u2  start_pc;</span><br><span class="line">        u2  length;</span><br><span class="line">        u2  name_index;</span><br><span class="line">        u2  descriptor_index;</span><br><span class="line">        u2  index;</span><br><span class="line">    &#125; local_variable_table[local_variable_table_length]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>attribute_name_index 是指向常量池中的索引，是 “LocalVaribleTable”</li><li>attribute_length 属性的长度</li><li>local_variable_table_length 局部变量表的长度</li><li>start_pc 和 length，表示所有给定的局部变量的索引都在范围[start_pc, start_pc + length) </li><li>index 表示一个局部变量的有效的非全限定名，指向常量池表的索引</li><li>descriptor_index 表示源程序中局部变量类型的字段描述符，指向常量池的索引</li><li>index 表示此局部标量在当前栈帧的局部变量表中的索引</li></ul><h2 id="10-属性-attribute"><a href="#10-属性-attribute" class="headerlink" title="10 属性 attribute"></a>10 属性 attribute</h2><p><strong>属性在 Class 文件格式中 ClassFile 结构、 field_info 结构、 method_info 结构 和 Code_attribute 结构中</strong></p><h3 id="通用格式"><a href="#通用格式" class="headerlink" title="通用格式"></a>通用格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute_info&#123;</span><br><span class="line">    u2      attribute_name_index</span><br><span class="line">    u4      attribute_length</span><br><span class="line">    u2      info[attribute_length]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-字节码文件的-Attribute"><a href="#11-字节码文件的-Attribute" class="headerlink" title="11 字节码文件的 Attribute"></a>11 字节码文件的 Attribute</h2><p><img src="/2020/04/12/jvm-class-file/jvm_class_15.png" width="80%" height="50%"></p><p><code>00 01</code> 代表属性个数， attributes_count， 只有一个<br><code>00 12</code> 是 attribute_name_index， 表示属性名称，指向 #18，是 SoureFile<br><code>00 00 00 02</code> 是 attribute_length， 表示属性长度，是 2<br><code>00 13</code> 是 attribute_info 的信息，指向 #19，是 Test1.java</p><p>上面说明，这个属性名称是 SourceFile, 名称是 Test1.java</p><h2 id="12-总结"><a href="#12-总结" class="headerlink" title="12 总结"></a>12 总结</h2><p>至此，我们整个 Class 文件已经分析完成了。分析 Class　文件需要耐心，按照　Class 文件结构，一个字节码，一个字节码去分析，就可以将整个 Class 文件弄清楚。</p><p>如果弄懂了整个 class 文件，对于学习 java 或者 kotlin 都有很大的帮助。<code></code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解 Java 虚拟机》(第2版)</a></li><li><a href="https://book.douban.com/subject/25792515/" target="_blank" rel="noopener">《Java 虚拟机规范》（Javs SE 7 版）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Class-文件结构&quot;&gt;&lt;a href=&quot;#Class-文件结构&quot; class=&quot;headerlink&quot; title=&quot;Class 文件结构&quot;&gt;&lt;/a&gt;Class 文件结构&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Class 文件是一组以 8 位字节为基础单位的二进制流，各
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android 动态链接库 So 的加载</title>
    <link href="https://yxhuangch.github.io/2020/03/28/android-so-load/"/>
    <id>https://yxhuangch.github.io/2020/03/28/android-so-load/</id>
    <published>2020-03-28T00:51:02.000Z</published>
    <updated>2021-08-20T06:24:53.745Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在做 Android 项目的时候，需要在 NativeActivity  中动态加载 so 。运行的时候，抛出了异常</p><blockquote><p>Caused by: java.lang.IllegalArgumentException: Unable to find native library  using classloader: dalvik.system.PathClassLoader</p></blockquote><p>在 NativeActivity 中可以看到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    BaseDexClassLoader classLoader = (BaseDexClassLoader) getClassLoader();</span><br><span class="line">        String path = classLoader.findLibrary(libname);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to find native library "</span> + libname +</span><br><span class="line">                                               <span class="string">" using classloader: "</span> + classLoader.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的源码中，可以知道，NativeActivity 要是通过 BaseDexClassLoader#findLibrary 方法去查找 so 的路径，然后进行判空。上面提到的异常，就是因为找不到这个 so 的 path, 抛处理的异常。</p><p>在这个异常之后有几个疑问</p><ul><li>第一个问题是： so 的加载过程是怎样的，so 是如何和现在运行的代码联系起来的？</li><li>第二个问题是： classLoader 通过 findLibrary 方法去查找 so 的 path, 这些path 有什么，是怎样来的？</li><li>第三个问题是：classLoader 是怎么来的，在哪里生成的？</li></ul><p>带着这三个问题去找答案，下面就是对三个问题答案的寻找过程。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本文通过讲述 Android 动态链接库 so 的加载过来，已经 so 的加载原理，可以对加载的整个流程有个清晰的认识，有助于对后续学习热修复有比较好的帮助。</p><p>下面代码分析的源码都是以 Android 9.0 版。</p><h2 id="1-Android-So-的加载过程"><a href="#1-Android-So-的加载过程" class="headerlink" title="1 Android  So 的加载过程"></a>1 Android  So 的加载过程</h2><p>在 Android 添加 so 有两种方式，一种是调用 <code>load(String filename)</code> 方法，传递进去的是路径；另一种是调用 <code>loadLibrary(String libname)</code> 方式，传递进去的是 so 的名称</p><blockquote><p>System.load(“/storage/emulated/0/libnative-lib.so”) 全路径<br>System.loadLibrary(“native-lib”); so 的名字</p></blockquote><h3 id="1-1-System-loadLibrary"><a href="#1-1-System-loadLibrary" class="headerlink" title="1.1 System#loadLibrary"></a>1.1 System#loadLibrary</h3><p>[&gt; java/lang/System.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libname)</span> </span>&#123;</span><br><span class="line">    Runtime.getRuntime().loadLibrary0(VMStack.getCallingClassLoader(), libname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-Runtime-loadLibrary0"><a href="#1-2-Runtime-loadLibrary0" class="headerlink" title="1.2 Runtime#loadLibrary0"></a>1.2 Runtime#loadLibrary0</h3><p>[&gt;java/lang/Runtime.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">loadLibrary0</span><span class="params">(ClassLoader loader, Class&lt;?&gt; callerClass, String libname)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    String libraryName = libname;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="keyword">null</span> &amp;&amp; !(loader <span class="keyword">instanceof</span> BootClassLoader)) &#123;</span><br><span class="line">         <span class="comment">//① ClassLoader#findLibrary 查找 so 的文件名称，见 1.4节</span></span><br><span class="line">        String filename = loader.findLibrary(libraryName);</span><br><span class="line">            <span class="keyword">if</span> (filename == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (loader.getClass() == PathClassLoader.class ||</span><br><span class="line">                     loader.getClass() == DelegateLastClassLoader.class)) &#123;</span><br><span class="line">            <span class="comment">// ② 如果通过 ClassLoader 找不到，则会通过 System 默认路径去找</span></span><br><span class="line">                filename = System.mapLibraryName(libraryName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (filename == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(loader + <span class="string">" couldn't find \""</span> +</span><br><span class="line">                                               System.mapLibraryName(libraryName) + <span class="string">"\""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ③ Native 加载</span></span><br><span class="line">            String error = nativeLoad(filename, loader);</span><br><span class="line">            <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(error);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ClassLoader 为空的时候</span></span><br><span class="line">    getLibPaths();</span><br><span class="line">    String filename = System.mapLibraryName(libraryName);</span><br><span class="line">    String error = nativeLoad(filename, loader, callerClass);</span><br><span class="line">    <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">// 最终通过 Native 来加载</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">nativeLoad</span><span class="params">(String filename, ClassLoader loader, Class&lt;?&gt; caller)</span></span></span><br></pre></td></tr></table></figure><ul><li>当 loader 不为空是，通过 ClassLoader#findLibrary() 查看 so  是否存在</li><li>当 loader 为空是，则从默认目录 mLibPaths 中查找</li></ul><h3 id="1-3-Runtime-getLibPaths"><a href="#1-3-Runtime-getLibPaths" class="headerlink" title="1.3 Runtime#getLibPaths"></a>1.3 Runtime#getLibPaths</h3><p>[&gt;java/lang/Runtime.java]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 获取 Lib 默认路径</span><br><span class="line">private String[] getLibPaths() &#123;</span><br><span class="line">    if (mLibPaths == null) &#123;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            if (mLibPaths == null) &#123;</span><br><span class="line">                mLibPaths = initLibPaths();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return mLibPaths;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">private static String[] initLibPaths() &#123;</span><br><span class="line">    String javaLibraryPath = System.getProperty(&quot;java.library.path&quot;);</span><br><span class="line">    if (javaLibraryPath == null) &#123;</span><br><span class="line">        return EmptyArray.STRING;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] paths = javaLibraryPath.split(&quot;:&quot;);</span><br><span class="line">    for (int i = 0; i &lt; paths.length; ++i) &#123;</span><br><span class="line">        if (!paths[i].endsWith(&quot;/&quot;)) &#123;</span><br><span class="line">            paths[i] += &quot;/&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return paths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initLibPaths</code> 路径是默认的 lib 路径 返回的路径是</p><blockquote><p> /system/lib/<br>/vendor/lib/<br>/product/lib/</p></blockquote><h3 id="1-4-BaseDexClassLoader-findLibrary"><a href="#1-4-BaseDexClassLoader-findLibrary" class="headerlink" title="1.4 BaseDexClassLoader.findLibrary"></a>1.4 BaseDexClassLoader.findLibrary</h3><p>通过 ClassLoader 查找 so</p><p>[&gt; libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pathList.findLibrary(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pathList 是 DexPathList</p><h3 id="1-5-DexPathList-findLibrary"><a href="#1-5-DexPathList-findLibrary" class="headerlink" title="1.5 DexPathList#findLibrary"></a>1.5 DexPathList#findLibrary</h3><p>[&gt;libcore/dalvik/src/main/java/dalvik/system/DexPathList.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String libraryName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过 so 的名称拼接成文件路径</span></span><br><span class="line">    String fileName = System.mapLibraryName(libraryName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (NativeLibraryElement element : nativeLibraryPathElements) &#123;</span><br><span class="line">        String path = element.findNativeLibrary(fileName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (path != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> path;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如<br><code>System.mapLibraryName(native-lib)</code> 返回的是 <code>libnative-lib.so</code></p><p><code>nativeLibraryPathElements</code> 是 native library 路径的集合， 它的是 <code>DexPathList</code> 初始化的时候赋值，详见 1.7节</p><h3 id="1-6-DexPathList-NativeLibraryElement-findNativeLibrary"><a href="#1-6-DexPathList-NativeLibraryElement-findNativeLibrary" class="headerlink" title="1.6 DexPathList$NativeLibraryElement#findNativeLibrary"></a>1.6 DexPathList$NativeLibraryElement#findNativeLibrary</h3><p>[&gt;libcore/dalvik/src/main/java/dalvik/system/DexPathList.java]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public String findNativeLibrary(String name) &#123;</span><br><span class="line">    maybeInit();</span><br><span class="line"></span><br><span class="line">    if (zipDir == null) &#123;</span><br><span class="line">        String entryPath = new File(path, name).getPath();</span><br><span class="line">        // 能打开并且只读的 so</span><br><span class="line">        if (IoUtils.canOpenReadOnly(entryPath)) &#123;</span><br><span class="line">            return entryPath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (urlHandler != null) &#123;</span><br><span class="line">        String entryName = zipDir + &apos;/&apos; + name;</span><br><span class="line">        if (urlHandler.isEntryStored(entryName)) &#123;</span><br><span class="line">          return path.getPath() + zipSeparator + entryName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-DexPathList-DexPathList"><a href="#1-7-DexPathList-DexPathList" class="headerlink" title="1.7 DexPathList#DexPathList"></a>1.7 DexPathList#DexPathList</h3><p>[&gt;libcore/dalvik/src/main/java/dalvik/system/DexPathList.java]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DexPathList(ClassLoader definingContext, String dexPath,</span><br><span class="line">    String librarySearchPath, File optimizedDirectory, boolean isTrusted) &#123;</span><br><span class="line">  </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    this.definingContext = definingContext;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;();</span><br><span class="line">    // save dexPath for BaseDexClassLoader</span><br><span class="line">   //  dex 的路径</span><br><span class="line">    this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,</span><br><span class="line">                                           suppressedExceptions, definingContext, isTrusted);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    // Native 库的路径</span><br><span class="line">    this.nativeLibraryDirectories = splitPaths(librarySearchPath, false);</span><br><span class="line">    //  系统 Native 库的路径</span><br><span class="line">    this.systemNativeLibraryDirectories =</span><br><span class="line">            splitPaths(System.getProperty(&quot;java.library.path&quot;), true);</span><br><span class="line">    // 所有的 Natvie</span><br><span class="line">    this.nativeLibraryPathElements = makePathElements(getAllNativeLibraryDirectories());</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>DexPathList</code> 的构造函数中，我们可以知道 <code>nativeLibraryPathElements</code> 是所有 Native Library 的集合。</p><p><code>DexPathList</code> 是在 ActivityThread 中创建，ActivityThread 是在 App 启动时候创建的。关于 App 启动的启动流程，可以去找这方面的资料，自行查看。</p><p>总结一些 Native Library 的路径来源：</p><ul><li><p>一个是 Native 库的原始路径 <code>System.getProperty(&quot;java.library.path****&quot;)</code>,<br>  /system/lib/; /vendor/lib/; /product/lib/</p></li><li><p>另外一个是App启动时的 Lib 库路径</p></li></ul><p><img src="/2020/03/28/android-so-load/android_so_1.png" width="80%" height="30%"></p><h3 id="1-8-Runtime-doLoad"><a href="#1-8-Runtime-doLoad" class="headerlink" title="1.8 Runtime#doLoad"></a>1.8 Runtime#doLoad</h3><p>在上面我们解决 Native Library 的路径问题，下面分析一下加载的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">doLoad</span><span class="params">(String name, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    String librarySearchPath = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="keyword">null</span> &amp;&amp; loader <span class="keyword">instanceof</span> BaseDexClassLoader) &#123;</span><br><span class="line">        BaseDexClassLoader dexClassLoader = (BaseDexClassLoader) loader;</span><br><span class="line">        librarySearchPath = dexClassLoader.getLdLibraryPath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用 native 方法加载 so, librarySearchPath 就是前面分析的路径的路径</span></span><br><span class="line">        <span class="keyword">return</span> nativeLoad(name, loader, librarySearchPath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">nativeLoad</span><span class="params">(String filename, ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            String librarySearchPath)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="1-9-Runtime-c-Runtime-nativeLoad"><a href="#1-9-Runtime-c-Runtime-nativeLoad" class="headerlink" title="1.9 Runtime.c#Runtime_nativeLoad"></a>1.9 Runtime.c#Runtime_nativeLoad</h3><p>[&gt; libcore/ojluni/src/main/native/Runtime.c]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line">Runtime_nativeLoad(JNIEnv* env, jclass ignored, jstring javaFilename,</span><br><span class="line">                   jobject javaLoader, jclass caller)</span><br><span class="line">&#123;</span><br><span class="line">    return JVM_NativeLoad(env, javaFilename, javaLoader, caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Runtime.c 中 <code>Runtime_nativeLoad</code> 方法会调用 <code>JVM_NativeLoad</code></p><h3 id="1-10-OpenjdkJvm-cc-JVM-NativeLoad"><a href="#1-10-OpenjdkJvm-cc-JVM-NativeLoad" class="headerlink" title="1.10 OpenjdkJvm.cc#JVM_NativeLoad"></a>1.10 OpenjdkJvm.cc#JVM_NativeLoad</h3><p>[&gt;art/openjdkjvm/OpenjdkJvm.cc]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jstring JVM_NativeLoad(JNIEnv* env,</span><br><span class="line">                                 jstring javaFilename,</span><br><span class="line">                                 jobject javaLoader,</span><br><span class="line">                                 jclass caller) &#123;</span><br><span class="line">  ScopedUtfChars filename(env, javaFilename);</span><br><span class="line">  if (filename.c_str() == nullptr) &#123;</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::string error_msg;</span><br><span class="line">  &#123;</span><br><span class="line">    // 获取 java 虚拟机</span><br><span class="line">    art::JavaVMExt* vm = art::Runtime::Current()-&gt;GetJavaVM();</span><br><span class="line">    // 加载 调用java 虚拟机中 NativieLibrary 方法去加载 so</span><br><span class="line">    bool success = vm-&gt;LoadNativeLibrary(env,</span><br><span class="line">                                         filename.c_str(),</span><br><span class="line">                                         javaLoader,</span><br><span class="line">                                         caller,</span><br><span class="line">                                         &amp;error_msg);</span><br><span class="line">    if (success) &#123;</span><br><span class="line">      return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h3 id="1-11-java-vm-ext-cc-JVM-NativeLoad"><a href="#1-11-java-vm-ext-cc-JVM-NativeLoad" class="headerlink" title="1.11 java_vm_ext.cc#JVM_NativeLoad"></a>1.11 java_vm_ext.cc#JVM_NativeLoad</h3><p>[&gt;art/runtime/java_vm_ext.cc]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">bool JavaVMExt::LoadNativeLibrary(JNIEnv* env,</span><br><span class="line">                                  const std::string&amp; path,</span><br><span class="line">                                  jobject class_loader,</span><br><span class="line">                                  std::string* error_msg) &#123;</span><br><span class="line">  error_msg-&gt;clear();</span><br><span class="line"></span><br><span class="line">  SharedLibrary* library;</span><br><span class="line">  Thread* self = Thread::Current();</span><br><span class="line">  // ① 先判断 so 是否已经被加载过</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLock mu(self, *Locks::jni_libraries_lock_);</span><br><span class="line">    library = libraries_-&gt;Get(path);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    VLOG(jni) &lt;&lt; &quot;[Shared library \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; already loaded in &quot;</span><br><span class="line">              &lt;&lt; &quot; ClassLoader &quot; &lt;&lt; class_loader &lt;&lt; &quot;]&quot;;</span><br><span class="line">    if (!library-&gt;CheckOnLoadResult()) &#123;</span><br><span class="line">      StringAppendF(error_msg, &quot;JNI_OnLoad failed on a previous attempt &quot;</span><br><span class="line">          &quot;to load \&quot;%s\&quot;&quot;, path.c_str());</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // ② 打开 so </span><br><span class="line">  ScopedLocalRef&lt;jstring&gt; library_path(env, GetLibrarySearchPath(env, class_loader));</span><br><span class="line">  Locks::mutator_lock_-&gt;AssertNotHeld(self);</span><br><span class="line">  const char* path_str = path.empty() ? nullptr : path.c_str();</span><br><span class="line">  bool needs_native_bridge = false;</span><br><span class="line">  void* handle = android::OpenNativeLibrary(env,</span><br><span class="line">                                            runtime_-&gt;GetTargetSdkVersion(),</span><br><span class="line">                                            path_str,</span><br><span class="line">                                            class_loader,</span><br><span class="line">                                            library_path.get(),</span><br><span class="line">                                            &amp;needs_native_bridge,</span><br><span class="line">                                            error_msg);</span><br><span class="line"></span><br><span class="line">  VLOG(jni) &lt;&lt; &quot;[Call to dlopen(\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;, RTLD_NOW) returned &quot; &lt;&lt; handle &lt;&lt; &quot;]&quot;;</span><br><span class="line"></span><br><span class="line">  // 打开失败返回</span><br><span class="line">  if (handle == nullptr) &#123;</span><br><span class="line">    VLOG(jni) &lt;&lt; &quot;dlopen(\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;, RTLD_NOW) failed: &quot; &lt;&lt; *error_msg;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 检测异常</span><br><span class="line">  if (env-&gt;ExceptionCheck() == JNI_TRUE) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; &quot;Unexpected exception:&quot;;</span><br><span class="line">    env-&gt;ExceptionDescribe();</span><br><span class="line">    env-&gt;ExceptionClear();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // ③ 创建一个新的 SharedLibrary 结构体放到 libraries 中</span><br><span class="line">  bool created_library = false;</span><br><span class="line">  &#123;</span><br><span class="line">    // Create SharedLibrary ahead of taking the libraries lock to maintain lock ordering.</span><br><span class="line">    std::unique_ptr&lt;SharedLibrary&gt; new_library(</span><br><span class="line">        new SharedLibrary(env,</span><br><span class="line">                          self,</span><br><span class="line">                          path,</span><br><span class="line">                          handle,</span><br><span class="line">                          needs_native_bridge,</span><br><span class="line">                          class_loader,</span><br><span class="line">                          class_loader_allocator));</span><br><span class="line"></span><br><span class="line">    MutexLock mu(self, *Locks::jni_libraries_lock_);</span><br><span class="line">    library = libraries_-&gt;Get(path);</span><br><span class="line">    if (library == nullptr) &#123;  // We won race to get libraries_lock.</span><br><span class="line">      library = new_library.release();</span><br><span class="line">      libraries_-&gt;Put(path, library);</span><br><span class="line">      created_library = true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!created_library) &#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;WOW: we lost a race to add shared library: &quot;</span><br><span class="line">        &lt;&lt; &quot;\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; ClassLoader=&quot; &lt;&lt; class_loader;</span><br><span class="line">    return library-&gt;CheckOnLoadResult();</span><br><span class="line">  &#125;</span><br><span class="line">  VLOG(jni) &lt;&lt; &quot;[Added shared library \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; for ClassLoader &quot; &lt;&lt; class_loader &lt;&lt; &quot;]&quot;;</span><br><span class="line"></span><br><span class="line">  // ④ 查找 ”JNI_OnLoad“ 符号</span><br><span class="line">  bool was_successful = false;</span><br><span class="line">  void* sym = library-&gt;FindSymbol(&quot;JNI_OnLoad&quot;, nullptr);</span><br><span class="line">  // 没有查找到， 标记为加载成功</span><br><span class="line">  if (sym == nullptr) &#123;</span><br><span class="line">    VLOG(jni) &lt;&lt; &quot;[No JNI_OnLoad found in \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;]&quot;;</span><br><span class="line">    was_successful = true;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 如果我们在 JNI 中已经复写了 JNI_OnLoad 方法，则需要重写 ClassLoader</span><br><span class="line">    ScopedLocalRef&lt;jobject&gt; old_class_loader(env, env-&gt;NewLocalRef(self-&gt;GetClassLoaderOverride()));</span><br><span class="line">    self-&gt;SetClassLoaderOverride(class_loader);</span><br><span class="line"></span><br><span class="line">    VLOG(jni) &lt;&lt; &quot;[Calling JNI_OnLoad in \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;]&quot;;</span><br><span class="line">    typedef int (*JNI_OnLoadFn)(JavaVM*, void*);</span><br><span class="line">    JNI_OnLoadFn jni_on_load = reinterpret_cast&lt;JNI_OnLoadFn&gt;(sym);</span><br><span class="line">    int version = (*jni_on_load)(this, nullptr);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    self-&gt;SetClassLoaderOverride(old_class_loader.get());</span><br><span class="line"></span><br><span class="line">    // 判断 JNI 版本</span><br><span class="line">    if (version == JNI_ERR) &#123;</span><br><span class="line">      StringAppendF(error_msg, &quot;JNI_ERR returned from JNI_OnLoad in \&quot;%s\&quot;&quot;, path.c_str());</span><br><span class="line">    &#125; else if (JavaVMExt::IsBadJniVersion(version)) &#123;</span><br><span class="line">      StringAppendF(error_msg, &quot;Bad JNI version returned from JNI_OnLoad in \&quot;%s\&quot;: %d&quot;,</span><br><span class="line">                    path.c_str(), version);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      was_successful = true;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 返回加载结果</span><br><span class="line">  library-&gt;SetResult(was_successful);</span><br><span class="line">  return was_successful;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的内容比较多，需要一步步分析</p><ul><li>第一步是判断 so 是否已经被加载过，如果已经加载过了，则直接返回加载成功</li><li>第二步是打开 so, 返回 <code>handle</code>句柄，如果返回的句柄为空，这份表示加载失败</li><li>第三步是创建一个 <code>SharedLibrary</code> 结构体，放到 <code>libraries</code> 中缓存</li><li>第四步是查找 <code>JNI_OnLoad</code> 符号，这里分两种情况<ul><li>如果在 JNI 中没有写 <code>JNI_OnLoad</code> 方法，找不到符号，返回加成功</li><li>另一种情况是，如果 JNI 中有 <code>JNI_OnLoad</code> 方法，则会重写当前的 ClassLoader, 并且判断 JNI 版本</li></ul></li></ul><p>从上面的第四步，<strong>我们可以知道加载 so 中 JNI 的入口是 <code>JNI_OnLoad</code> 方法，所以在写 JNI 的时候，会在 <code>JNI_OnLoad</code>方法中做一些初始化的工作。另外一个就是，如果写了 <code>JNI_OnLoad</code> 方法，就要指定 JNI 版本。</strong></p><p>判断 JNI 的版本</p><p>[&gt;art/runtime/java_vm_ext.cc]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool JavaVMExt::IsBadJniVersion(int version) &#123;</span><br><span class="line">  // We don&apos;t support JNI_VERSION_1_1. These are the only other valid versions.</span><br><span class="line">  return version != JNI_VERSION_1_2 &amp;&amp; version != JNI_VERSION_1_4 &amp;&amp; version != JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是判断 JNI 版本，可以看到只能是 <code>JNI_VERSION_1_2,JNI_VERSION_1_4,JNI_VERSION_1_6</code> 三个版本</p><p>下来是我们平时在写 JNI 的时候, <code>JNI_OnLoad</code> 方法中需要给定 jni 的版本， 同时做一些初始化的工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int JNI_OnLoad(JavaVM *vm, void *reserved) &#123;</span><br><span class="line">    JNIEnv *env;</span><br><span class="line">    jVM = vm;</span><br><span class="line"></span><br><span class="line">    // 设定 jni 版本为 1_4</span><br><span class="line">    if ((*vm)-&gt;GetEnv(vm, (void **) &amp;env, JNI_VERSION_1_4) != JNI_OK) &#123; </span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 初始化的工作</span><br><span class="line">     android_dumpVideo = (*env)-&gt;GetStaticMethodID(env, cEmulator, &quot;bitblt&quot;,</span><br><span class="line">                                                  &quot;(Ljava/nio/ByteBuffer;)V&quot;);</span><br><span class="line"></span><br><span class="line">    if (android_dumpVideo == NULL) &#123;</span><br><span class="line">        __android_log_print(ANDROID_LOG_ERROR, &quot;mame4droid-jni&quot;, &quot;Failed to find method bitblt&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    android_changeVideo = (*env)-&gt;GetStaticMethodID(env, cEmulator, &quot;changeVideo&quot;, &quot;(IIII)V&quot;);</span><br><span class="line"></span><br><span class="line">    if (android_changeVideo == NULL) &#123;</span><br><span class="line">        __android_log_print(ANDROID_LOG_ERROR, &quot;mame4droid-jni&quot;,</span><br><span class="line">                            &quot;Failed to find method changeVideo&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-So-的加载原理"><a href="#2-So-的加载原理" class="headerlink" title="2. So 的加载原理"></a>2. So 的加载原理</h2><p>在前面的部分，我们梳理了 so 加载的整个流程，但这个过程还有一些以为，包括：</p><ul><li>ClassLoader 从哪里来</li><li>Native 库是怎样来的</li><li>so 是怎样到 Native 库里面的</li></ul><p>下面将一个个来查找这些疑问的答案</p><h3 id="2-1-ClassLoader-是怎样来的"><a href="#2-1-ClassLoader-是怎样来的" class="headerlink" title="2.1 ClassLoader 是怎样来的"></a>2.1 ClassLoader 是怎样来的</h3><h3 id="2-1-1-System-loadLibrary"><a href="#2-1-1-System-loadLibrary" class="headerlink" title="2.1.1 System#loadLibrary"></a>2.1.1 System#loadLibrary</h3><p>[&gt; java/lang/System.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libname)</span> </span>&#123;</span><br><span class="line">      Runtime.getRuntime().loadLibrary0(VMStack.getCallingClassLoader(), libname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载的 ClassLoader 从 VMStack 中获取， VMStack 再去从 Native 中获取</p><p>[&gt;/libcore/libart/src/main/java/dalvik/system/VMStack.java]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@FastNative</span><br><span class="line">native public static ClassLoader getCallingClassLoader();</span><br></pre></td></tr></table></figure><h3 id="2-1-2-ActivityThread-handleBindApplication"><a href="#2-1-2-ActivityThread-handleBindApplication" class="headerlink" title="2.1.2 ActivityThread#handleBindApplication"></a>2.1.2 ActivityThread#handleBindApplication</h3><p>[&gt;/frameworks/base/core/java/android/app/ActivityThread.java]</p><p>在 ActivityThread 是 Android App 启动的入口，关于 App 的启动可参考其他资料。<br>App 启动过程，会调到 ActivityThread#handleBindApplication 方法。<br>在这个方法中，会创建 <code>LoadedApk</code>  并且传入进去 Context 中的 ClassLoader.<br>Context 的实现是 ContextImpl，Context#getClassLoader() 方法，去看 ContextImpl#getClassLoader()， 详见 2.1.3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 LoadedApk，使用是 Context 的 ClassLoader</span></span><br><span class="line">    LoadedApk pi = getPackageInfo(instrApp, data.compatInfo, appContext.getClassLoader(), <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 将 ActivityThread 和 LoadedApk 作为创建 ContextImpl 的参数</span></span><br><span class="line">    ContextImpl instrContext = ContextImpl.createAppContext(<span class="keyword">this</span>, pi);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = instrContext.getClassLoader();</span><br><span class="line">        mInstrumentation = (Instrumentation) cl.loadClass(data.instrumentationName.getClassName())</span><br><span class="line">                .newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to instantiate instrumentation "</span> + data.instrumentationName + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-3-ContextImpl-getClassLoader"><a href="#2-1-3-ContextImpl-getClassLoader" class="headerlink" title="2.1.3 ContextImpl#getClassLoader"></a>2.1.3 ContextImpl#getClassLoader</h3><p>[&gt;/frameworks/base/core/java/android/app/ContextImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mClassLoader != <span class="keyword">null</span> ? mClassLoader : (mPackageInfo != <span class="keyword">null</span> ? mPackageInfo.getClassLoader() : ClassLoader.getSystemClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑有点绕，将代码整理改成下面，会更加容易看懂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mClassLoader != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> mClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> mPackageInfo.getClassLoader();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过整理的代码逻辑就很清晰了，第一次进来的时候 mClassLoader 是空的，只要看后面的逻辑。<br>mPackageInfo是 LoadApk, mPackageInfo 不会为空，在 2.1.2 节知道它是 ContextImpl 创建的时候传进来的mP。所以，ackageInfo.getClassLoader()  是调用了  LoadApk#getClassLoader() 方法，关于这个方法详见 2.1.4</p><h3 id="2-1-4-LoadApk-getClassLoader"><a href="#2-1-4-LoadApk-getClassLoader" class="headerlink" title="2.1.4 LoadApk#getClassLoader"></a>2.1.4 LoadApk#getClassLoader</h3><p>[&gt;/frameworks/base/core/java/android/app/LoadApk.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mClassLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            createOrUpdateClassLoaderLocked(<span class="keyword">null</span> <span class="comment">/*addedPaths*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createOrUpdateClassLoaderLocked</span><span class="params">(List&lt;String&gt; addedPaths)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    ···</span></span><br><span class="line"><span class="function">    <span class="comment">// 创建 LoadApk 的时候，传进 mIncludeCode 的值是 false</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(!mIncludeCode)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mClassLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();</span><br><span class="line">                mClassLoader = ApplicationLoaders.getDefault().getClassLoader(</span><br><span class="line">                        <span class="string">""</span> <span class="comment">/* codePath */</span>, mApplicationInfo.targetSdkVersion, isBundledApp,</span><br><span class="line">                        librarySearchPath, libraryPermittedPath, mBaseClassLoader,</span><br><span class="line">                        <span class="keyword">null</span> <span class="comment">/* classLoaderName */</span>);</span><br><span class="line">                StrictMode.setThreadPolicy(oldPolicy);</span><br><span class="line">                mAppComponentFactory = AppComponentFactory.DEFAULT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 调用  ApplicationLoaders.getDefault() 创建 ClassLoader, </span></span><br><span class="line">     <span class="keyword">if</span> (mClassLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ..</span><br><span class="line">        mClassLoader = ApplicationLoaders.getDefault().getClassLoader(zip,</span><br><span class="line">                mApplicationInfo.targetSdkVersion, isBundledApp, librarySearchPath,</span><br><span class="line">                libraryPermittedPath, mBaseClassLoader,</span><br><span class="line">                mApplicationInfo.classLoaderName);</span><br><span class="line">        mAppComponentFactory = createAppFactory(mApplicationInfo, mClassLoader);</span><br><span class="line">    </span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-5-ApplicationLoaders-getClassLoader"><a href="#2-1-5-ApplicationLoaders-getClassLoader" class="headerlink" title="2.1.5 ApplicationLoaders#getClassLoader"></a>2.1.5 ApplicationLoaders#getClassLoader</h3><p>[&gt;/frameworks/base/core/java/android/app/ApplicationLoaders.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">(String zip, <span class="keyword">int</span> targetSdkVersion, <span class="keyword">boolean</span> isBundled,</span></span></span><br><span class="line"><span class="function"><span class="params">                           String librarySearchPath, String libraryPermittedPath,</span></span></span><br><span class="line"><span class="function"><span class="params">                           ClassLoader parent, String classLoaderName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// For normal usage the cache key used is the same as the zip path.</span></span><br><span class="line">    <span class="keyword">return</span> getClassLoader(zip, targetSdkVersion, isBundled, librarySearchPath,</span><br><span class="line">                          libraryPermittedPath, parent, zip, classLoaderName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> ClassLoader <span class="title">getClassLoader</span><span class="params">(String zip, <span class="keyword">int</span> targetSdkVersion, <span class="keyword">boolean</span> isBundled,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       String librarySearchPath, String libraryPermittedPath,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       ClassLoader parent, String cacheKey,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       String classLoaderName)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">synchronized</span> (mLoaders) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                parent = baseParent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 试图从缓存总去取 ClassLoader</span></span><br><span class="line">            <span class="keyword">if</span> (parent == baseParent) &#123;</span><br><span class="line">                ClassLoader loader = mLoaders.get(cacheKey);</span><br><span class="line">                <span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> loader;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建 ClassLoader</span></span><br><span class="line">            ClassLoader classloader = ClassLoaderFactory.createClassLoader(</span><br><span class="line">                    zip,  librarySearchPath, libraryPermittedPath, parent,</span><br><span class="line">                    targetSdkVersion, isBundled, classLoaderName);</span><br><span class="line">                mLoaders.put(cacheKey, classloader);</span><br><span class="line">                <span class="keyword">return</span> classloader;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-6-ClassLoaderFactory-createClassLoader"><a href="#2-1-6-ClassLoaderFactory-createClassLoader" class="headerlink" title="2.1.6 ClassLoaderFactory#createClassLoader"></a>2.1.6 ClassLoaderFactory#createClassLoader</h3><p>[&gt;/frameworks/base/core/java/com/android/internal/os/ClassLoaderFactory.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">createClassLoader</span><span class="params">(String dexPath,</span></span></span><br><span class="line"><span class="function"><span class="params">    String librarySearchPath, ClassLoader parent, String classloaderName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isPathClassLoaderName(classloaderName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PathClassLoader(dexPath, librarySearchPath, parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDelegateLastClassLoaderName(classloaderName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegateLastClassLoader(dexPath, librarySearchPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Invalid classLoaderName: "</span> + classloaderName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面这么多步，终于看到了创建创建 ClassLoader 的地方.<br>根据参数的 classloaderName 的不同，会创建  PathClassLoader 或者 DelegateLastClassLoader。 </p><p>classloaderName 参数是 app 启动的时候传下来的，见 2.1.4 节</p><p>总的来说，<strong>ClassLoader 是 app 启动的时候， ActivityThread 中经过一步步的调用，最后在 ApplicationLoaders 中用 ClassLoaderFactory 创建。</strong></p><p>ClassLoader 的分类</p><p><img src="/2020/03/28/android-so-load/android_so_2.png" width="80%" height="30%"></p><p>关于不同的 ClassLoader 有不同的作用，可以去查相关的资料</p><p>到此，我们的第一个问题解决了，ClassLoader 是 app 启动的时候在 ActivityThread 中创建。 </p><h2 id="2-2-Native-库是怎样来的"><a href="#2-2-Native-库是怎样来的" class="headerlink" title="2.2 Native 库是怎样来的"></a>2.2 Native 库是怎样来的</h2><p>通过对 DexPathList 的分析，可以知道 Native Library 来自来自两个地方</p><ul><li><p>一个是 DexPathList 创建的时候，构造函数传进来的 librarySearchPath。</p></li><li><p>另外一个是 addNativePath(Collection<string> libPaths)<br>例如 :</string></p><blockquote><p>/data/app/com.test.baidu/base.apk!/lib/armeabi-v7a</p></blockquote></li></ul><h3 id="2-2-1-DexPathList-findLibrary"><a href="#2-2-1-DexPathList-findLibrary" class="headerlink" title="2.2.1 DexPathList#findLibrary"></a>2.2.1 DexPathList#findLibrary</h3><p>在第一章的时候，加载 so 会调用到 DexPathList#findLibrary 方法，在这个方法里面会遍历 nativeLibraryPathElements。 nativeLibraryPathElements 是 NativeLibrary 路径的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String libraryName)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    String fileName = System.mapLibraryName(libraryName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (NativeLibraryElement element : nativeLibraryPathElements) &#123;</span><br><span class="line">        String path = element.findNativeLibrary(fileName);</span><br><span class="line">        <span class="keyword">if</span> (path != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> path;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>System.mapLibraryName 的实现是在 System.c 里面，返回 so 的文件名，例如 </p><blockquote><p>libraryName 是 test_baidu,<br>System.mapLibraryName(‘test_baidu’) 返回的是  libtest_baidu.so</p></blockquote><p>下面要看看 <code>nativeLibraryPathElements</code>是怎么来的<br>NativeLibraryElement 类是 Native Library 的路径元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> static class NativeLibraryElement &#123;</span><br><span class="line">        </span><br><span class="line">    private final File path;</span><br><span class="line">    private final String zipDir;</span><br><span class="line"></span><br><span class="line">    public NativeLibraryElement(File dir) &#123;</span><br><span class="line">        this.path = dir;</span><br><span class="line">        this.zipDir = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NativeLibraryElement(File zip, String zipDir) &#123;</span><br><span class="line">        this.path = zip;</span><br><span class="line">        this.zipDir = zipDir;</span><br><span class="line"></span><br><span class="line">        if (zipDir == null) &#123;</span><br><span class="line">          throw new IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-1-DexPathList-DexPathList-构造函数"><a href="#2-2-1-DexPathList-DexPathList-构造函数" class="headerlink" title="2.2.1 DexPathList#DexPathList 构造函数"></a>2.2.1 DexPathList#DexPathList 构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DexPathList(ClassLoader definingContext, String dexPath,</span><br><span class="line">            String librarySearchPath, File optimizedDirectory, boolean isTrusted) &#123;</span><br><span class="line">            </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,</span><br><span class="line">                                           suppressedExceptions, definingContext, isTrusted);</span><br><span class="line"></span><br><span class="line">    //  ① 创建是传入进来的 librarySearchPath</span><br><span class="line">    this.nativeLibraryDirectories = splitPaths(librarySearchPath, false);</span><br><span class="line">        </span><br><span class="line">   //  ② 系统的 &quot;java.library.path&quot; 路径  </span><br><span class="line">    this.systemNativeLibraryDirectories = splitPaths(System.getProperty(&quot;java.library.path&quot;), true);</span><br><span class="line">    List&lt;File&gt; allNativeLibraryDirectories = new ArrayList&lt;&gt;(nativeLibraryDirectories);</span><br><span class="line">    allNativeLibraryDirectories.addAll(systemNativeLibraryDirectories);</span><br><span class="line">    this.nativeLibraryPathElements = makePathElements(allNativeLibraryDirectories);</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 DexPathList 的构造函数中，我们可以看到 Native library 存在两个方面</p><ul><li>一个是传入进来的 librarySearchPath</li><li>另外一个是通过虚拟机属性 <code>java.library.path</code> 获取的系统 Native 库</li></ul><h3 id="2-2-2-DexPathList-addNativePath"><a href="#2-2-2-DexPathList-addNativePath" class="headerlink" title="2.2.2 DexPathList#addNativePath"></a>2.2.2 DexPathList#addNativePath</h3><p>外部添加的 libPaths 路径<br>例如 </p><blockquote><p>/data/app/com.test.baidu/base.apk!/lib/armeabi-v7a</p></blockquote><p>DexPathList#addNativePath 是在 ApplicationLoaders#addNative 中调用，见 2.2.3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void addNativePath(Collection&lt;String&gt; libPaths) &#123;</span><br><span class="line">    if (libPaths.isEmpty()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;File&gt; libFiles = new ArrayList&lt;&gt;(libPaths.size());</span><br><span class="line">    for (String path : libPaths) &#123;</span><br><span class="line">        libFiles.add(new File(path));</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;NativeLibraryElement&gt; newPaths =</span><br><span class="line">            new ArrayList&lt;&gt;(nativeLibraryPathElements.length + libPaths.size());</span><br><span class="line">    newPaths.addAll(Arrays.asList(nativeLibraryPathElements));</span><br><span class="line">    for (NativeLibraryElement element : makePathElements(libFiles)) &#123;</span><br><span class="line">        if (!newPaths.contains(element)) &#123;</span><br><span class="line">            newPaths.add(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nativeLibraryPathElements = newPaths.toArray(new NativeLibraryElement[newPaths.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-ApplicationLoaders-addNative"><a href="#2-2-3-ApplicationLoaders-addNative" class="headerlink" title="2.2.3 ApplicationLoaders#addNative"></a>2.2.3 ApplicationLoaders#addNative</h3><p>[&gt;/frameworks/base/core/java/android/app/ApplicationLoaders.java]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void addNative(ClassLoader classLoader, Collection&lt;String&gt; libPaths) &#123;</span><br><span class="line">        if (!(classLoader instanceof PathClassLoader)) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;class loader is not a PathClassLoader&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        final PathClassLoader baseDexClassLoader = (PathClassLoader) classLoader;</span><br><span class="line">        baseDexClassLoader.addNativePath(libPaths);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-4-LoadedApk-createOrUpdateClassLoaderLocked"><a href="#2-2-4-LoadedApk-createOrUpdateClassLoaderLocked" class="headerlink" title="2.2.4 LoadedApk#createOrUpdateClassLoaderLocked"></a>2.2.4 LoadedApk#createOrUpdateClassLoaderLocked</h3><p>[&gt; /frameworks/base/core/java/android/app/LoadedApk.java]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">private void createOrUpdateClassLoaderLocked(List&lt;String&gt; addedPaths) &#123;</span><br><span class="line">        </span><br><span class="line">    ...</span><br><span class="line">       </span><br><span class="line">    // ① 默认 library 的路径</span><br><span class="line">   final String defaultSearchPaths = System.getProperty(&quot;java.library.path&quot;);</span><br><span class="line">    final boolean treatVendorApkAsUnbundled = !defaultSearchPaths.contains(&quot;/vendor/lib&quot;);</span><br><span class="line">    if (mApplicationInfo.getCodePath() != null</span><br><span class="line">            &amp;&amp; mApplicationInfo.isVendor() &amp;&amp; treatVendorApkAsUnbundled) &#123;</span><br><span class="line">        isBundledApp = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ②</span><br><span class="line">    makePaths(mActivityThread, isBundledApp, mApplicationInfo, zipPaths, libPaths);</span><br><span class="line">    String libraryPermittedPath = mDataDir;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">  // ③ 创建 ClassLoader</span><br><span class="line">   if (mClassLoader == null) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mClassLoader = ApplicationLoaders.getDefault().getClassLoader(zip,</span><br><span class="line">                mApplicationInfo.targetSdkVersion, isBundledApp, librarySearchPath,</span><br><span class="line">                libraryPermittedPath, mBaseClassLoader,</span><br><span class="line">                mApplicationInfo.classLoaderName);</span><br><span class="line">        mAppComponentFactory = createAppFactory(mApplicationInfo, mClassLoader);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!libPaths.isEmpty() &amp;&amp; SystemProperties.getBoolean(PROPERTY_NAME_APPEND_NATIVE, true)) &#123;</span><br><span class="line">        ...</span><br><span class="line">        try &#123;</span><br><span class="line">            // ④ 添加 libPaths 路径</span><br><span class="line">        ApplicationLoaders.getDefault().addNative(mClassLoader, libPaths);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            StrictMode.setThreadPolicy(oldPolicy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    // ⑤ 其他的 lib 路径 到 defaultSearchPaths</span><br><span class="line">  List&lt;String&gt; extraLibPaths = new ArrayList&lt;&gt;(3);</span><br><span class="line">    String abiSuffix = VMRuntime.getRuntime().is64Bit() ? &quot;64&quot; : &quot;&quot;;</span><br><span class="line">    if (!defaultSearchPaths.contains(&quot;/vendor/lib&quot;)) &#123;</span><br><span class="line">        extraLibPaths.add(&quot;/vendor/lib&quot; + abiSuffix);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!defaultSearchPaths.contains(&quot;/odm/lib&quot;)) &#123;</span><br><span class="line">        extraLibPaths.add(&quot;/odm/lib&quot; + abiSuffix);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!defaultSearchPaths.contains(&quot;/product/lib&quot;)) &#123;</span><br><span class="line">        extraLibPaths.add(&quot;/product/lib&quot; + abiSuffix);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!extraLibPaths.isEmpty()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        try &#123;</span><br><span class="line">            // ⑥ 将 其他 lib 路径也添加到 DexPathList 中</span><br><span class="line">            ApplicationLoaders.getDefault().addNative(mClassLoader, extraLibPaths);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            StrictMode.setThreadPolicy(oldPolicy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createOrUpdateClassLoaderLocked 方法里面创建 ClassLoader 并且设置 lib 路径</p><ul><li>首先 defaultSearchPaths 默认路径，在 ①⑤中获取并放置进去，包含</li></ul><blockquote><p> /system/lib/<br>/vendor/lib/<br>/product/lib/</p></blockquote><ul><li>其次，在 ② 中 makePaths</li><li>在 ④⑥中将 libs 路径添加到 DexPathList 中</li></ul><h3 id="2-2-5-LoadedApk-makePaths"><a href="#2-2-5-LoadedApk-makePaths" class="headerlink" title="2.2.5 LoadedApk#makePaths"></a>2.2.5 LoadedApk#makePaths</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public static void makePaths(ActivityThread activityThread,</span><br><span class="line">                                 boolean isBundledApp,</span><br><span class="line">                                 ApplicationInfo aInfo,</span><br><span class="line">                                 List&lt;String&gt; outZipPaths,</span><br><span class="line">                                 List&lt;String&gt; outLibPaths) &#123;</span><br><span class="line">    final String appDir = aInfo.sourceDir;</span><br><span class="line">    // aInfo.nativeLibraryDir 的来源在 ActivityThread#getInstrumentationLibrary 中</span><br><span class="line">    final String libDir = aInfo.nativeLibraryDir;</span><br><span class="line">    final String[] sharedLibraries = aInfo.sharedLibraryFiles;</span><br><span class="line">        </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    String instrumentationLibDir = activityThread.mInstrumentationLibDir;</span><br><span class="line">    String instrumentedLibDir = activityThread.mInstrumentedLibDir;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    if (outLibPaths != null) &#123;</span><br><span class="line">        outLibPaths.add(instrumentationLibDir);</span><br><span class="line">        if (!instrumentationLibDir.equals(instrumentedLibDir)) &#123;</span><br><span class="line">            outLibPaths.add(instrumentedLibDir);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">        if (outLibPaths != null) &#123;</span><br><span class="line">        outLibPaths.add(instrumentationLibDir);</span><br><span class="line">        if (!instrumentationLibDir.equals(instrumentedLibDir)) &#123;</span><br><span class="line">            outLibPaths.add(instrumentedLibDir);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">         </span><br><span class="line">        if (outLibPaths.isEmpty()) &#123;</span><br><span class="line">            outLibPaths.add(libDir);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ① 根据 cpu 的不同添加不同路径</span><br><span class="line">        if (aInfo.primaryCpuAbi != null) &#123;</span><br><span class="line">            if (aInfo.targetSdkVersion &lt; Build.VERSION_CODES.N) &#123;</span><br><span class="line">                outLibPaths.add(&quot;/system/fake-libs&quot; +</span><br><span class="line">                    (VMRuntime.is64BitAbi(aInfo.primaryCpuAbi) ? &quot;64&quot; : &quot;&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">            for (String apk : outZipPaths) &#123;</span><br><span class="line">                outLibPaths.add(apk + &quot;!/lib/&quot; + aInfo.primaryCpuAbi);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (isBundledApp) &#123;</span><br><span class="line">outLibPaths.add(System.getProperty(&quot;java.library.path&quot;));</span><br><span class="line">        &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ① 中，会根据 cpu 架构的不同，而添加不同路径，例如，如果手机 cpu 的架构 是 armeabi-v7a, 那 <code>apk + &quot;!/lib/&quot; + aInfo.primaryCpuAbi</code> 就是</p><blockquote><p>data/app/包名==/base.apk!/lib/armeabli-v7a</p></blockquote><h3 id="2-2-6-ActivityThread-getInstrumentationLibrary"><a href="#2-2-6-ActivityThread-getInstrumentationLibrary" class="headerlink" title="2.2.6 ActivityThread#getInstrumentationLibrary"></a>2.2.6 ActivityThread#getInstrumentationLibrary</h3><p>[&gt;/frameworks/base/core/java/android/app/ActivityThread.java]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private String getInstrumentationLibrary(ApplicationInfo appInfo, InstrumentationInfo insInfo) &#123;</span><br><span class="line">    if (appInfo.primaryCpuAbi != null &amp;&amp; appInfo.secondaryCpuAbi != null</span><br><span class="line">            &amp;&amp; appInfo.secondaryCpuAbi.equals(insInfo.secondaryCpuAbi)) &#123;</span><br><span class="line">       </span><br><span class="line">        String secondaryIsa =</span><br><span class="line">                VMRuntime.getInstructionSet(appInfo.secondaryCpuAbi);</span><br><span class="line">        final String secondaryDexCodeIsa =</span><br><span class="line">                SystemProperties.get(&quot;ro.dalvik.vm.isa.&quot; + secondaryIsa);</span><br><span class="line">        secondaryIsa = secondaryDexCodeIsa.isEmpty() ? secondaryIsa : secondaryDexCodeIsa;</span><br><span class="line"></span><br><span class="line">        final String runtimeIsa = VMRuntime.getRuntime().vmInstructionSet();</span><br><span class="line">        if (runtimeIsa.equals(secondaryIsa)) &#123;</span><br><span class="line">            return insInfo.secondaryNativeLibraryDir;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return insInfo.nativeLibraryDir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ActivityThread 中的 nativeLibraryDir 通过 getInstrumentationLibrary 方法获取，也是通过 <code>SystemProperties.get(&quot;ro.dalvik.vm.isa.&quot; + secondaryIsa);</code> 系统属性获取</p><p>总的来说 NativeLibraryPath 主要是来至于几个方面</p><ul><li><p>一个是系统的 <code>java.library.path</code> 属性，是</p><blockquote><p>/system/lib<br>/vendor/lib<br>/product/lib</p></blockquote></li><li><p>一个是 <code>apk + &quot;!/lib/&quot; + aInfo.primaryCpuAbi</code> </p><blockquote><p>/data/app/包名==/base.apk!/lib/armeabli-v7a</p></blockquote></li></ul><ul><li>一个是 <code>&quot;ro.dalvik.vm.isa.&quot; + secondaryIsa</code> 属性<blockquote><p>/data/app/包名==/lib/arm</p></blockquote></li></ul><p>如下图中的 nativeLiraryPathsElements中的路径<br><img src="/2020/03/28/android-so-load/android_so_1.png" width="80%" height="30%"></p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>通过上面的分析，已经回答了我们在前言部分的三个疑问，那接下来就要解决这个异常了。<br>我们知道</p><blockquote><p>Caused by: java.lang.IllegalArgumentException: Unable to find native library  using classloader: dalvik.system.PathClassLoader</p></blockquote><p>在上面的分析知道, 通过 ClassLoader#findLibrary去 libs 路径去查找我们要加载的 so, 找不到这个 path 导致。</p><p>动态加载 so，我们在通常需要把要加载的 so 从后台下载下来，然后通过 System.load(String filename) 或者 System.loadLibrary(String libname) 方法去加载 so。</p><p>那解决这个问题就是把我们下载存放 so 的路径，添加到 ClassLoader 的 libs 路径里面，而这些 libs 路径是 app 启动的时候就应经生成了。可以利用反射，在运行时路径添加进去。</p><h3 id="将存放-so-的路径放到-ClassLoader-中"><a href="#将存放-so-的路径放到-ClassLoader-中" class="headerlink" title="将存放 so 的路径放到 ClassLoader 中"></a>将存放 so 的路径放到 ClassLoader 中</h3><p>利用反射将存放 so 的路径放到 ClassLoader 中，刚好 <a href="https://github.com/Tencent/tinker/blob/dev/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java" target="_blank" rel="noopener">tinker</a> 的 TinkerLoadLibrary 也有实现发方法，我们就不用自己实现了，可以拿过来直接使用</p><p>LoadLibrary 核心代码 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V25</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(ClassLoader classLoader, File folder)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Field pathListField = RetroShareReflectUtil.findField(classLoader, <span class="string">"pathList"</span>);</span><br><span class="line">        Object dexPathList = pathListField.get(classLoader);</span><br><span class="line"></span><br><span class="line">        Field nativeLibraryDirectories = RetroShareReflectUtil.findField(dexPathList, <span class="string">"nativeLibraryDirectories"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;File&gt; libDirs = (List&lt;File&gt;) nativeLibraryDirectories.get(dexPathList);</span><br><span class="line">        libDirs.add(<span class="number">0</span>, folder);</span><br><span class="line">        Field systemNativeLibraryDirectories =</span><br><span class="line">                RetroShareReflectUtil.findField(dexPathList, <span class="string">"systemNativeLibraryDirectories"</span>);</span><br><span class="line">        List&lt;File&gt; systemLibDirs = (List&lt;File&gt;) systemNativeLibraryDirectories.get(dexPathList);</span><br><span class="line">        Method makePathElements =</span><br><span class="line">                RetroShareReflectUtil.findMethod(dexPathList, <span class="string">"makePathElements"</span>, List.class);</span><br><span class="line">        libDirs.addAll(systemLibDirs);</span><br><span class="line">        Object[] elements = (Object[]) makePathElements.</span><br><span class="line">                invoke(dexPathList, libDirs);</span><br><span class="line">        Field nativeLibraryPathElements = RetroShareReflectUtil.findField(dexPathList, <span class="string">"nativeLibraryPathElements"</span>);</span><br><span class="line">        nativeLibraryPathElements.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        nativeLibraryPathElements.set(dexPathList, elements);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于反射的代码已放到 <a href="https://github.com/yxhuangCH/AndroidSoLoad/tree/master/soload" target="_blank" rel="noopener">github</a></p><p>我的项目下载存放 so 的路径是 /data/user/0/包名/app_libs</p><p>运行之后,我们看开点 路径已经添加进了 ClassLoader 的 nativeLibraryDirecories 中</p><p><img src="/2020/03/28/android-so-load/android_so_load_3.png" width="80%" height="30%"></p><p>至此，异常解决了。<br>同时也对 so 的加载原理有了更好的了解。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://blog.csdn.net/givemeacondom/article/details/83826645" target="_blank" rel="noopener">Android_动态加载.so文件,解决apk安装包过大的问题</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1071447" target="_blank" rel="noopener">Android 动态链接库加载原理及 HotFix 方案介绍</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1563054" target="_blank" rel="noopener">Android so 加载原理分析</a></p></li><li><p><a href="http://gityuan.com/2017/03/26/load_library/" target="_blank" rel="noopener">loadLibrary动态库加载过程分析</a></p></li><li><p><a href="http://androidxref.com/" target="_blank" rel="noopener">参考 Android 源码</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在做 Android 项目的时候，需要在 NativeActivity  中动态加载 so 。运行的时候，抛出
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>软件设计原则（一）： 依赖倒置原则</title>
    <link href="https://yxhuangch.github.io/2020/02/23/denpendence-inversion-principle/"/>
    <id>https://yxhuangch.github.io/2020/02/23/denpendence-inversion-principle/</id>
    <published>2020-02-23T00:59:24.000Z</published>
    <updated>2020-02-23T03:48:22.105Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如何不依赖代码却可以复用它的功能</p></blockquote><p>在软件设计中为了建立清晰的软件分层关系，引入了软件分层设计，也是便于高层业务模块依赖低层模块。在一般的应用软件中，策略层会依赖方法层，业务逻辑层会依赖数据存储层。</p><p><img src="/2020/02/23/denpendence-inversion-principle/dip_1.png" width="70%" height="70%"><br>图1</p><p>这是我们正常的软件设计。</p><p>但是这样的设计会带来一些问题。</p><p>策略层对方程层和工具层是传递依赖的，如果下面两层的改动，都会对策略层产生影响，这样导致的级联改动非常不利用软件的维护。</p><p>出现了上述问题，可能会想到定义策略层和工具层的接口，毕竟接口比实现更问题。</p><p>所以，会变成下面的设计关系。</p><p><img src="/2020/02/23/denpendence-inversion-principle/dip_2.png" width="70%" height="70%"><br>图2</p><p>Policy layer 层依赖的是方法层的 MechanismService 接口，而方法层会依赖工具层的 UtilityService 接口。这是通常的编程习惯，底层模块有自己的接口，高层模块依赖低层模块提供的接口。</p><p>但是我们下面不是用这种方式，而是用依赖倒置设计原则去重构。</p><p>###依赖倒置的设计原则</p><p>按照依赖倒置原则，接口的所有权是被倒置的，也就是说，接口被定义在高层模块，高层模块拥有接口，低层模块实现接口。不是高层模块依赖低层模块的接口，而是低层模块依赖高层模块的接口，从而实现依赖关系的倒置。</p><p><img src="/2020/02/23/denpendence-inversion-principle/dip_3.png" width="70%" height="70%"><br>图3</p><p>在上面的依赖层次中，每一层的接口都被高层模块定义，由低层模块实现，高层模块完全不依赖底层模块。这样低层模块的改动不会影响高层模块，高层模块的复用也不会完全依赖低层模块。</p><h3 id="使用依赖倒置实现高层模块复用"><a href="#使用依赖倒置实现高层模块复用" class="headerlink" title="使用依赖倒置实现高层模块复用"></a>使用依赖倒置实现高层模块复用</h3><p>依赖倒置原则也适用于一个类向另一个类发送消息的场景</p><p>Button 控制灯泡，按钮按下的时候，灯泡点亮或关闭。常规的设计是，Button 类直接依赖 Lamp 灯泡类</p><p><img src="/2020/02/23/denpendence-inversion-principle/dip_4.png" width="70%" height="70%"><br>图4</p><p>这样会导致问题，Button 依赖 Lamp, Lamp 的任何改动都会牵扯到 Button, 变成联级的改动。另外，如果想要 Button 控制另外一种电器，Button 变难以重用， 以为 Button 依赖着 Lamp.</p><p>解决办法是将依赖中的具体实现，改成为依赖抽象。</p><p>重构后的设计</p><p><img src="/2020/02/23/denpendence-inversion-principle/dip_5.png" width="70%" height="70%"><br>图5</p><p>抽象接口 ButtonServer 是属于高层模块 Button 的，不属于低层模块 Lamp。这样就形成了依赖倒置。</p><p>Button 不会再依赖 Lamp，而是依赖抽象的 ButtonServer, 而 Lamp 是<br>ButtonServer 的具体实现，这样 Lamp 的改动基本上就不会牵扯 Button。另外，如果想要重用 Button 控制其他设备, 只需要这些设备实现 ButtonServer 接口即可。</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>在创建对象是，一般都会是具体实现，这样就会形成一个依赖。这时，可以选择用抽象工厂模式来解决代码依赖的问题。</p><p><img src="/2020/02/23/denpendence-inversion-principle/dip_6.png" width="70%" height="70%"><br>图6</p><p>Application 通过调用 ServiceFactory接口的 makeService 方法。这个方法由 ServiceFactoryImpl 类具体提供，该方法初始化一个 ConcreteImpl 类的实例，并且将其返回 Service 类型返回。</p><p>图6中间的虚线代表着软件架构中的抽象层与具体实现层的边界。所有跨越这条边界源码级别的依赖关系都应该是单向的，即具体实现层依赖抽象层。</p><p>抽象接口层包含了应用的所有高阶业务规则，具体实现层则包括了这些业务规则需要做的具体操作及其相关的细节信息。</p><p>图6中控制流跨越边界（虚线）的方向与源代码依赖关系跨越该边界的反向相反，源代码依赖用于是控制流方向反向，这就是依赖倒置。</p><h3 id="依赖导致原则"><a href="#依赖导致原则" class="headerlink" title="依赖导致原则"></a>依赖导致原则</h3><ul><li>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口</li><li>抽象接口不应该依赖于具体实现，而具体实现则应该依赖于抽象接口</li></ul><p>高层：业务逻辑<br>底层：UI,底层配置（数据库等）</p><p>高层模块不依赖低层模块，而是依赖抽象接口，这个接口是由高层模块定义，低层模块实现</p><p>应用规则：</p><ul><li><ol><li>应用代码多使用抽象接口，尽量避免使用多变的具体实现类</li></ol></li><li><ol start="2"><li>不要继承具体类，除非是抽象类</li></ol></li><li><ol start="3"><li>不要重写 override, 包含具体实现的函数</li></ol></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://book.douban.com/subject/30333919/" target="_blank" rel="noopener">《架构整洁之道》</a>第11章：DIP 依赖反转原则</li><li><a href="https://time.geekbang.org/column/article/179282" target="_blank" rel="noopener">极客时间-李智慧·后端技术面试38讲</a>  12 | 软件设计的依赖倒置原则：如何不依赖代码却可以复用它的功能</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;如何不依赖代码却可以复用它的功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在软件设计中为了建立清晰的软件分层关系，引入了软件分层设计，也是便于高层业务模块依赖低层模块。在一般的应用软件中，策略层会依赖方法层，业务逻辑层会依赖数据存储层。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="软件设计" scheme="https://yxhuangch.github.io/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
</feed>
